//-----------------------------------------------------------------------------
// gfx
//-----------------------------------------------------------------------------
package gfx

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
import "mat"
import "gl"
import "uti"

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_vaos []i32
var g_vaoCount i32 = 0

var g_vbos []i32
var g_vboCount i32 = 0

//var g_shaders[]i32
//var g_shaderCount i32 = 0

var g_programs []i32
var g_programCount i32 = 0

var g_textures []i32
var g_textureCount i32 = 0

var g_framebuffers []i32
var g_framebufferCount i32 = 0

var g_sizeofFloat i32 = 4

var g_blend bool = false
var g_srcBlend i32 = 0
var g_dstBlend i32 = 0

var g_depth bool = false

var g_clearColor mat.v4

var red mat.v4
var green mat.v4
var blue mat.v4
var pink mat.v4
var white mat.v4
var black mat.v4
var zero mat.v4

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type target_s struct {
    framebuffer i32
    texture i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type mesh_s struct {
    vertices [540]f32
    attributes [3]i32
    primitive i32
    vao i32
    vbo i32
    stride i32
    floatCount i32
    vertexCount i32
    dataSize i32
    bufferSize i32
    index i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func glerror() (error bool) {
    error = false
    var glerr i32 = -1
    for glerr != 0  {
        glerr = gl.GetError()
        if  glerr != 0 {
            error = true
            if glerr == gl.INVALID_ENUM {
                printf("GL_INVALID_ENUM\n")
            } else if glerr == gl.INVALID_VALUE {
                printf("GL_INVALID_VALUE\n")
            } else if glerr == gl.INVALID_OPERATION {
                printf("GL_INVALID_OPERATION\n")
            } else if glerr == gl.STACK_OVERFLOW {
                printf("GL_STACK_OVERFLOW\n")
            } else if glerr == gl.STACK_UNDERFLOW {
                printf("GL_STACK_UNDERFLOW\n")
            } else if glerr == gl.OUT_OF_MEMORY {
                printf("GL_OUT_OF_MEMORY\n")
            } else if glerr != 0 {
                uti.assert_(false, "invalid glError\n")
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func no_glerror() (noerror bool) {
    var error bool = glerror()
    noerror = error == false // panic if noerror = (glerror() == false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func glstatus() (error bool) {
    error = false
    var glstat i32
    glstat = gl.CheckFramebufferStatus(gl.FRAMEBUFFER)
    uti.assert_(no_glerror(), "CheckFramebufferStatus")
    if (glstat != gl.FRAMEBUFFER_COMPLETE) {
        error = true;
        if (glstat == gl.FRAMEBUFFER_UNDEFINED) {
            printf("GL_FRAMEBUFFER_UNDEFINED\n")
        } else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT) {
            printf("GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n")
        } else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) {
            printf("GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\n")
        } else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER) {
            printf("GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER\n")
        } else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_READ_BUFFER) {
            printf("GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER\n")
        } else if (glstat == gl.FRAMEBUFFER_UNSUPPORTED) {
            printf("GL_FRAMEBUFFER_UNSUPPORTED\n")
        } else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
            printf("GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE\n")
        } else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS) {
            printf("GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS\n")
        } else {
            uti.assert_(false, "invalid glFramebufferStatus")
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func no_glstatus() (nostatus bool) {
    var status bool = glstatus()
    nostatus = status == false // panic if nostatus = (glstatus() == false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func enable_blending(srcBlend i32, dstBlend i32) () {
	if (g_blend == false) {
		gl.Enable(gl.BLEND)
		uti.assert_(no_glerror(), "gl.Enable(gl.BLEND)")
		if ((g_srcBlend != srcBlend) || (g_dstBlend != dstBlend)) {
			gl.BlendFunc(srcBlend, dstBlend)
		    uti.assert_(no_glerror(), "gl.BlendFunc")
		}
		g_blend = true
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func disable_blending() () {
	if (g_blend == true) {
		gl.Disable(gl.BLEND)
		uti.assert_(no_glerror(), "gl.Disable(gl.BLEND)")
		g_blend = false
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func enable_depth() () {
	if (g_depth == false) {
		gl.Enable(gl.DEPTH_TEST)
		uti.assert_(no_glerror(), "gl.Enable(gl.DEPTH_TEST)")
		g_depth = true
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func disable_depth() () {
	if (g_depth == true) {
		gl.Disable(gl.DEPTH_TEST)
		uti.assert_(no_glerror(), "gl.Disable(gl.DEPTH_TEST)")
		g_depth = false
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func clear(buffers i32, color mat.v4) () {
	if ((g_clearColor.x != color.x) ||
		(g_clearColor.y != color.y) ||
		(g_clearColor.z != color.z) ||
		(g_clearColor.w != color.w)) {
		g_clearColor = color
		gl.ClearColor(g_clearColor.x, g_clearColor.y, g_clearColor.z, g_clearColor.w)
		uti.assert_(no_glerror(), "gl.ClearColor")
	}
	gl.Clear(buffers)
	uti.assert_(no_glerror(), "gl.Clear")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func init(width i32, height i32)() {

	red   = mat.v4_(1.0, 0.0, 0.0, 1.0)
	green = mat.v4_(0.0, 1.0, 0.0, 1.0)
	blue  = mat.v4_(0.0, 0.0, 1.0, 1.0)
	pink  = mat.v4_(1.0, 0.0, 1.0, 1.0)
	white = mat.v4_(1.0, 1.0, 1.0, 1.0)
	zero  = mat.v4_(0.0, 0.0, 0.0, 0.0)

	g_clearColor = pink

    gl.Strs("i_v3Position", "i_v3Position")
    gl.Strs("i_v4Albedo", "i_v4Albedo")
    gl.Strs("i_v2Texcoord", "i_v2Texcoord")
    gl.Strs("u_t2Albedo", "u_t2Albedo")
    gl.Strs("u_t2Src", "u_t2Src")
    gl.Strs("u_t2Dst", "u_t2Dst")
    gl.Strs("u_fTime", "u_fTime")

    //-----------------------------------------------------------------------------
    // vsPassThrough
    //-----------------------------------------------------------------------------
    gl.Strs(
    `
    #version 130
    in vec3 i_v3Position;
    in vec4 i_v4Albedo;
    in vec2 i_v2Texcoord;
    out vec4 v_v4Albedo;
    out vec2 v_v2Texcoord;
    void main()
    {
        gl_Position = vec4(i_v3Position.rg, 0.0, 1);
        v_v4Albedo = i_v4Albedo;
        v_v2Texcoord = i_v2Texcoord;
    }`, "vsPassThrough")

    //-----------------------------------------------------------------------------
    // psVertexColor
    //-----------------------------------------------------------------------------
    gl.Strs(
    `
    #version 130
    in vec4 v_v4Albedo;
    out vec4 o_v4Color;
    void main()
    {
        o_v4Color = v_v4Albedo;
    }
    `, "psVertexColor")

    //-----------------------------------------------------------------------------
    // psVertexTexture
    //-----------------------------------------------------------------------------
    gl.Strs(
    `
    #version 130
    uniform sampler2D u_t2Albedo;
    in vec4 v_v4Albedo;
    in vec2 v_v2Texcoord;
    out vec4 o_v4Color;
    void main()
    {
        o_v4Color = v_v4Albedo * texture2D(u_t2Albedo, v_v2Texcoord);
    }
    `, "psTexture")

    //-----------------------------------------------------------------------------
    // psTransition_0
    //-----------------------------------------------------------------------------
    gl.Strs(
    `
    #version 130
    uniform sampler2D u_t2Src;
    uniform sampler2D u_t2Dst;
    uniform float u_fTime;
    in vec2 v_v2Texcoord;
    out vec4 o_v4Color;
    void main()
    {
        o_v4Color = mix(texture2D(u_t2Src, v_v2Texcoord), texture2D(u_t2Dst, v_v2Texcoord), u_fTime);
    }
    `, "psTransition_0")

    //-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    gl.Init()
    uti.assert_(no_glerror(), "gl.Init")

    gl.Disable(gl.BLEND)
    uti.assert_(no_glerror(), "gl.Disable(gl.BLEND)")

    gl.Disable(gl.CULL_FACE)
    uti.assert_(no_glerror(), "gl.Disable(gl.CULL_FACE)")

    gl.Disable(gl.DEPTH_TEST)
    uti.assert_(no_glerror(), "gl.Disable(gl.DEPTH_TEST)")

    gl.ClearColor(g_clearColor.x, g_clearColor.y, g_clearColor.z, g_clearColor.w)
    uti.assert_(no_glerror(), "gl.ClearColor")

    gl.Viewport(0, 0, width, height)
    uti.assert_(no_glerror(), "gl.Viewport")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func free()() {

    gl.Free("vsPassThrough")
    gl.Free("psVertexColor")
    gl.Free("psTexture")
    gl.Free("psTransition_0")
    gl.Free("i_v3Position")
    gl.Free("i_v4Albedo")
    gl.Free("i_v2Texcoord")
    gl.Free("u_t2Albedo")
    gl.Free("u_t2Src")
    gl.Free("u_t2Dst")
    gl.Free("u_fTime")

    use_program(0)

    var i i32
    for i = 0; i < g_programCount; i = i + 1 {
        printf("gl.DeleteProgram(%d)\n", g_programs[i])
        gl.DeleteProgram(g_programs[i]) // ##0 crash
        uti.assert_(no_glerror(), "gl.DeleteProgram")
    }

    for i = 0; i < g_vboCount; i = i + 1 {
        printf("gl.DeleteBuffers(%d)\n", g_vbos[i])
        gl.DeleteBuffers(1, g_vbos[i])
        uti.assert_(no_glerror(), "glDeleteBuffers")
    }

    for i = 0; i < g_vaoCount; i = i + 1 {
        printf("gl.DeleteVertexArrays(%d)\n", g_vaos[i])
        gl.DeleteVertexArrays(1, g_vaos[i])
        uti.assert_(no_glerror(), "g_DeleteVertexArrays")
    }

	for i = 0; i < g_framebufferCount; i = i + 1 {
		printf("gl.DeleteFramebuffers(%d)\n", g_framebuffers[i])
		gl.DeleteFramebuffers(1, g_framebuffers[i])
		uti.assert_(no_glerror(), "g.DeleteFramebuffers")
	}

	for i = 0; i < g_textureCount; i = i + 1 {
		printf("gl.DeleteTextures(%d)\n", g_textures[i])
		gl.DeleteTextures(1, g_textures[i])
		uti.assert_(no_glerror(), "g.DeleteTextures")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_texture(path str, mag i32, min i32, s i32, t i32, r i32, w i32, h i32) (texture i32) {
    if (path == "") {
        texture = gl.GenTextures(1, texture)
        uti.assert_(no_glerror(), "gl.GenTextures")
    } else {
        texture = gl.NewTexture(path)
        uti.assert_(no_glerror(), "gl.NewTexture")
    }

    g_textures = append(g_textures, texture)
    g_textureCount= g_textureCount + 1 // pre increment not working

    gl.BindTexture(gl.TEXTURE_2D, texture)
    uti.assert_(no_glerror(), "gl.BindTexture")

    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    uti.assert_(no_glerror(), "gl.TexParameteri")

    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
    uti.assert_(no_glerror(), "gl.TexParameteri")

    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    uti.assert_(no_glerror(), "gl.TexParameteri")

    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
    uti.assert_(no_glerror(), "gl.TexParameteri")

    gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE)
    uti.assert_(no_glerror(), "gl.TexParameteri")

    if (path == "") {
        gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, 0)
        uti.assert_(no_glerror(), "gl.Image2D")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_target(w i32, h i32) (target target_s) {
    var framebuffer i32 = -1
    var texture i32 = -1

    framebuffer = gl.GenFramebuffers(1, framebuffer)
    uti.assert_(no_glerror(), "gl.GenFramebuffers")
    printf("FRAMEBUFFER_0 : %d\n", framebuffer)
    g_framebuffers = append(g_framebuffers, framebuffer)
    g_framebufferCount = g_framebufferCount + 1 // pre increment not working

    gl.BindFramebuffer(gl.FRAMEBUFFER, framebuffer)
    uti.assert_(no_glerror(), "gl.BindFramebuffer")
    texture = create_texture("", gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, w, h)

    gl.FramebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0)
    uti.assert_(no_glerror(), "gl.FramebufferTexture2D")

    uti.assert_(no_glstatus(), "gl.CheckFramebufferStatus")

    gl.BindFramebuffer(gl.FRAMEBUFFER, 0)
    uti.assert_(no_glerror(), "gl.BindFramebuffer")
    uti.assert_(no_glstatus(), "gl.CheckFramebufferStatus")

    target.framebuffer = framebuffer
    target.texture = texture
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func bind_framebuffer(framebuffer i32) {
	gl.BindFramebuffer(gl.FRAMEBUFFER, framebuffer)
	uti.assert_(no_glerror(), "gl.BindFramebuffer")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_program(vertex str, pixel str)(program i32) {

    // vertex shader
    var vertexShader i32 = gl.CreateShader(gl.VERTEX_SHADER)
    uti.assert_(no_glerror(), "gl.CreateShader")
    //shaders = append(shaders, vertexShader) // cache shader creationg
    //++shaderCount

    gl.ShaderSource(vertexShader, 1, vertex)
    uti.assert_(no_glerror(), "gl.ShaderSource")

    gl.CompileShader(vertexShader)
    uti.assert_(no_glerror(), "gl.CompileShader")

    // pixel shader
    var pixelShader i32 = gl.CreateShader(gl.FRAGMENT_SHADER)
    uti.assert_(no_glerror(), "gl.CreateShader")
    //shaders = append(shaders, pixelShader) // cache shader creation
    //++shaderCount

    gl.ShaderSource(pixelShader, 1, pixel)
    uti.assert_(no_glerror(), "gl.ShaderSource")

    gl.CompileShader(pixelShader)
    uti.assert_(no_glerror(), "gl.CompileShader")

    // program
    program = gl.CreateProgram()
    uti.assert_(no_glerror(), "gl.CreateProgram")
    g_programs = append(g_programs, program)
    g_programCount = g_programCount + 1 // pre increment not working

    gl.AttachShader(program, vertexShader)
    uti.assert_(no_glerror(), "gl.AttachShader")

    gl.AttachShader(program, pixelShader)
    uti.assert_(no_glerror(), "gl.AttachShader")

    gl.LinkProgram(program)
    uti.assert_(no_glerror(), "gl.LinkProgram")

    gl.DetachShader(program, vertexShader)
    uti.assert_(no_glerror(), "gl.LinkProgram")

    gl.DetachShader(program, pixelShader)
    uti.assert_(no_glerror(), "gl.DetachShader")

    gl.DeleteShader(vertexShader)
    uti.assert_(no_glerror(), "gl.DeleteShader")

    gl.DeleteShader(pixelShader)
    uti.assert_(no_glerror(), "gl.DeleteShader")

    return program
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func use_program(program i32) {
    //printf("use_program(%d)\n", program)
    gl.UseProgram(program)
    uti.assert_(no_glerror(), "gl.UseProgram")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func bind_attribute(program i32, location i32, name str) () {

    gl.BindAttribLocation(program, location, name)
    uti.assert_(no_glerror(), "gl.BindAttribute")

    var newLocation i32 = gl.GetAttribLocation(program, name)
    uti.assert_(no_glerror(), "gl.GetAttribLocation")
    uti.assert_(newLocation == location, "attribute not found\n")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func bind_texture(program i32, name str) (sampler i32) {
    sampler = bind_uniform(program, name)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func bind_uniform(program i32, name str) (uniform i32) {
    uniform = gl.GetUniformLocation(program, name) // ##2 crash find a way to test if str is present in gl.Strs
    uti.assert_(no_glerror(), "gl.GetUniformLocation")
    uti.assert_(uniform >= 0, "uniform>= 0")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func assign_texture(slot i32, sampler i32, texture i32) () {
    gl.ActiveTexture(gl.TEXTURE0 + slot)
    uti.assert_(no_glerror(), "gl.ActiveTexture")

    gl.BindTexture(gl.TEXTURE_2D, texture)
    uti.assert_(no_glerror(), "gl.BindTexture")

    gl.Uniform1i(sampler, slot)
    uti.assert_(no_glerror(), "gl.Uniform1i")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func assign_float(slot i32, value f32) {
    gl.Uniform1f(slot, value)
    uti.assert_(no_glerror(), "gl.Uniform1f")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func alloc_mesh(mesh *mesh_s, primitive i32, attributes [3]i32, vertexCount i32) () { // make it work with slices

    uti.assert_((primitive == gl.TRIANGLES || primitive == gl.LINES), "(primitive == gl.TRIANGLES || primitive == gl.LINES)")
    uti.assert_(vertexCount > 0, "vertexCount > 0")

    if primitive == gl.TRIANGLES {
        uti.assert_((vertexCount % 3) == 0, "(vertexCount % 3) == 0")
    } else if primitive == gl.LINES {
        uti.assert_((vertexCount % 2) == 0, "(vertexCount % 2) == 0")
    }
    (*mesh).attributes = attributes
    (*mesh).primitive = primitive
    (*mesh).vao = 0
    (*mesh).vbo = 0
    (*mesh).stride = 0
    (*mesh).floatCount = 0
    (*mesh).vertexCount = 0
    (*mesh).dataSize = 0
    (*mesh).bufferSize = 0
    (*mesh).index = 0;

    // stride
    var i i32 = 0
    var attributeCount i32 = len(attributes)
    var stride i32 = 0
    printf("attributeCount %d\n", attributeCount)
    for i = 0; i < attributeCount; i = i + 1 {
        (*mesh).stride = (*mesh).stride + attributes[i]
        stride = stride + attributes[i]
        printf("(*mesh).stride %d, stride %d, attributes[i] %d\n", (*mesh).stride, stride, attributes[i])
    }
    uti.assert_((*mesh).stride > 0, "(*mesh).stride > 0")

    var floatCount i32 = (*mesh).stride * vertexCount
    var bufferSize i32 = floatCount * g_sizeofFloat
    uti.assert_(bufferSize > 0, "bufferSize > 0")
    uti.assert_((floatCount  % (*mesh).stride) == 0, "(floatCount % (*mesh).stride) == 0")
    (*mesh).bufferSize = bufferSize

    // vbo
    (*mesh).vbo = gl.GenBuffers(1, (*mesh).vbo)
    uti.assert_(no_glerror(), "gl.GenBuffers")
    g_vbos = append(g_vbos, (*mesh).vbo)
    g_vboCount = g_vboCount + 1

    gl.BindBuffer(gl.ARRAY_BUFFER, (*mesh).vbo)
    uti.assert_(no_glerror(), "gl.BindBuffer")

    // vao
    (*mesh).vao = gl.GenVertexArrays(1, (*mesh).vao)
    uti.assert_(no_glerror(), "gl.GenVertexArrays")
    g_vaos = append(g_vaos, (*mesh).vao)
    g_vaoCount = g_vaoCount + 1;

    gl.BindVertexArray((*mesh).vao)
    uti.assert_(no_glerror(), "gl.BindVertexArray")

    gl.BindBuffer(gl.ARRAY_BUFFER, (*mesh).vbo)
    uti.assert_(no_glerror(), "gl.BindBuffer")

    printf("bufferSize %d\n", bufferSize)
    //var null *i32 = 0
    var null []f32
    gl.BufferData(gl.ARRAY_BUFFER, bufferSize, null, gl.DYNAMIC_DRAW)
    uti.assert_(no_glerror(), "gl.BufferData")

    var offset i32 = 0
    for i = 0; i < attributeCount; i = i + 1 {
        printf("VertexAttribPointer %d, %d, %d, %d\n", i, attributes[i], (*mesh).stride * g_sizeofFloat, offset)

        gl.EnableVertexAttribArray(i)
        uti.assert_(no_glerror(), "gl.EnableVertexAttribArray")

        gl.VertexAttribPointer(i, attributes[i], gl.FLOAT, false, (*mesh).stride * g_sizeofFloat, offset)
        uti.assert_(no_glerror(), "gl.VertexAttribPointer")

        offset = offset + g_sizeofFloat * attributes[i]
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func begin_mesh(mesh *mesh_s) () {
    (*mesh).index = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func end_mesh(mesh* mesh_s) () {

    if (*mesh).index > 0 {
        (*mesh).floatCount = (*mesh).index //len(g_vertices)
        //printf("floatCount %d\n", (*mesh).floatCount)

        (*mesh).dataSize = (*mesh).floatCount * g_sizeofFloat
        //printf("dataSize %d\n", (*mesh).dataSize)

        //printf("stride %d\n", (*mesh).stride)
        uti.assert_(((*mesh).floatCount % (*mesh).stride) == 0, "((*mesh).floatCount % (*mesh).stride)) == 0")

        (*mesh).vertexCount = (*mesh).floatCount / (*mesh).stride
        //printf("vertexCount %d\n", (*mesh).vertexCount)

        //printf("(*mesh).vbo %d\n", (*mesh).vbo)
        gl.BindBuffer(gl.ARRAY_BUFFER, (*mesh).vbo)
        uti.assert_(no_glerror(), "gl.BindBuffer")

        gl.BufferSubData(gl.ARRAY_BUFFER, 0, (*mesh).dataSize, (*mesh).vertices)
        uti.assert_(no_glerror(), "gl.BufferSubData")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_mesh(mesh* mesh_s) {
    gl.BindVertexArray((*mesh).vao)
    uti.assert_(no_glerror(), "gl.BindVertexArray")

    //printf("render mesh %d\n", (*mesh).vertexCount)
    gl.DrawArrays((*mesh).primitive, 0, (*mesh).vertexCount)
    uti.assert_(no_glerror(), "gl.DrawArrays")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func append_line(mesh *mesh_s, line mat.v4, color mat.v4) () {
    uti.assert_((*mesh).primitive == gl.LINES, "(*mesh).primitive == gl.LINES")

	var x0 f32 = line.x
	var y0 f32 = line.y
	var x1 f32 = line.z
	var y1 f32 = line.w

	var r f32 = color.x
	var g f32 = color.y
	var b f32 = color.z
	var a f32 = color.w

    var index i32 = (*mesh).index
    (*mesh).vertices[index] = x0
    index = index + 1
    (*mesh).vertices[index] = y0
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1

    (*mesh).vertices[index] = x1
    index = index + 1
    (*mesh).vertices[index] = y1
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1

    (*mesh).index = index
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func append_quad(mesh *mesh_s, rect mat.v4, color mat.v4) {
    uti.assert_((*mesh).primitive == gl.TRIANGLES, "(*mesh).primitive == gl.TRIANGLES")

	var x f32 = rect.x
	var y f32 = rect.y
	var w f32 = rect.z
	var h f32 = rect.w

	var r f32 = color.x
	var g f32 = color.y
	var b f32 = color.z
	var a f32 = color.w

    var index i32 = (*mesh).index
    var x1 f32 = x + w
    var y1 f32 = y + h

    (*mesh).vertices[index] = x
    index = index + 1
    (*mesh).vertices[index] = y
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1

    (*mesh).vertices[index] = x1
    index = index + 1
    (*mesh).vertices[index] = y
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1

    (*mesh).vertices[index] = x
    index = index + 1
    (*mesh).vertices[index] = y1
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1

    (*mesh).vertices[index] = x
    index = index + 1
    (*mesh).vertices[index] = y1
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1

    (*mesh).vertices[index] = x1
    index = index + 1
    (*mesh).vertices[index] = y
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1

    (*mesh).vertices[index] = x1
    index = index + 1
    (*mesh).vertices[index] = y1
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1


  /*(*mesh).vertices[index + 0] = x
    (*mesh).vertices[index + 1] = y
    (*mesh).vertices[index + 2] = 0.0
    (*mesh).vertices[index + 3] = r
    (*mesh).vertices[index + 4] = g
    (*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
    (*mesh).vertices[index + 7] = 0.0
    (*mesh).vertices[index + 8] = 1.0
    index = index + 9

    (*mesh).vertices[index + 0] = x1
    (*mesh).vertices[index + 1] = y
    (*mesh).vertices[index + 2] = 0.0
    (*mesh).vertices[index + 3] = r
    (*mesh).vertices[index + 4] = g
    (*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
    (*mesh).vertices[index + 7] = 1.0
    (*mesh).vertices[index + 8] = 1.0
    index = index + 9

    (*mesh).vertices[index + 0] = x
    (*mesh).vertices[index + 1] = y1
    (*mesh).vertices[index + 2] = 0.0
    (*mesh).vertices[index + 3] = r
    (*mesh).vertices[index + 4] = g
    (*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
    (*mesh).vertices[index + 7] = 0.0
    (*mesh).vertices[index + 8] = 0.0
    index = index + 9

    (*mesh).vertices[index + 0] = x
    (*mesh).vertices[index + 1] = y1
    (*mesh).vertices[index + 2] = 0.0
    (*mesh).vertices[index + 3] = r
    (*mesh).vertices[index + 4] = g
    (*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
    (*mesh).vertices[index + 7] = 0.0
    (*mesh).vertices[index + 8] = 0.0
    index = index + 9

    (*mesh).vertices[index + 0] = x1
    (*mesh).vertices[index + 1] = y
    (*mesh).vertices[index + 2] = 0.0
    (*mesh).vertices[index + 3] = r
    (*mesh).vertices[index + 4] = g
    (*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
    (*mesh).vertices[index + 7] = 1.0
    (*mesh).vertices[index + 8] = 1.0
    index = index + 9

    (*mesh).vertices[index + 0] = x1
    (*mesh).vertices[index + 1] = y1
    (*mesh).vertices[index + 2] = 0.0
    (*mesh).vertices[index + 3] = r
    (*mesh).vertices[index + 4] = g
    (*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
    (*mesh).vertices[index + 7] = 1.0
    (*mesh).vertices[index + 8] = 0.0
    index = index + 9*/

    (*mesh).index = index
}


