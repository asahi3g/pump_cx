//-----------------------------------------------------------------------------
// gui
//-----------------------------------------------------------------------------
package gui

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
import "app"
import "gl"
import "gltext"
import "gfx"
import "mat"
import "uti"

//-----------------------------------------------------------------------------
// gfx
//-----------------------------------------------------------------------------
var g_opaqueVertexColoredLines      gfx.mesh_id
var g_alphaVertexColoredTriangles   gfx.mesh_id
var g_opaqueVertexColoredTriangles  gfx.mesh_id
var g_fullscreenQuad                gfx.mesh_id

var g_skycoinTexture gfx.texture_s

//-----------------------------------------------------------------------------
// GUI
//-----------------------------------------------------------------------------
var GUI_INVALID     i32 = 0
var GUI_CONTROL     i32 = 1
var GUI_SCREEN      i32 = 2
var GUI_PICTURE     i32 = 3
var GUI_LABEL       i32 = 4
var GUI_PARTITION   i32 = 5
var GUI_KEYBOARD    i32 = 6
var GUI_WINDOW      i32 = 7

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var STATE_CLOSED    i32 = 0
var STATE_SHOWING   i32 = 1
var STATE_OPENED    i32 = 2
var STATE_CLOSING   i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var DOCK_NONE       i32 = 0
var DOCK_LEFT       i32 = 1
var DOCK_RIGHT      i32 = 2
var DOCK_TOP        i32 = 3
var DOCK_BOTTOM     i32 = 4
var DOCK_FILL       i32 = 5

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var DIALOG_NONE      i32 = 0
var DIALOG_OK        i32 = 1
var DIALOG_OK_CANCEL i32 = 2
var DIALOG_YES_NO    i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var ALIGN_NONE          i32 =  0
var ALIGN_LEFT          i32 =  1
var ALIGN_RIGHT         i32 =  2
var ALIGN_HORZ          i32 =  3
var ALIGN_BOTTOM        i32 =  4
var ALIGN_LEFT_BOTTOM   i32 =  5
var ALIGN_RIGHT_BOTTOM  i32 =  6
var ALIGN_HORZ_BOTTOM   i32 =  7
var ALIGN_TOP           i32 =  8
var ALIGN_LEFT_TOP      i32 =  9
var ALIGN_RIGHT_TOP     i32 = 10
var ALIGN_HORZ_TOP      i32 = 11
var ALIGN_VERT          i32 = 12
var ALIGN_VERT_LEFT     i32 = 13
var ALIGN_VERT_RIGHT    i32 = 14
var ALIGN_CENTER        i32 = 15

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTOSIZE_NONE   i32 = 0
var AUTOSIZE_X      i32 = 1
var AUTOSIZE_Y      i32 = 2
var AUTOSIZE        i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTORATIO_NONE  i32 = 0
var AUTORATIO_X     i32 = 1
var AUTORATIO_Y     i32 = 2

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTOSCALE_NONE  i32 = 0
var AUTOSCALE_X     i32 = 1
var AUTOSCALE_Y     i32 = 2
var AUTOSCALE       i32 = 3


//-----------------------------------------------------------------------------
// DUMMY
//-----------------------------------------------------------------------------
/*type dummy_id struct {
    dummy i32
    control i32
}

type dummy_s struct {
    id dummy_id
}

func dummy_id_(base control_id, dummy i32) (out dummy_id) {
    out.base = base
    out.dummy = dummy
    uti.assert_(is_valid_dummy(out), "dummy_id_: invalid id")
}

func is_valid_dummy(id dummy_id) (out bool) {
    out = id.dummy >= 0 && id.dummy < g_dummyCount && is_valid_control(id.base)
}

var g_dummys[8] dummy_s
var g_dummyCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_dummy(name str) (out dummy_id) {
    out.dummy = g_dummyCount
    out.control = create_control_(name, GUI_DUMMY, out.dummy)

    var dummy dummy_s
    dummy.id = out

    g_dummys[out.dummy] = dummy
    g_dummyCount = out.dummy + 1
    uti.assert_(is_valid_dummy(out), "create_dummy : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize_dummy(id dummy_id) () {
    uti.assert_(is_valid_dummy(id), "resize_dummy : invalid id")
    resize_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_dummy(id dummy_id) () {
    uti.assert_(is_valid_dummy(id), "render_dummy : invalid id")
    render_control(id.base)
}*/


//-----------------------------------------------------------------------------
// FONT
//-----------------------------------------------------------------------------
type font_id struct {
    font i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type font_s struct {
    id font_id
    name str
    path str
    min i32
    max i32
    direction i32
    textureCount i32
    textures [8]texture_s
    names [8]str
    sizes [8]i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_fonts [8]font_s
var g_fontCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_font()(out font_id) {
    out.font = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_font(id font_id) (out bool) {
    out = id.font >= 0 && id.font < g_fontCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_font(name str, path str, min i32, max i32, direction i32) (out font_id) {
    out.font = g_fontCount

    var font font_s
    font.id = out
    font.name = name
    font.path = path
    font.min = min
    font.max = max
    font.direction = direction
    font.textureCount = 0

    g_fonts[out.font] = font
    g_fontCount = out.font + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func font_add_size(id font_id, size i32) {
    uti.assert_(is_valid_font(id), "font_add_size : invalid id")

    var index i32 = id.font

    var name str
    name = g_fonts[index].name

    var path str
    path = g_fonts[index].path

    var min i32 = g_fonts[index].min
    var max i32 = g_fonts[index].max
    var dir i32 = g_fonts[index].direction

    var textureName str
    textureName = sprintf("%s_%d", name, size)

    var textureCount i32 = g_fonts[index].textureCount
    printf("font_add_size %d, : %s, %d\n", textureCount, textureName, size)
    g_fonts[index].textures[textureCount] = gfx.create_font_texture(textureName, path, size, min, max, dir)
    g_fonts[index].names[textureCount] = textureName
    g_fonts[index].sizes[textureCount] = size

    g_fonts[index].textureCount = textureCount + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func font_get_texture_index(id font_id, size i32) (out i32) {
    uti.assert_(is_valid_font(id), "font_get_texture_index : invalid id")

    var textureCount i32 = g_fonts[id.font].textureCount

    out = -1
    var minSize i32 = size

    var i i32 = 0
    for i= 0 ; i < textureCount; i = i + 1 {
        var fontSize i32 = g_fonts[id.font].sizes[i]
        //printf("i %d, FONT_SIZE %d, size %d, minSize %d\n", i, fontSize, size, minSize)
        if (fontSize >= size && fontSize <= minSize) {
            out = i
        }
    }

    //printf("TEXTURE_INDEX %d\n", out)
}

//-----------------------------------------------------------------------------
// SCOPE
//-----------------------------------------------------------------------------
var g_docks [32]bound_s
var g_offsets [32]rectangle_s
var g_scopeIndex i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type bound_s struct {
    left f32
    bottom f32
    right f32
    top f32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type rectangle_s struct {
    x f32
    y f32
    width f32
    height f32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_dock bound_s
var g_offset rectangle_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func reset_scope()() {
    uti.assert_(g_scopeIndex == 0, "invalid scope")
    g_scopeIndex = 0

    g_dock.left = 0.0
    g_dock.bottom = 0.0
    g_dock.right = 2.0
    g_dock.top = 2.0

    g_offset.x = -1.0
    g_offset.y = -1.0
    g_offset.width = 2.0
    g_offset.height = 2.0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func push_scope()() {
    g_docks[g_scopeIndex] = g_dock
    g_offsets[g_scopeIndex] = g_offset
    g_scopeIndex = g_scopeIndex + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func pop_scope() () {
    uti.assert_(g_scopeIndex > 0, "stack underflow")
    g_scopeIndex = g_scopeIndex - 1
    g_dock = g_docks[g_scopeIndex]
    g_offset = g_offsets[g_scopeIndex]
}

//-----------------------------------------------------------------------------
// LAYER_SKIN
//-----------------------------------------------------------------------------
var g_layerSkins [256]layer_skin_s
var g_layerSkinCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type layer_skin_id struct {
    layer i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_layer_skin() (out layer_skin_id) {
    out.layer = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type layer_skin_s struct {
    id layer_skin_id
    name str
    surface     mat.v4
    left        mat.v4
    bottom      mat.v4
    right       mat.v4
    top         mat.v4
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_layer_skin(id layer_skin_id) (out bool) {
    out = id.layer >= 0 && id.layer < g_layerSkinCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_layer_skin(name str, surface mat.v4, left mat.v4, bottom mat.v4, right mat.v4, top mat.v4) (out layer_skin_id) {
    out.layer = g_layerSkinCount

    var layer layer_skin_s
    layer.id  = out
    layer.name    = name
    layer.surface = surface
    layer.left    = left
    layer.bottom  = bottom
    layer.right   = right
    layer.top     = top

    g_layerSkins[out.layer] = layer
    g_layerSkinCount = out.layer + 1
    uti.assert_(is_valid_layer_skin(out), "create_layer_skin : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func layer_skin_print(message str, id layer_skin_id) {
    uti.assert_(is_valid_layer_skin(id), "layer_skin_print : invalid id")
    var index i32 = id.layer
    printf("%s LAYER_SKIN %d - %s, SURFACE %f, %f, %f, %f, LEFT %f, %f, %f, %f, BOTTOM %f, %f, %f, %f, RIGHT %f, %f, %f, %f, TOP %f, %f, %f, %f\n",
        message,
        g_layerSkins[index].id.layer,
        g_layerSkins[index].name,
        g_layerSkins[index].surface.x,
        g_layerSkins[index].surface.y,
        g_layerSkins[index].surface.z,
        g_layerSkins[index].surface.w,
        g_layerSkins[index].left.x,
        g_layerSkins[index].left.y,
        g_layerSkins[index].left.z,
        g_layerSkins[index].left.w,
        g_layerSkins[index].bottom.x,
        g_layerSkins[index].bottom.y,
        g_layerSkins[index].bottom.z,
        g_layerSkins[index].bottom.w,
        g_layerSkins[index].right.x,
        g_layerSkins[index].right.y,
        g_layerSkins[index].right.z,
        g_layerSkins[index].right.w,
        g_layerSkins[index].top.x,
        g_layerSkins[index].top.y,
        g_layerSkins[index].top.z,
        g_layerSkins[index].top.w)
}

//-----------------------------------------------------------------------------
// CONTROL_SKIN
//-----------------------------------------------------------------------------
var g_controlSkins [256]control_skin_s
var g_controlSkinCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_skin_id struct {
    skin i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_skin_s struct {
    id control_skin_id
    name str
    back layer_skin_id
    front layer_skin_id
    hover_back layer_skin_id
    hover_front layer_skin_id
    disabled_back layer_skin_id
    disabled_front layer_skin_id
    focused_back layer_skin_id
    focused_front layer_skin_id
    selected_back layer_skin_id
    selected_front layer_skin_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_control_skin() (out control_skin_id) {
    out.skin = -1
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_control_skin(id control_skin_id) (out bool) {
    out = id.skin >= 0 && id.skin < g_controlSkinCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_control_skin(name str, back layer_skin_id, front layer_skin_id, hoverBack layer_skin_id, hoverFore layer_skin_id, disabledBack layer_skin_id, disabledFore layer_skin_id, focusedBack layer_skin_id, focusedFore layer_skin_id, selectedBack layer_skin_id, selectedFore layer_skin_id)  (out control_skin_id) {
    out.skin = g_controlSkinCount

    var skin control_skin_s
    skin.name = name
    skin.id = out
    skin.back = back
    skin.front = front
    skin.hover_back = hoverBack
    skin.hover_front = hoverFore
    skin.disabled_back = disabledBack
    skin.disabled_front = disabledFore
    skin.focused_back = focusedBack
    skin.focused_front = focusedFore
    skin.selected_back = selectedBack
    skin.selected_front = selectedFore

    g_controlSkins[out.skin] = skin
    g_controlSkinCount = out.skin + 1
    uti.assert_(is_valid_control_skin(out), "create_control_skin : invalid id")
    control_skin_print("create_control_skin : ", out)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_skin_print(message str, id control_skin_id) {
    uti.assert_(is_valid_control_skin(id), "control_skin_print : invalid id")
    var index i32 = id.skin
    printf("%s CONTROL_SKIN %d - %s\n", message, g_controlSkins[index].id.skin, g_controlSkins[index].name)
    if (is_valid_layer_skin(g_controlSkins[index].back)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].back)
    }
    if (is_valid_layer_skin(g_controlSkins[index].front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].front)
    }
    if (is_valid_layer_skin(g_controlSkins[index].hover_back)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].hover_back)
    }
    if (is_valid_layer_skin(g_controlSkins[index].hover_front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].hover_front)
    }
    if (is_valid_layer_skin(g_controlSkins[index].disabled_back)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].disabled_back)
    }
    if (is_valid_layer_skin(g_controlSkins[index].disabled_front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].disabled_front)
    }
    if (is_valid_layer_skin(g_controlSkins[index].focused_back)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].focused_back)
    }
    if (is_valid_layer_skin(g_controlSkins[index].focused_front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].focused_front)
    }
    if (is_valid_layer_skin(g_controlSkins[index].selected_front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].selected_front)
    }
    if (is_valid_layer_skin(g_controlSkins[index].selected_front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].selected_front)
    }
}

//-----------------------------------------------------------------------------
// SKIN
//-----------------------------------------------------------------------------
var g_black             mat.v4 = mat.rgba_ui8( 30,  34,  39, 255)
var g_white             mat.v4 = mat.rgba_ui8(255, 251, 251, 255)
var g_primary_blue      mat.v4 = mat.rgba_ui8(  0, 114, 255, 255)
var g_light_blue        mat.v4 = mat.rgba_ui8(  0, 195, 255, 255)
var g_green             mat.v4 = mat.rgba_ui8(  0, 223, 128, 255)
var g_red               mat.v4 = mat.rgba_ui8(255,   0,  78, 255)
var g_gold              mat.v4 = mat.rgba_ui8(255, 193,  37, 255)
var g_gray_0            mat.v4 = mat.rgba_ui8( 34,  38,  43, 255)
var g_gray_1            mat.v4 = mat.rgba_ui8( 41,  45,  50, 255)
var g_gray_2            mat.v4 = mat.rgba_ui8( 74,  77,  81, 255)
var g_gray_3            mat.v4 = mat.rgba_ui8(140, 142, 145, 255)
var g_gray_4            mat.v4 = mat.rgba_ui8(206, 207, 208, 255)
var g_gray_5            mat.v4 = mat.rgba_ui8(239, 240, 240, 255)
var g_gray_6            mat.v4 = mat.rgba_ui8(247, 247, 247, 255)
var g_gray_7            mat.v4 = mat.rgba_ui8(251, 251, 251, 255)

var g_black_a50 mat.v4 = mat.v4_mul(g_black, mat.v4_(0.5, 0.5, 0.5, 0.8))
var g_primary_blue_a50  mat.v4 = alpha(g_primary_blue, 0.5)

var g_debugLayerSkin layer_skin_id
var g_bootLayerSkin layer_skin_id
var g_blackLayerSkin layer_skin_id
var g_redLayerSkin layer_skin_id
var g_greenLayerSkin layer_skin_id
var g_primaryBlueLayerSkin layer_skin_id
var g_primaryBlueAlphaLayerSkin layer_skin_id
var g_modalLayerSkin layer_skin_id
var g_windowLayerSkin layer_skin_id
var g_headerLayerSkin layer_skin_id
var g_stripLayerSkin layer_skin_id

var g_debugControlSkin control_skin_id
var g_bootControlSkin control_skin_id
var g_blackControlSkin control_skin_id
var g_redControlSkin control_skin_id
var g_greenControlSkin control_skin_id
var g_primaryBlueControlSkin control_skin_id
var g_primaryBlueAlphaControlSkin control_skin_id
var g_modalControlSkin control_skin_id
var g_windowControlSkin control_skin_id
var g_headerControlSkin control_skin_id
var g_stripControlSkin control_skin_id

var textureLogo str = "textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png"

var g_boldFont font_id = invalid_font()
var g_regularFont font_id = invalid_font()

var g_fontSizeTitle i32 = 64
var g_fontSizeHeader i32 = 45
var g_fontSizeButton i32 = 38
var g_fontSizeText i32 = 36

func alpha(color mat.v4, a f32) (out mat.v4) {
    //out = mat.v4_(color.x, color.y, color.z, (color.w * a)) // ##issue_57  out.w == 0
    out.x = color.x
    out.y = color.y
    out.z = color.z
    out.w = color.w * a
}

//-----------------------------------------------------------------------------
// CONTROL
//-----------------------------------------------------------------------------
var g_controls [256]control_s
var g_controlCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_id struct {
    control i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_s struct {
    id control_id
    name str
    gui_type i32
    gui_index i32

    skin control_skin_id

    dock i32
    align i32
    autosize i32
    autoratio i32
    autoscale i32

    position mat.v2
    size mat.v2
    ratio mat.v2
    scale mat.v2

    padding mat.v4
    renderPosition mat.v2
    //renderSize mat.v2

    children [8]control_id // can't make it work with slices
    childrenCount i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_control() (out control_id) {
    out.control = 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_id_(control i32) (out control_id) {
    out.control = control
    uti.assert_(is_valid_control(out), "control_id_ : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_control(id control_id) (out bool) {
    out = id.control >= 0 && id.control < g_controlCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_control(name str) (out control_id) {
    out = create_control_(name, GUI_CONTROL, g_controlCount)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_control_(name str, gui_type i32, gui_index i32) (out control_id) {
    out.control = g_controlCount

    var control control_s
    control.id = out
    control.name = name
    control.gui_type  = gui_type
    control.gui_index = gui_index

    control.skin = invalid_control_skin()

    control.dock      = DOCK_NONE
    control.align     = ALIGN_NONE
    control.autosize  = AUTOSIZE_NONE
    control.autoratio = AUTORATIO_NONE
    control.autoscale = AUTOSCALE_NONE

    control.position = mat.v2_zero
    control.size     = mat.v2_zero
    control.ratio    = mat.v2_one
    control.scale    = mat.v2_one

    control.renderPosition = mat.v2_zero
    //control.renderSize     = mat.v2_zero

    control.childrenCount = 0
    g_controls[out.control] = control
    g_controlCount = out.control + 1
    uti.assert_(is_valid_control(out), "create_control : invalid control")
    control_print("create_control : ", out, true)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_print(message str, id control_id, printSkin bool) {
    uti.assert_(is_valid_control(id), "control_print : invalid control")
    var index i32 = id.control
    printf("%s CONTROL %d - %s, GUI_TYPE %d, GUI_INDEX %d, SKIN %d, DOCK %d, ALIGN %d, AUTOSIZE %d, AUTORATIO %d, AUTOSCALE %d POSITION %f, %f, SIZE %f, %f, RATIO %f, %f, SCALE %f, %f, RENDER_POSITION %f, %f, CHILDREN %d\n",
        message,
        g_controls[index].id.control,
        g_controls[index].name,
        g_controls[index].gui_type,
        g_controls[index].gui_index,
        g_controls[index].skin,
        g_controls[index].dock,
        g_controls[index].align,
        g_controls[index].autosize,
        g_controls[index].autoratio,
        g_controls[index].autoscale,
        g_controls[index].position.x,
        g_controls[index].position.y,
        g_controls[index].size.x,
        g_controls[index].size.y,
        g_controls[index].ratio.x,
        g_controls[index].ratio.y,
        g_controls[index].scale.x,
        g_controls[index].scale.y,
        g_controls[index].renderPosition.x,
        g_controls[index].renderPosition.y,
        g_controls[index].childrenCount)

    if (printSkin == true && is_valid_control_skin(g_controls[index].skin)) {
        control_skin_print("control_print : ", g_controls[index].skin)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_skin(id control_id, skin control_skin_id) {
    uti.assert_(is_valid_control(id)   , "control_set_skin : invalid id")
    uti.assert_(is_valid_control_skin(skin), "control_set_skin : invalid skin")
    g_controls[id.control].skin = skin
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_dock(id control_id, dock i32) {
    uti.assert_(is_valid_control(id), "control_set_dock : invalid id")
    g_controls[id.control].dock = dock
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_align(id control_id, align i32) {
    uti.assert_(is_valid_control(id), "control_set_align : invalid id")
    g_controls[id.control].align = align
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_autosize(id control_id, autosize i32) {
    uti.assert_(is_valid_control(id), "control_set_autosize : invalid id")
    g_controls[id.control].autosize = autosize
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_autoratio(id control_id, autoratio i32) {
    uti.assert_(is_valid_control(id), "control_set_autoratio : invalid id")
    g_controls[id.control].autoratio = autoratio
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_autoscale(id control_id, autoscale i32) {
    uti.assert_(is_valid_control(id), "control_set_autoscale : invalid id")
    g_controls[id.control].autoscale = autoscale
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_position(id control_id, position v2) {
    uti.assert_(is_valid_control(id), "control_set_position : invalid id")
    g_controls[id.control].position = position
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_size(id control_id, size v2) {
    uti.assert_(is_valid_control(id), "control_set_size : invalid id")
    g_controls[id.control].size = size
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_bounds(id control_id, bounds v4) {
    uti.assert_(is_valid_control(id), "control_set_bounds : invalid id")
    g_controls[id.control].position = mat.v4_xy(bounds)
    g_controls[id.control].size = mat.v4_zw(bounds)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_ratio(id control_id, ratio v2) {
    uti.assert_(is_valid_control(id), "control_set_ratio : invalid id")
    g_controls[id.control].ratio = ratio
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_scale(id control_id, scale v2) {
    uti.assert_(is_valid_control(id), "control_set_scale : invalid id")
    g_controls[id.control].scale = scale
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_add_child(parent control_id, child control_id) {
    uti.assert_(is_valid_control(parent), "control_add_child : invalid parent")
    uti.assert_(is_valid_control(child), "control_add_child : invalid child")
    var count i32 = g_controls[parent.control].childrenCount
    g_controls[parent.control].children[count] = child
    g_controls[parent.control].childrenCount = count + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_clear_child(id control_id) {
    uti.assert_(is_valid_control(id), "control_clear_child : invalid id")
    g_controls[id.control].childrenCount = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_padding(id control_id, padding mat.v4) {
    uti.assert_(is_valid_control(id), "control_set_padding : invalid id")
    g_controls[id.control].padding = mat.v4_mul(padding, mat.v4_(1.0, gfx.gfx_ratio_y, 1.0, gfx.gfx_ratio_y)) // ##1 id viewport resize
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func align_control(align i32, posx f32, posy f32, width f32, height f32, contX f32, contY f32, contW f32, contH f32, padding mat.v4) (x f32, y f32) {
    x = posx
    y = posy

    if (align == ALIGN_CENTER) {
        x = contX + (contW - width) / 2.0
        y = contY + (contH - height) / 2.0
        //printf("posx %f, posy %f, width %f, height %f, X %f, Y %f\n", posx, posy, width, height, x, y)
    } else if (align == ALIGN_HORZ_BOTTOM) {
        x = contX + (contW - width) / 2.0
        y = contY + padding.y
        //control_print(index, "ALIGN_HORZ_BOTTOM : ")
    } else if (align == ALIGN_HORZ_TOP) {
        uti.assert_(false, "ALIGN_HORZ_TOP not implemented")
    } else if (align == ALIGN_VERT_LEFT) {
        uti.assert_(false, "ALIGN_VERT_LEFT not implemented")
    } else if (align == ALIGN_VERT_RIGHT) {
        uti.assert_(false, "ALIGN_VERT_RIGHT not implemented")
    } else if (align == ALIGN_LEFT_BOTTOM) {
        uti.assert_(false, "ALIGN_LEFT_BOTTOM not implemented")
    } else if (align == ALIGN_RIGHT_BOTTOM) {
        uti.assert_(false, "ALIGN_RIGHT_BOTTOM not implemented")
    } else if (align == ALIGN_HORZ) {
        uti.assert_(false, "ALIGN_HORZ not implemented")
    } else if (align == ALIGN_VERT) {
        uti.assert_(false, "ALIGN_VERT not implemented")
    } else if (align == ALIGN_LEFT_TOP) {
        uti.assert_(false, "ALIGN_LEFT_TOP not implemented")
    } else if (align == ALIGN_RIGHT_TOP) {
        uti.assert_(false, "ALIGN_RIGHT_TOP not implemented")
    } else if (align == ALIGN_LEFT) {
         uti.assert_(false, "ALIGN_LEFT not implemented")
    } else if (align == ALIGN_RIGHT) {
        uti.assert_(false, "ALIGN_RIGHT not implemented")
    } else if (align == ALIGN_BOTTOM) {
        uti.assert_(false, "ALIGN_BOTTOM not implemented")
    } else if (align == ALIGN_TOP) {
        uti.assert_(false, "ALIGN_TOP not implemented")
    } else if (align != ALIGN_NONE) {
        //x = bounds.x
        //y = bounds.y
        //w = bounds.z
        //h = bounds.w
    //} else {
        uti.assert_(false, "invalid align property")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func redock_control(id control_id) () {
    uti.assert_(is_valid_control(id), "redock_control : invalid id")
    //control_print("redock_control : ", id)

    var index i32 = id.control
    var w f32 = 0.0
    var h f32 = 0.0
    var x f32 = 0.0
    var y f32 = 0.0

    var dock i32 = g_controls[index].dock
    var align i32 = g_controls[index].align
    var autosize i32 = g_controls[index].autosize
    var size mat.v2 = g_controls[index].size
    var position mat.v2 = g_controls[index].position
    var padding mat.v4 = g_controls[index].padding

    var paddingLeft f32 = padding.x
    var paddingBottom f32 = padding.y
    var paddingRight f32 = padding.z
    var paddingTop f32 = padding.w

    var paddingX f32 = paddingLeft + paddingRight
    var paddingY f32 = paddingBottom + paddingTop

    /*if (dock != DOCK_NONE) {
        uti.assert_(align == ALIGN_NONE, "redock_control : incompatible align & dock options")
    }*/

    if (dock == DOCK_FILL) {
        x = g_dock.left + paddingLeft
        w = g_dock.right - g_dock.left - paddingX
        h = g_dock.top - g_dock.bottom - paddingY
        y = g_dock.bottom + paddingBottom
        //control_print("DOCK_FILL : ", id, false)
        //printf("padding %f, %f\n", padding.x, padding.y)
    } else if (dock == DOCK_LEFT) {
        x = g_dock.left + paddingLeft
        w = size.x
        h = g_dock.top - g_dock.bottom - paddingY
        y = g_dock.top - h - paddingTop
        g_dock.left = x + w
        //control_print(index, "DOCK_LEFT : ")
    } else if (dock == DOCK_RIGHT) {
        w = size.x
        x = g_dock.right - w - paddingLeft
        h = g_dock.top - g_dock.bottom - paddingY
        y = g_dock.top - h - paddingTop
        g_dock.right = x
        //uti.assert_(false, "not implemented : DOCK_RIGHT")
    } else if (dock == DOCK_TOP) {
        x = g_dock.left + paddingLeft
        w = g_dock.right - g_dock.left - paddingX
        h = size.y
        y = g_dock.top - h - paddingTop
        g_dock.top = y
        //uti.assert_(false, "not implemented : DOCK_TOP")
    } else if (dock == DOCK_BOTTOM) {
        x = g_dock.left + paddingLeft
        w = g_dock.right - g_dock.left - paddingX
        h = size.y
        y = g_dock.bottom + paddingBottom// + h
        g_dock.bottom = y + h
        //control_print("DOCK_BOTTOM : ", id, false)
        //uti.assert_(false, "not implemented : DOCK_BOTTOM")
    } else if (dock == DOCK_NONE) {
        x = position.x
        y = position.y
        w = size.x
        h = size.y
    } else {
        uti.assert_(false, "invalid dock value")
    }

    var contX f32 = g_dock.left
    var contY f32 = g_dock.bottom
    var contW f32 = g_offset.width
    var contH f32 = g_offset.height

    //control_print("befor align : ", id, false)
    x, y = align_control(align, x, y, size.x, size.y, contX, contY, contW, contH, padding)
    //control_print("after align : ", id, false)
    push_scope()

    g_offset.x = g_offset.x + x
    g_offset.y = g_offset.y + y
    g_offset.width = w
    g_offset.height = h

    g_dock.left = 0.0
    g_dock.bottom = 0.0
    g_dock.right = w
    g_dock.top = h

    //control_print(index, "child")
    var count i32 = g_controls[index].childrenCount
    for i := 0; i < count; i = i + 1 {
        var child control_id = g_controls[index].children[i]
        uti.assert_(is_valid_control(child), "redock_control : invalid child control")

        ///printf("REDOCK_CHILD %d/%d\n", i + 1, count)
        var childControl i32 = child.control
        var guiType i32 = g_controls[childControl].gui_type
        var guiIndex i32 = g_controls[childControl].gui_index

        if (guiType == GUI_INVALID) {
            uti.assert_(false, "invalid gui type (GUI_INVALID)")
        } else if (guiType == GUI_CONTROL) {
            uti.assert_(guiIndex == childControl, "unexpected error")
            redock_control(control_id_(childControl))
        } else if (guiType == GUI_SCREEN) {
            uti.assert_(false, "unidd recursive screen")
        } else if (guiType == GUI_PICTURE) {
            //redock_picture(picture_id_(child, guiIndex))
            redock_control(control_id_(childControl))
        } else if (guiType == GUI_LABEL) {
            //redock_label(label_id_(child, guiIndex))
            redock_control(control_id_(childControl))
        } else if (guiType == GUI_PARTITION) {
            //redock_partition(partition_id_(child, guiIndex))
            redock_control(control_id_(childControl))
        } else if (guiType == GUI_KEYBOARD) {
            //redock_keyboard(keyboard_id_(child, guiIndex))
            redock_control(control_id_(childControl))
        } else if (guiType == GUI_WINDOW) {
            //redock_window(window_id_(child, guiIndex))
            redock_control(control_id_(childControl))
        } else {
            uti.assert_(false, "unknown gui type")
        }
    }

    g_controls[index].renderPosition = mat.v2_(g_offset.x, g_offset.y)
    //g_controls[index].renderSize = mat.v2_(g_offset.width, g_offset.height)
    var newWidth f32 = g_offset.width
    var newHeight f32 = g_offset.height

    if ((autosize & AUTOSIZE_X) == AUTOSIZE_X) {
        newWidth = g_controls[index].size.x - paddingX
    }
    if ((autosize & AUTOSIZE_Y) == AUTOSIZE_Y) {
        newHeight = g_controls[index].size.y - paddingY
    }
    g_controls[index].size = mat.v2_(newWidth, newHeight)

    control_print("after_pop", id, false)
    pop_scope()
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize_control(id control_id) () {
    uti.assert_(is_valid_control(id), "resize_control : invalid id")
    var bounds mat.v2 = g_controls[id.control].size
    var pixelBounds mat.v2 = mat.v2_mul(bounds, gfx.gfx_viewport)
    resize_control_(id, pixelBounds, bounds, mat.v2_zero)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize_control_(id control_id, pixelBounds mat.v2, bounds mat.v2, autoBounds mat.v2) () {
    uti.assert_(is_valid_control(id), "resize_control : invalid id")
       //control_print("resize_control : ", id, false)
       //printf("pixelBounds %f, %f, bounds %f, %f, autoBounds %f, %f\n", pixelBounds.x, pixelBounds.y, bounds.x, bounds.y, autoBounds.x, autoBounds.y)

    var index i32 = id.control

    var autoscale i32 = g_controls[index].autoscale
    var scale mat.v2 = g_controls[index].scale
    var autosize i32 = g_controls[index].autosize

    var padding mat.v4 = g_controls[index].padding
    var newWidth f32 = g_controls[index].size.x
    var newHeight f32 = g_controls[index].size.y

    var paddingLeft f32 = padding.x
    var paddingBottom f32 = padding.y
    var paddingRight f32 = padding.z
    var paddingTop f32 = padding.w
    var paddingX f32 = paddingLeft + paddingRight
    var paddingY f32 = paddingBottom + paddingTop
    var maxWidth f32 = 0.0
    var maxHeight f32 = 0.0

    if (autosize == AUTOSIZE) {
        control_print("AUTOSIZE : ", id, false)
    }

    var count i32 = g_controls[index].childrenCount
    for i := 0; i < count; i = i + 1 {
        var child control_id = g_controls[index].children[i]
        uti.assert_(is_valid_control(child), "resize_control : invalid child control")
        var guiType i32 = g_controls[child.control].gui_type
        var guiIndex i32 = g_controls[child.control].gui_index

        if (guiType == GUI_INVALID) {
           uti.assert_(false, "invalid gui type (GUI_INVALID)")
        } else if (guiType == GUI_CONTROL) {
            uti.assert_(guiIndex == child.control, "unexpected error")
            resize_control(control_id_(guiIndex))
        } else if (guiType == GUI_SCREEN) {
            uti.assert_(false, "unidd recursive screen")
        } else if (guiType == GUI_PICTURE) {
            resize_picture(picture_id_(child, guiIndex))
        } else if (guiType == GUI_LABEL) {
            resize_label(label_id_(child, guiIndex))
        } else if (guiType == GUI_PARTITION) {
            resize_partition(partition_id_(child, guiIndex))
        } else if (guiType == GUI_KEYBOARD) {
            resize_keyboard(keyboard_id_(child, guiIndex))
        } else if (guiType == GUI_WINDOW) {
            resize_window(window_id_(child, guiIndex))
        } else {
            uti.assert_(false, "unknown gui type")
        }

        var position mat.v2 = g_controls[child.control].renderPosition
        var size mat.v2 = g_controls[child.control].size

        maxWidth = maxWidth + size.x
        maxHeight = maxHeight + size.y
        printf("%s, %d/%d : MAXWIDTH %f, MAXHEIGHT %f\n", g_controls[id.control].name, i + 1, count, maxWidth, maxHeight)
    }

    if (autosize == AUTOSIZE || autosize == AUTOSIZE_X || autosize == AUTOSIZE_Y) {
        if ((autosize & AUTOSIZE_X) == AUTOSIZE_X) {
            uti.assert_((autoscale & AUTOSCALE_X) == 0, "AUTOSIZE_X is not compatible with AUTOSCALE_X")
            printf("NEW_WIDTH %f, AUTO_BOUNDS_X %f\n", maxWidth, autoBounds.x)
            newWidth = mat.max(maxWidth, autoBounds.x) - paddingX
        }
        if ((autosize & AUTOSIZE_Y) == AUTOSIZE_Y) {
            uti.assert_((autoscale & AUTOSCALE_Y) == 0, "AUTOSIZE_Y is not compatible with AUTOSCALE_Y")
            newHeight = mat.max(maxHeight, autoBounds.y) - paddingY
            printf("NEW_HEIGHT %f, AUTO_BOUNDS_Y %f\n", maxHeight, autoBounds.y)
        }

        g_controls[index].size = mat.v2_(newWidth, newHeight)
        control_print("NEW_SIZE : ", id, false)
    } else {
        uti.assert_(autosize == AUTOSIZE_NONE, "invalid AUTOSIZE value")
    }

    if (autoscale == AUTOSCALE || autoscale == AUTOSCALE_X || autoscale == AUTOSCALE_Y) {
        if (autoBounds.x > 0 && autoBounds.y > 0) {
            //control_print("AUTOSCALE : ", id, false)
            //printf("scale %f, %f, newWidth %f, newHeight %f, autoBounds %f, %f\n", scale.x, scale.y, newWidth, newHeight, autoBounds.x, autoBounds.y)
            var scaleW f32 = scale.x
            var scaleH f32 = scale.y
            if ((autoscale & AUTOSCALE_X) == AUTOSCALE_X) {
                uti.assert_((autosize & AUTOSIZE_X) == 0, "AUTOSCALE_X is not compatible with AUTOSIZE_X")
                scaleW = newWidth / autoBounds.x
            }
            if ((autoscale & AUTOSCALE_Y) == AUTOSCALE_Y) {
                uti.assert_((autosize & AUTOSIZE_Y) == 0, "AUTOSCALE_Y is not compatible with AUTOSCALE_Y")
                scaleH = newHeight / autoBounds.y
            }

            if (autoscale == AUTOSCALE) {
                if (scaleW < scaleH) {
                    scaleH = scaleW
                    var newScale mat.v2 = mat.v2_(scaleW, scaleH/* / gfx.gfx_ratio_y*/)
                    g_controls[index].scale = newScale
                    //control_print("after_pop", id, false)

                } else {
                    scaleW = scaleH
                    var newScale mat.v2 = mat.v2_(scaleW/* * gfx.gfx_ratio_x*/, scaleH)
                    g_controls[index].scale = newScale
                }
            } else {
                var newScale mat.v2 = mat.v2_(scaleW, scaleH)
                g_controls[index].scale = newScale
            }
        }
    } else {
        uti.assert_(autoscale == AUTOSCALE_NONE, "invalid AUTOSCALE value")
    }

    //control_print("after_pop", index)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_surface(id mesh_id, bounds mat.v4, color mat.v4) () {
    if (color.w > 0) {
        gfx.append_quad(id, bounds, mat.v4_(0.0, 0.0, 1.0, 1.0), color)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_border(id mesh_id, bounds mat.v4, left mat.v4, bottom mat.v4, right mat.v4, top mat.v4) () {
    var x0 f32 = bounds.x
    var y0 f32 = bounds.y
    var x1 f32 = x0 + bounds.z
    var y1 f32 = y0 + bounds.w

    if (left.w > 0) {
        gfx.append_line(id, mat.v4_(x0, y0, x0, y1), left)
    }

    if (bottom.w > 0) {
        gfx.append_line(id, mat.v4_(x0, y0, x1, y0), bottom)
    }

    if (right.w > 0) {
        gfx.append_line(id, mat.v4_(x1, y0, x1, y1), right)
    }

    if (top.w > 0) {
        gfx.append_line(id, mat.v4_(x0, y1, x1, y1), top)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_control(id control_id) () {
    //control_print("render_control : ", id)
    uti.assert_(is_valid_control(id), "render_control : invalid control index")

    var index i32 = id.control
    //var renderBounds mat.v4 = mat.v4_v2v2(g_controls[index].renderPosition, g_controls[index].renderSize)
    var renderBounds mat.v4 = mat.v4_v2v2(g_controls[index].renderPosition, g_controls[index].size)
    var controlSkin control_skin_id = g_controls[index].skin
    uti.assert_(is_valid_control_skin(controlSkin) || controlSkin.skin == -1, "render_control : invalid control skin")
    if is_valid_control_skin(controlSkin) {
        var backLayerSkin layer_skin_id = g_controlSkins[controlSkin.skin].back
        uti.assert_(is_valid_layer_skin(backLayerSkin) || backLayerSkin.layer == -1, "render_control : invalid layer skin")
        if is_valid_layer_skin(backLayerSkin) {
            render_surface(g_opaqueVertexColoredTriangles, renderBounds, g_layerSkins[backLayerSkin.layer].surface)
            render_border(g_opaqueVertexColoredLines, renderBounds,
                g_layerSkins[backLayerSkin.layer].left,
                g_layerSkins[backLayerSkin.layer].right,
                g_layerSkins[backLayerSkin.layer].bottom,
                g_layerSkins[backLayerSkin.layer].top)
        }
        var frontLayerSkin layer_skin_id = g_controlSkins[controlSkin.skin].front
        uti.assert_(is_valid_layer_skin(frontLayerSkin) || frontLayerSkin.layer == -1, "render_control : invalid layer skin")
        if (is_valid_layer_skin(frontLayerSkin)) {
            render_surface(g_alphaVertexColoredTriangles,renderBounds, g_layerSkins[frontLayerSkin.layer].surface)
            //gfx.append_rect(g_alphaVertexColoredLines, g_controls[index].renderBounds,
              //  g_layerSkins[backLayerSkin].left,
               // g_layerSkins[backLayerSkin].right,
                //g_layerSkins[backLayerSkin].bottom,
                ///g_layerSkins[backLayerSkin].top)
        }
    }

    var count i32 = g_controls[index].childrenCount
    for i := 0; i < count; i = i + 1 {
        var child control_id = g_controls[index].children[i]
        uti.assert_(is_valid_control(child), "render_control : invalid child control")
        var guiType i32 = g_controls[child].gui_type
        var guiIndex i32 = g_controls[child].gui_index

        if (guiType == GUI_INVALID) {
            uti.assert_(false, "invalid gui type (GUI_INVALID)")
        } else if (guiType == GUI_CONTROL) {
            //control_print(guiIndex, "render_control_child GUI_CONTROL : ")
            uti.assert_(child.control == guiIndex, "unexpected error")
            render_control(child)
        } else if (guiType == GUI_SCREEN) {
            uti.assert_(false, "unidd recursive screen")
        } else if (guiType == GUI_PICTURE) {
            render_picture(picture_id_(child, guiIndex))
        } else if (guiType == GUI_LABEL) {
            render_label(label_id_(child, guiIndex))
        } else if (guiType == GUI_PARTITION) {
            render_partition(partition_id_(child, guiIndex))
        } else if (guiType == GUI_KEYBOARD) {
            render_keyboard(keyboard_id_(child, guiIndex))
        } else if (guiType == GUI_WINDOW) {
            render_window(window_id_(child, guiIndex))
        } else {
            uti.assert_(false, "unknown gui type")
        }
    }
}

//-----------------------------------------------------------------------------
// SCREEN
//-----------------------------------------------------------------------------
var g_screens [64]screen_s
var g_screenCount i32

var g_modals [64]screen_id
var g_modalCount i32 = 0

var g_currentScreen screen_id = invalid_screen()
var g_nextScreen    screen_id = invalid_screen()

var g_transitionDuration f64 = 0.5D
var g_transitionTime     f64 = 0.0D

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type screen_id struct {
    base control_id
    screen i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type screen_s struct {
    id    screen_id
    on_exit   screen_id
    on_enter  screen_id
    on_menu   screen_id
    on_next   screen_id
    duration  f64
    time      f64
    state     i32
    prevState i32
    modal     bool
    paused    bool
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_screen(name str) (out screen_id) {
    out.screen = g_screenCount
    out.base = create_control_(name, GUI_SCREEN, out.screen)

    var screen screen_s
    screen.id = out
    screen.on_exit   = invalid_screen()
    screen.on_enter  = invalid_screen()
    screen.on_menu   = invalid_screen()
    screen.on_next   = invalid_screen()
    screen.duration  = -1.0D
    screen.time      = 0.0D
    screen.state     = STATE_CLOSED
    screen.prevState = STATE_CLOSED
    screen.modal     = false
    screen.paused    = false

    g_screens[out.screen] = screen
    g_screenCount = out.screen + 1
    uti.assert_(is_valid_screen(out), "create_screen : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//func invalid_screen() { // ##pending issue
func invalid_screen() (out screen_id) {
    out.base = invalid_control()
    out.screen = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_screen(id screen_id) (out bool) {
    out = id.screen >= 0 && id.screen < g_screenCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func sceen_set_modal(id screen_id, modal bool) () {
    uti.assert_(is_valid_screen(id), "screen_set_modal : invalid id")
    g_screens[id.screen].modal = true
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_exit(id screen_id, exit screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_exit : invalid id")
    uti.assert_(is_valid_screen(exit)  , "screen_on_exit : invalid id")
    g_screens[id.screen].on_exit = exit
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_menu(id screen_id, menu screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_menu : invalid id")
    uti.assert_(is_valid_screen(menu)  , "screen_on_menu : invalid id")
    g_screens[id.screen].on_menu = menu
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_enter(id screen_id, enter screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_enter : invalid id")
    uti.assert_(is_valid_screen(enter) , "screen_on_enter : invalid id")
    g_screens[id.screen].on_enter = enter
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_next(id screen_id, next screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_next : invalid id 0")
    uti.assert_(is_valid_screen(next)  , "screen_on_next : invalid id 1")
    g_screens[id.screen].on_next = next
}

//-----------------------------------------------------------------------------
func screen_set_on_event(id screen_id, event screen_id) () {
    screen_set_on_exit(id, event)
    screen_set_on_enter(id, event)
    screen_set_on_menu(id, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_duration(id screen_id, duration f64) {
    uti.assert_(is_valid_screen(id), "screen_set_duration : invalid id")
    g_screens[id.screen].duration = duration
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_modal(id screen_id, modal bool) {
    uti.assert_(is_valid_screen(id), "screen_set_modal : invalid id")
    g_screens[id.screen].modal = modal
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func change_screen_state(id screen_id, state i32) () {
    uti.assert_(is_valid_screen(id), "change_screen_state : invalid id")
    g_screens[id.screen].prevState = g_screens[id.screen].state
    printf("CHANGE %d\n", state)
    g_screens[id.screen].state = state
    var prev i32 = g_screens[id.screen].prevState
    var curr i32 = g_screens[id.screen].state
    if (prev != curr) {
        printf("%d screen state changed %d -> %d\n", id.screen, prev, curr)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_state_changed(id screen_id, prev i32, curr i32) (value bool) {
    uti.assert_(is_valid_screen(id), "screen_state_chaned : invalid id")
    var screenPrev i32 = g_screens[id.screen].prevState
    var screenCurr i32 = g_screens[id.screen].state
    value = ((screenPrev == prev) && (screenCurr == curr))
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func update_screen(id screen_id, deltaTime f64) () {
    uti.assert_(is_valid_screen(id), "update_screen : invalid id")
    var t f64 = g_screens[id.screen].time
    var d f64 = g_screens[id.screen].duration

    g_screens[id.screen].time = t
    var state i32 = g_screens[id.screen].state
    if ((t <= 0) && (state == STATE_CLOSED)) {
        printf("CHANGE SHOWING\n")
        change_screen_state(id, STATE_SHOWING)
    } else if ((t >= d) && (d > 0) && (state == STATE_OPENED)) { // can't use g_screens[screen].state here
        printf("CHANGE CLOSING %d\n", g_screens[id.screen].state)
        change_screen_state(id, STATE_CLOSING)
    }

    t = t + deltaTime
    g_screens[id.screen].time = t
//    printf("time %f", f64.f32(t))
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize_screen(id screen_id) () {
    uti.assert_(is_valid_screen(id), "resize_screen : invalid id")
    resize_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func clear_batches() {
    g_renderBatchCount = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func begin_batches() {
    var i i32 = 0;
    //printf("BEGIN_BATCHES %d\n", g_renderBatchCount)
    for i = 0; i < g_renderBatchCount; i = i + 1 {
        //printf("BEGIN_BATCH %d/%d\n", i, g_renderBatchCount)
        var batchId batch_id = g_renderBatches[i]
        uti.assert_(is_valid_batch(batchId), "begin_batch : invaid batch")
        var meshId gfx.mesh_id = g_batches[batchId.batch].mesh
        uti.assert_(gfx.is_valid_mesh(meshId), "begin_batches : invalid mesh")
        gfx.begin_mesh(meshId)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func end_batches() {
    var i i32 = 0;
    for i = 0; i < g_renderBatchCount; i = i + 1 {
        var batchId batch_id = g_renderBatches[i]
        uti.assert_(is_valid_batch(batchId), "end_batch : invalid batch")
        var meshId gfx.mesh_id = g_batches[batchId.batch].mesh
        uti.assert_(gfx.is_valid_mesh(meshId), "end_batches : invalid mesh")
        gfx.end_mesh(meshId)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_batches(alpha bool) {
    var i i32 = 0
    for i = 0; i < g_renderBatchCount; i = i + 1 {
        var batchId batch_id = g_renderBatches[i]
        uti.assert_(is_valid_batch(batchId), "render_batches : invalid batch")
        var batch i32 = batchId.batch
        var meshId gfx.mesh_id = g_batches[batch].mesh
        uti.assert_(gfx.is_valid_mesh(meshId), "render_batches : invalid mesh")
        if (gfx.mesh_is_empty(meshId) == false) {
            var batchAlpha bool = g_batches[batch].alpha
            if (batchAlpha == alpha) {
               if (alpha == true) {
                    gfx.enable_blending(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
                } else {
                   gfx.disable_blending()
                }
                gfx.effect_use(gfx.g_fxTexture)
                gfx.effect_assign_texture(gfx.g_fxTexture, 0, g_batches[batch].texture.name)
                gfx.render_mesh(meshId)
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_screen(id screen_id) () {
    uti.assert_(is_valid_screen(id), "render_screen : invalid screen")
    gfx.begin_mesh(g_opaqueVertexColoredTriangles)
    gfx.begin_mesh(g_opaqueVertexColoredLines)
    gfx.begin_mesh(g_alphaVertexColoredTriangles)
    begin_batches()

    render_control(id.base)

    end_batches()
    gfx.end_mesh(g_alphaVertexColoredTriangles)
    gfx.end_mesh(g_opaqueVertexColoredLines)
    gfx.end_mesh(g_opaqueVertexColoredTriangles)

    // opaque
    if gfx.mesh_is_empty(g_opaqueVertexColoredTriangles) == false {
        gfx.disable_blending()
        gfx.effect_use(gfx.g_fxVertexColor)
        gfx.render_mesh(g_opaqueVertexColoredTriangles)
    }

    render_batches(false)

    if gfx.mesh_is_empty(g_opaqueVertexColoredLines) == false {
        gfx.disable_blending()
        gfx.effect_use(gfx.g_fxVertexColor)
        gfx.render_mesh(g_opaqueVertexColoredLines)
    }

    // alpha
    if gfx.mesh_is_empty(g_alphaVertexColoredTriangles) == false {
        gfx.enable_blending(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
        gfx.effect_use(gfx.g_fxVertexColor)
        gfx.render_mesh(g_alphaVertexColoredTriangles)
    }

    render_batches(true)
}

//-----------------------------------------------------------------------------
// LABEL
//-----------------------------------------------------------------------------
var g_labels [64]label_s
var g_labelCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type label_id struct {
    base control_id
    label i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type label_s struct {
    id label_id
    font font_id
    batch batch_id
    text str
    textSize i32
    textAlign i32
    textPosition mat.v2
    color_0 mat.v4
    color_1 mat.v4
    //mesh mesh_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_id_(base control_id, label i32) (out label_id) {
    out.base = base
    out.label = label
    uti.assert_(is_valid_label(out), "label_id_ : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_label(id label_id) (out bool) {
    out = id.label >= 0 && id.label < g_labelCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_label(name str) (out label_id) {
    out.label = g_labelCount
    out.base = create_control_(name, GUI_LABEL, out.label)

    var label label_s
    label.id = out
    label.font = invalid_font()
    label.batch = invalid_batch()
    label.text = ""
    label.textSize = 16
    label.textAlign = ALIGN_NONE
    label.textPosition = mat.v2_zero
    label.color_0 = g_red
    label.color_1 = g_green
    g_labels[out.label] = label
    g_labelCount = out.label + 1
    uti.assert_(is_valid_label(out), "create_label : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_font(id label_id, font font_id) {
    uti.assert_(is_valid_label(id), "label_set_font : invalid id")
    uti.assert_(is_valid_font(font), "label_set_font : invalid font")
    g_labels[id.label].font = font
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_text(id label_id, text str) {
    uti.assert_(is_valid_label(id), "label_set_text : invalid id")
    g_labels[id.label].text = text
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_align(id label_id, align i32) {
    uti.assert_(is_valid_label(id), "label_set_align : invalid id")
    g_labels[id.label].textAlign = align
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_size(id label_id, size i32) {
    uti.assert_(is_valid_label(id), "label_set_size : invalid id")
    g_labels[id.label].textSize = size
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_color(id label_id, color mat.v4) {
    uti.assert_(is_valid_label(id), "label_set_color : invalid id")
    g_labels[id.label].color_0 = color
    g_labels[id.label].color_1 = color
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type batch_id struct {
    batch i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type batch_s struct {
    texture texture_s
    mesh mesh_id
    alpha bool
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_batches[64] batch_s
var g_batchCount i32 = 0

var g_renderBatches[64] batch_id
var g_renderBatchCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_batch() (out batch_id) {
    out.batch = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_batch(id batch_id) (out bool) {
    out = id.batch >= 0 && id.batch < g_batchCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func get_batch(texture texture_s, alpha bool) (out batch_id) {

    out.batch = -1
    var i i32 = 0
    for i >= 0 {
        if (i < g_batchCount) {
            var textureName i32 = g_batches[i].texture.name
            var textureAlpha bool = g_batches[i].alpha
            if (textureName == texture.name && textureAlpha == alpha) {
                out.batch = i
            }
            i = i + 1
        } else {
            i = -1
        }
    }
    if (out.batch < 0) {
        g_batches[g_batchCount].texture = texture
        var attributes [3]i32 // ##0 harcode
        attributes = [3]i32{3, 4, 2} // ##0 can't use slice yet
        g_batches[g_batchCount].mesh = gfx.lock_mesh(gl.TRIANGLES, attributes, 2048 * 3) // ##0 hardcode
        g_batches[g_batchCount].alpha = alpha
        out.batch = g_batchCount
        g_batchCount = g_batchCount + 1
    }

    i = 0
    var found bool = false
    for i >= 0 {
        if (i < g_renderBatchCount) {
            if (g_renderBatches[i].batch == out.batch) {
               found = true
               i = -1
            } else {
                i = i + 1
            }
        } else {
            i = -1
        }
    }

    if (found == false) {
        //printf("BATCH_NOT FOUND %d\n", out.batch)
        g_renderBatches[g_renderBatchCount] = out
        g_renderBatchCount = g_renderBatchCount + 1
    }

    uti.assert_(is_valid_batch(out), "get_batch : invalid index")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize_label(id label_id) () {
    uti.assert_(is_valid_label(id), "resize_label : invalid id")

    var i32Width i32
    var i32Hheight i32
    var text str = g_labels[id.label].text

    var fontId font_id = g_labels[id.label].font
    var fontIndex i32 = fontId.font
    uti.assert_(is_valid_font(fontId), "resize_label : invalid font")

    var fontSize i32 = g_labels[id.label].textSize
    var textureIndex i32 = font_get_texture_index(fontId, fontSize)

    var fontName str = g_fonts[fontIndex].names[textureIndex] // ##0 auto select best size
    i32Width, i32Height := gfx.measure_text(fontName, text)

    var pixelBounds mat.v2 = mat.v2_(i32.f32(i32Width), i32.f32(i32Height))
    var bounds mat.v2 = mat.v2_div(pixelBounds, gfx.gfx_viewport)
    resize_control_(id.base, pixelBounds, bounds, bounds)

    var position mat.v2 = g_controls[id.base].renderPosition
    //var size mat.v2 = g_controls[id.base].renderSize
    var size mat.v2 = g_controls[id.base].size
    var scale mat.v2 = g_controls[id.base].scale
    var padding mat.v4 = g_controls[id.base].padding
    //printf("LABEL_SCALE %f, %f, width %f, height %f, scale.x * width %f, scale.y * height %f\n", scale.x, scale.y, width, height, scale.x * width, scale.y * height)

    var newSize mat.v2 = mat.v2_mul(scale, bounds)

    position.x, position.y = align_control(g_labels[id.label].textAlign, 0.0, 0.0, newSize.x, newSize.y, position.x, position.y, size.x, size.y, padding)
    g_labels[id.label].textPosition = position
    g_labels[id.label].batch = get_batch(g_fonts[fontIndex].textures[textureIndex], true)
    //control_print("resize_label :", id.base, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_label(id label_id) () {
    uti.assert_(is_valid_label(id), "render_label : invalid id")
    //control_print("RENDER_LABEL : ", id.base, false)
    render_control(id.base)

    var fontId font_id = g_labels[id.label].font
    uti.assert_(is_valid_font(fontId), "render_label : invalid font")

    var fontSize i32 = g_labels[id.label].textSize
    var textureIndex i32 = font_get_texture_index(fontId, fontSize)

    var fontTexture texture_s = g_fonts[fontId.font].textures[textureIndex] // ##0 auto select best size
    var fontName str = g_fonts[fontId.font].names[textureIndex]

    //printf("render_label : using font %s - %d, %d, %d\n", fontName, fontTexture.name, fontTexture.width, fontTexture.height)

    var control i32 = id.base.control
    var renderPosition mat.v2 = g_labels[id.label].textPosition
    var batch batch_id = g_labels[id.label].batch
    uti.assert_(is_valid_batch(batch), "render_label : invalid batch")
    //gfx.append_text(&(gfx.g_meshes[g_batches[batch.batch].mesh.mesh]), fontTexture, fontName, // ##pending
    var meshId gfx.mesh_id = g_batches[batch.batch].mesh
    gfx.append_text(meshId, fontTexture, fontName,
        renderPosition, g_controls[control].scale,
        mat.v4_(1.0, 1.0, 1.0, 1.0), g_labels[id.label].text, true, g_labels[id.label].color_0, g_labels[id.label].color_1)
}

//-----------------------------------------------------------------------------
// PICTURE
//-----------------------------------------------------------------------------
var g_pictures [64]picture_s
var g_pictureCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type picture_id struct {
    base control_id
    picture i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type picture_s struct {
    id picture_id
    texture gfx.texture_s
    batch batch_id
    pictureAlign i32
    picturePosition mat.v2
    alpha bool
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_id_(base control_id, picture i32) (out picture_id) {
    out.base = base
    out.picture = picture
    uti.assert_(is_valid_picture(out), "picture_id_ : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_picture(id picture_id) (out bool) {
    out = id.picture >= 0 && id.picture < g_pictureCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_picture(name str) (out picture_id) {
    out.picture = g_pictureCount
    out.base = create_control_(name, GUI_PICTURE, out.picture)

    var picture picture_s
    picture.id = out
    picture.texture = gfx.invalid_texture()
    picture.batch = invalid_batch()
    picture.pictureAlign = ALIGN_NONE
    picture.picturePosition = mat.v2_zero
    picture.alpha = false

    g_pictures[out.picture] = picture
    g_pictureCount = out.picture + 1
    uti.assert_(is_valid_picture(out), "create_picture : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_set_texture(id picture_id, texture texture_s) {
    uti.assert_(is_valid_picture(id), "picture_set_texture : invalid id")
    g_pictures[id.picture].texture = texture
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_set_align(id picture_id, align i32) {
    uti.assert_(is_valid_picture(id), "picture_set_align : invalid id")
    g_pictures[id.picture].pictureAlign = align
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize_picture(id picture_id) () {
   uti.assert_(is_valid_picture(id), "resize_picture : invalid id")

    var i32Width i32 = g_pictures[id.picture].texture.width
    var i32Height i32 = g_pictures[id.picture].texture.height

    var pixelBounds mat.v2 = mat.v2_(i32.f32(i32Width), i32.f32(i32Height))
    var bounds mat.v2 = mat.v2_div(pixelBounds, gfx.gfx_viewport)

    resize_control_(id.base, pixelBounds, bounds, bounds)

    var position mat.v2 = g_controls[id.base].renderPosition
    //var size mat.v2 = g_controls[id.base].renderSize
    var size mat.v2 = g_controls[id.base].size
    var scale mat.v2 = g_controls[id.base].scale
    var padding mat.v4 = g_controls[id.base].padding
    //printf("PICTURE_SCALE %f, %f, width %f, height %f, scale.x * width %f, scale.y * height %f\n", scale.x, scale.y, width, height, scale.x * width, scale.y * height)

    var newSize mat.v2 = mat.v2_mul(scale, bounds)
    //printf("NEW SIZE %f, %f - %f, %f -> %f, %f\n", bounds.x, bounds.y, newSize.x, newSize.y, size.x, size.y)
    position.x, position.y = align_control(g_pictures[id.picture].pictureAlign, 0.0, 0.0, newSize.x, newSize.y, position.x, position.y, size.x, size.y, padding)
    //printf("PICTURE_POSITION %f, %f\n", position.x, position.y)
    g_pictures[id.picture].picturePosition = position
    g_pictures[id.picture].batch = get_batch(g_pictures[id.picture].texture, g_pictures[id.picture].alpha)
    //control_print("resize_picture : AFTER", id.base, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_picture(id picture_id) () {
    uti.assert_(is_valid_picture(id), "render_picture : invalid id")

    render_control(id.base)

    var control i32 = id.base.control

    var color mat.v4 = gfx.white
    var controlSkin control_skin_id = g_controls[control].skin
    uti.assert_(is_valid_control_skin(controlSkin) || controlSkin.skin == -1, "render_picture : invalid id")
    if is_valid_control_skin(controlSkin) {
        var backLayerSkin layer_skin_id = g_controlSkins[controlSkin.skin].back
        uti.assert_(is_valid_layer_skin(backLayerSkin) || backLayerSkin.layer == -1, "render_picture : invalid id")
        if is_valid_layer_skin(backLayerSkin) {
            color = g_layerSkins[backLayerSkin.layer].surface
        }
    }

    var texture gfx.texture_s = g_pictures[id.picture].texture
    if texture.name > 0 {
        //printf("RENDER_BOUNDS %f, %f, %f, %f\n",
          //  g_controls[id.control].renderBounds.x,
            //g_controls[id.control].renderBounds.y,
            //g_controls[id.control].renderBounds.z,
            //g_controls[id.control].renderBounds.w)

        var i32Width i32 = g_pictures[id.picture].texture.width
        var i32Height i32 = g_pictures[id.picture].texture.height

        var scale mat.v2 = g_controls[id.base].scale

        //control_print("render_picture : ", id.base, false)
        var width f32 = scale.x * i32.f32(i32Width) / gfx.gfx_width
        var height f32 = scale.y * i32.f32(i32Height) / gfx.gfx_height

        var renderPosition mat.v2 = g_pictures[id.picture].picturePosition
        //var renderPosition mat.v2 = g_controls[id.base].renderPosition

        var batch batch_id = g_pictures[id.picture].batch
        uti.assert_(is_valid_batch(batch), "render_picture : invalid batch")

        var meshId gfx.mesh_id = g_batches[batch.batch].mesh
        gfx.append_quad(meshId, mat.v4_v2v2(renderPosition, mat.v2_(width, height)), mat.v4_(0.0, 0.0, 1.0, 1.0), color)
    }
}

//-----------------------------------------------------------------------------
// WINDOW
//-----------------------------------------------------------------------------
var g_windows[8] window_s
var g_windowCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type window_id struct {
    base control_id
    window i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type window_s struct {
    id window_id
    header control_id
    caption label_id
    container control_id
    strip control_id
    dialog i32
    ok label_id
    cancel label_id
    yes label_id
    no label_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_id_(base control_id, window i32) (out window_id) {
    out.base = base
    out.window = window
    uti.assert_(is_valid_window(out), "window_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_window(id window_id) (out bool) {
    out = id.window >= 0 && id.window < g_windowCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_set_caption(id window_id, text str) () {
    uti.assert_(is_valid_window(id), " window_set_caption : invalid id")
    label_set_text(g_windows[id.window].caption, text)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_set_containee(id window_id, containee control_id) {
    uti.assert_(is_valid_window(id), "window_set_containee : invalid id")
    uti.assert_(is_valid_control(containee), "window_set_containee : invalid containee")

    var container control_id = g_windows[id.window].container
    uti.assert_(is_valid_control(container), "window_set_containee : invalid container")

    control_add_child(container, containee)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_window(name str) (out window_id) {
    out.base = create_control_(name, GUI_WINDOW, out.window)
    out.window = g_windowCount

    var window window_s
    window.id = out

    g_windowCount = out.window + 1

    uti.assert_(is_valid_window(out), "create_window : invalid id")

    {
        var header control_id = create_control("header") // ##pending := 
        control_add_child(out.base, header)
        control_set_skin(header, g_headerControlSkin)
        control_set_size(header, mat.v2_(0.0, 0.1))
        control_set_dock(header, DOCK_TOP)
        window.header = header

        var caption label_id = create_label("label")
        control_add_child(header, caption.base)
        //control_set_autoscale(caption.base, AUTOSCALE)
        control_set_dock(caption.base, DOCK_FILL)
        label_set_align(caption, ALIGN_CENTER)
        label_set_font(caption, g_boldFont) // ##1 skin
        label_set_color(caption, g_white)
        label_set_size(caption, g_fontSizeButton)
        window.caption = caption
    }

    {
        var strip control_id = create_control("strip")
        control_add_child(out.base, strip)
        control_set_dock(strip, DOCK_BOTTOM)
        control_set_skin(strip, g_bootControlSkin)
        //control_set_autosize(strip, AUTOSIZE)
        control_set_bounds(strip, mat.v4_(0.0, 0.0, 0.0, 0.12))
        window.strip = strip
    }

    var buttonSize mat.v4 = mat.v4_(0.0, 0.0, 0.15, 0.1)

    {
        var yes label_id = create_label("yes")
        control_set_bounds(yes.base, buttonSize)
        control_set_skin(yes.base, g_headerControlSkin)
        //control_set_autoscale(yes.base, AUTOSCALE)
        control_set_dock(yes.base, DOCK_RIGHT)
        control_set_padding(yes.base, mat.v4_(0.01, 0.01, 0.01, 0.01))
        label_set_align(yes, ALIGN_CENTER)
        label_set_color(yes, g_white)
        label_set_font(yes, g_boldFont)
        label_set_text(yes, "Yes")
        label_set_size(yes, g_fontSizeButton)
        window.yes = yes
    }

    {
        var no label_id = create_label("no")
        control_set_bounds(no.base, buttonSize)
        control_set_skin(no.base, g_headerControlSkin)
        //control_set_autoscale(no.base, AUTOSCALE)
        control_set_dock(no.base, DOCK_RIGHT)
        control_set_padding(no.base, mat.v4_(0.01, 0.01, 0.01, 0.01))
        label_set_align(no, ALIGN_CENTER)
        label_set_color(no, g_white)
        label_set_font(no, g_boldFont)
        label_set_text(no, "No")
        label_set_size(no, g_fontSizeButton)
        window.no = no
    }

    {
        var ok label_id = create_label("ok")
        control_set_bounds(ok.base, buttonSize)
        control_set_skin(ok.base, g_headerControlSkin)
        //control_set_autoscale(ok.base, AUTOSCALE)
        control_set_dock(ok.base, DOCK_RIGHT)
        control_set_padding(ok.base, mat.v4_(0.01, 0.01, 0.01, 0.01))
        label_set_align(ok, ALIGN_CENTER)
        label_set_color(ok, g_white)
        label_set_font(ok, g_boldFont)
        label_set_text(ok, "Ok")
        label_set_size(ok, g_fontSizeButton)
        window.ok = ok
    }

    {
        var cancel label_id = create_label("cancel")
        control_set_bounds(cancel.base, buttonSize)
        control_set_skin(cancel.base, g_headerControlSkin)
        //control_set_autoscale(cancel.base, AUTOSCALE)
        control_set_dock(cancel.base, DOCK_RIGHT)
        control_set_padding(cancel.base, mat.v4_(0.01, 0.01, 0.01, 0.01))
        label_set_align(cancel, ALIGN_CENTER)
        label_set_color(cancel, g_white)
        label_set_font(cancel, g_boldFont)
        label_set_text(cancel, "Cancel")
        label_set_size(cancel, g_fontSizeButton)
        window.cancel = cancel
    }

    {
        var container control_id = create_control("container")
        control_add_child(out.base, container)
        //control_set_skin(container, g_redControlSkin)
        //control_set_autosize(container, AUTOSIZE)
        control_set_dock(container, DOCK_FILL)
        control_set_padding(container, mat.v4_(0.01, 0.0, 0.01, 0.01))
        window.container = container
    }

    g_windows[out.window] = window
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_set_dialog(id window_id, dialog i32) {
    uti.assert_(is_valid_window(id), "set_dialog : invalid id")
    g_windows[id.window].dialog = dialog
    var strip control_id = g_windows[id.window].strip
    control_clear_child(strip)
    if (dialog == DIALOG_OK) {
        control_add_child(strip, g_windows[id.window].ok.base)
    } else if (dialog == DIALOG_OK_CANCEL) {
        control_add_child(strip, g_windows[id.window].cancel.base)
        control_add_child(strip, g_windows[id.window].ok.base)
  } else if (dialog == DIALOG_YES_NO) {
        control_add_child(strip, g_windows[id.window].no.base)
        control_add_child(strip, g_windows[id.window].yes.base)
    } else if (dialog != DIALOG_NONE) {
        uti.assert_(false, "invalid dialog value")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize_window(id window_id) () {
    uti.assert_(is_valid_window(id), "resize_window : invalid id")
    //control_print("RESIZE_WINDOW : ", id.base, false)
    resize_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_window(id window_id) () {
    uti.assert_(is_valid_window(id), "render_window : invalid id")
    //control_print("RENDER_WINDOW: ", id.base, false)
    render_control(id.base)
}

//-----------------------------------------------------------------------------
// KEYBOARD
//-----------------------------------------------------------------------------
var g_keyboards[8] keyboard_s
var g_keyboardCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type keyboard_id struct {
    base control_id
    keyboard i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type keyboard_s struct {
    id keyboard_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_id_(base control_id, keyboard i32) (out keyboard_id) {
    out.base = base
    out.keyboard = keyboard
    uti.assert_(is_valid_keyboard(out), "keyboard_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_keyboard(id keyboard_id) (out bool) {
    out = id.keyboard >= 0 && id.keyboard < g_keyboardCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_keyboard(name str) (out keyboard_id) {
    out.keyboard = g_keyboardCount
    out.base = create_control_(name, GUI_KEYBOARD, out.keyboard)

    var keyboard keyboard_s
    keyboard.id = out

    g_keyboards[out.keyboard] = keyboard
    g_keyboardCount = out.keyboard + 1
    uti.assert_(is_valid_keyboard(out), "create_keyboard : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize_keyboard(id keyboard_id) () {
    uti.assert_(is_valid_keyboard(id), "resize_keyboard : invalid id")
    resize_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*func render_keyboard() () {
    var rowCount i32 = 10
    var lineCount i32 = 4

    var fRowCount f32 = i32.f32(rowCount)
    var fLineCount f32 = i32.f32(lineCount)

    var keyWidth f32 = 0.08
    var keyHeight f32 = 0.08 * gfx.gfx_ratio

    var height f32 = fLineCount * keyHeight + (fLineCount + 1.0) * gui.padding.y
    var width f32 = fRowCount * keyWidth + (fRowCount + 1.0) * gui.padding.x

    var w f32 = width
    var h f32 = height
    var x f32 = -1.0 + (2.0 - w) / 2.0
    var y f32 = -1.0 + gui.padding.y
    gfx.append_quad(g_opaqueVertexColoredTriangles, mat.v4_(x, y, w, h), mat.v4_(0.0, 0.0, 1.0, 1.0), gui.g_gray_2)
    gfx.append_rect(g_opaqueVertexColoredLines, mat.v4_(x, y, w, h), gui.g_gray_3, gui.g_gray_3, gui.g_gray_3, gui.g_gray_3)

    var count i32 = 0
    var i i32 = 0
    var j i32 = 0
    for i = 0; i < rowCount; i = i + 1 {
        for j = 0; j < lineCount; j = j + 1 {
            var kx f32 = gui.padding.x + x + i32.f32(i) * (gui.padding.x + keyWidth)
            var ky f32 = gui.padding.y + y + i32.f32(j) * (gui.padding.y + keyHeight)
            var kw f32 = keyWidth
            var kh f32 = keyHeight
            gfx.append_quad(g_opaqueVertexColoredTriangles, mat.v4_(kx, ky, kw, kh), mat.v4_(0.0, 0.0, 1.0, 1.0), gui.g_primary_blue)
            gfx.append_text(g_alphaTexturedTriangles, g_skycoinFontTexture, "skycoin", kx, ky, gui.g_light_blue, "A", false, false)
            gfx.append_rect(g_opaqueVertexColoredLines, mat.v4_(kx, ky, kw, kh), gui.g_primary_blue, gui.g_primary_blue, gui.g_primary_blue, gui.g_primary_blue)
            count = count + 1
        }
    }
}*/

func render_keyboard(id keyboard_id) () {
    uti.assert_(is_valid_keyboard(id), "render_keyboard : invalid id")
    render_control(id.base)
}

//-----------------------------------------------------------------------------
// PARTITION
//-----------------------------------------------------------------------------
var g_partitions[8] partition_s
var g_partitionCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type partition_id struct {
    base control_id
    partition i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type partition_s struct {
    id partition_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_id_(base control_id, partition i32) (out partition_id) {
    out.base = base
    out.partition = partition
    uti.assert_(is_valid_partition(out), "partition_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_partition(id partition_id) (out bool) {
    out = id.partition >= 0 && id.partition < g_partitionCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_partition(name str) (out partition_id) {
    out.partition = g_partitionCount
    out.base = create_control_(name, GUI_PARTITION, out.partition)

    var partition partition_s
    partition.id = out

    g_partitions[out.partition] = partition
    g_partitionCount = out.partition + 1
    uti.assert_(is_valid_partition(out), "create_partition : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize_partition(id partition_id) () {
    uti.assert_(is_valid_partition(id), "resize_partition : invalid id")
    resize_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_partition(id partition_id) () {
    uti.assert_(is_valid_partition(id), "render_partition : invalid id")
    render_control(id.base)
}

//-----------------------------------------------------------------------------
// GUI
//-----------------------------------------------------------------------------
func init() () {
   // meshes
    var attributes [3]i32
    attributes = [3]i32{3, 4, 2} // can't use slice yet
    g_opaqueVertexColoredTriangles = gfx.create_mesh(gl.TRIANGLES, attributes, 10 * 2048 * 3)
    g_alphaVertexColoredTriangles = gfx.create_mesh(gl.TRIANGLES, attributes, 10 * 2048 * 3)
    g_opaqueVertexColoredLines = gfx.create_mesh(gl.LINES, attributes, 10 * 2048 * 2)
    g_fullscreenQuad = gfx.create_mesh(gl.TRIANGLES, attributes, 6 * 3)

    gfx.begin_mesh(g_fullscreenQuad)
    gfx.append_quad(g_fullscreenQuad, mat.v4_(-1.0, 1.0, 2.0, -2.0), mat.v4_(0.0, 0.0, 1.0, 1.0), gfx.white)
    gfx.end_mesh(g_fullscreenQuad)

    // fonts
    g_regularFont = create_font("skycoinRegular", "fonts/Skycoin-Regular.ttf", 32, 127, gltext.LeftToRight)
    font_add_size(g_regularFont, g_fontSizeText)
    font_add_size(g_regularFont, g_fontSizeButton)
    font_add_size(g_regularFont, g_fontSizeHeader)
    font_add_size(g_regularFont, g_fontSizeTitle)

    g_boldFont = create_font("skycoinBold", "fonts/Skycoin-Bold.ttf", 32, 127, gltext.LeftToRight)
    font_add_size(g_boldFont, g_fontSizeText)
    font_add_size(g_boldFont, g_fontSizeButton)
    font_add_size(g_boldFont, g_fontSizeHeader)
    font_add_size(g_boldFont, g_fontSizeTitle)

    // textures
    g_skycoinTexture = gfx.create_texture("textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png", gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)

    // layers
    g_debugLayerSkin            = create_layer_skin("debug"         , g_red               , g_green , g_green , g_green , g_green )
    g_bootLayerSkin             = create_layer_skin("boot"          , g_black             , gfx.zero, gfx.zero, gfx.zero, gfx.zero)
    g_blackLayerSkin            = create_layer_skin("black"         , g_black             , g_gray_3, g_gray_3, g_gray_3, g_gray_3)
    g_redLayerSkin              = create_layer_skin("red"           , g_red               , gfx.zero, gfx.zero, gfx.zero, gfx.zero)
    g_greenLayerSkin            = create_layer_skin("green"         , g_green             , gfx.zero, gfx.zero, gfx.zero, gfx.zero)
    g_primaryBlueLayerSkin      = create_layer_skin("primaryBlue"   , g_primary_blue      , gfx.zero, gfx.zero, gfx.zero, gfx.zero)
    g_primaryBlueAlphaLayerSkin = create_layer_skin("primaryBlueA50", g_primary_blue_a50  , gfx.zero, gfx.zero, gfx.zero, gfx.zero)
    g_modalLayerSkin            = create_layer_skin("modal"         , g_black_a50         , gfx.zero, gfx.zero, gfx.zero, gfx.zero)
    g_windowLayerSkin           = create_layer_skin("window"        , g_black             , g_gray_3, g_gray_3, g_gray_3, g_gray_3)
    g_headerLayerSkin           = create_layer_skin("header"        , g_gray_2            , g_gray_3, g_gray_3, g_gray_3, g_gray_3)
    g_stripLayerSkin            = create_layer_skin("strip"         , g_gray_1            , g_gray_2, g_gray_2, g_gray_2, g_gray_2)
    // controls
    g_debugControlSkin           = create_control_skin("debug"          , g_debugLayerSkin      , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
g_bootControlSkin            = create_control_skin("boot"           , g_bootLayerSkin       , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_blackControlSkin           = create_control_skin("black"          , g_blackLayerSkin      , invalid_layer_skin()                         , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_redControlSkin             = create_control_skin("red"            , g_redLayerSkin        , invalid_layer_skin()                         , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_greenControlSkin           = create_control_skin("green"          , g_greenLayerSkin      , invalid_layer_skin()                         , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_primaryBlueControlSkin     = create_control_skin("primaryBlue"    , g_primaryBlueLayerSkin, invalid_layer_skin()                         , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_primaryBlueAlphaControlSkin= create_control_skin("primaryBlueA50" , invalid_layer_skin()       , g_primaryBlueAlphaLayerSkin, invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_modalControlSkin           = create_control_skin("modal"          , g_modalLayerSkin      , invalid_layer_skin()                         , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_windowControlSkin          = create_control_skin("window"         , g_windowLayerSkin     , invalid_layer_skin()                         , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_headerControlSkin          = create_control_skin( "header"         , g_headerLayerSkin     , invalid_layer_skin()                         , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_stripControlSkin          = create_control_skin("strip"         , g_stripLayerSkin     , invalid_layer_skin()                         , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())

    printf("C5\n")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func update(deltaTime f64)() { // ##1 rewrite

    //printf("UPDATE %d, %d\n", g_currentScreen.screen, g_nextScreen.screen)
    if (is_valid_screen(g_currentScreen)) {
        update_screen(g_currentScreen, deltaTime)
        if (screen_state_changed(g_currentScreen, STATE_OPENED, STATE_CLOSING)) {
            g_nextScreen = g_screens[g_currentScreen.screen].on_next // ##issue_58 issue array index with struct
            printf("NEXT_SCREEN %d\n", g_nextScreen.screen)
            printf("CURRENT %d, NEXT %d\n", g_currentScreen.screen, g_nextScreen.screen)
            g_transitionTime = 0.0D
            g_screens[g_currentScreen.screen].prevState= g_screens[g_currentScreen.screen].state
            printf("screen : %d, STATE_CLOSING\n", g_currentScreen.screen)
        } else if (screen_state_changed(g_currentScreen, STATE_CLOSING, STATE_CLOSED)) {
            g_screens[g_currentScreen.screen].time = 0.0D
            g_screens[g_currentScreen.screen].prevState = g_screens[g_currentScreen.screen].state
            g_currentScreen = g_nextScreen
            printf("screen : %d, STATE_CLOSED\n", g_currentScreen.screen)
        }
    }

    if (g_currentScreen.screen != g_nextScreen.screen) {
        if (is_valid_screen(g_nextScreen)) {
            update_screen(g_nextScreen, deltaTime)
        }

        if (g_transitionTime <= 0) {
            printf("TRANSITION STARTED %f\n", f64.f32(g_transitionTime + deltaTime))
            g_transitionTime = g_transitionTime + deltaTime
        } else if (g_transitionTime <= g_transitionDuration) {
            g_transitionTime = g_transitionTime + deltaTime
        } else {
            printf("TRANSITION ENDED\n")
            if (is_valid_screen(g_currentScreen)) {
                printf("CHANGE CLOSED\n")
                change_screen_state(g_currentScreen, STATE_CLOSED)
                printf("prev screen : %d, %d, %s\n", g_currentScreen.screen, g_screens[g_currentScreen.screen].state, "STATE_CLOSED")
            }

            g_currentScreen = g_nextScreen
            printf("CURRENT_SCREEN %d\n", g_nextScreen.screen)
            if (is_valid_screen(g_nextScreen)) {
                var nextScreen screen_id = g_screens[g_nextScreen.screen].on_next
                printf("CHANGE OPENED\n")
                change_screen_state(g_nextScreen, STATE_OPENED)
                printf("next screen : %d, %d, %s\n", g_nextScreen.screen, g_screens[g_nextScreen.screen].state, "STATE_OPENED")
                g_transitionTime = 0.0D
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var KEY_RELEASE i32 = 0
var KEY_PRESS i32 = 1
var KEY_REPEAT i32 = 2

var KEYCODE_ESCAPE i32 = 256
var KEYCODE_ENTER i32 = 257
var KEYCODE_LEFT_CTRL i32 = 341
var KEYCODE_MENU i32 = 343

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*func skip_screens()() {
    var next bool = true
    var skipId screen_id = g_currentScreen
    for (next == true) {
        var nextId screen_id = g_screens[skipId].on_next
        if (is_valid_screen(nextId)) {
            if (is_valid_screen(g_screens[nextId.screen].on_exit) ||
                is_valid_screen(g_screens[nextId.screen].on_enter) ||
                is_valid_screen(g_screens[nextId.screen].on_menu)) {
                next = false
            }
            skipId = nextId
        } else {
            next = false
        }
    }
    g_nextScreen = skipId
}*/

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_keyboard(window str, key i32, scancode i32, action i32, mods i32) () {

    if (g_modalCount > 0) {
        if (key == KEYCODE_ESCAPE && action == KEY_PRESS) {
                g_modalCount = g_modalCount - 1
        }
    } else {
    printf("key pressed : %d, scancode %d, action %d, mods %d\n", key, scancode, action, mods)
    if (is_valid_screen(g_currentScreen)) {

        var screen i32 = g_currentScreen.screen
        var state i32 = g_screens[screen].state
        //if (g_screens[g_currentScreen.screen].state == STATE_OPENED) { // ##pending
        //} else if (g_screens[g_currentScreen.screen].state == STATE_SHOWING) { // ##pending
        if (state == STATE_OPENED || state == STATE_SHOWING) {
            if (key == KEYCODE_ESCAPE && action == KEY_PRESS) {
                g_screens[screen].paused = true
                var onExit screen_id = g_screens[screen].on_exit
                if (is_valid_screen(onExit) == true) {
                    show_screen(onExit)
                } else {
                    printf("INVALID ON EXIT SCREEN %d, %d\n", onExit.screen, onExit.base)
                }
            } else if (key == KEYCODE_ENTER && action == KEY_PRESS) {
                g_screens[screen].paused = true
                var onEnter screen_id = g_screens[screen].on_enter
                if (is_valid_screen(onEnter) == true) {
                    show_screen(onEnter)
                }
            } else if (key == KEYCODE_LEFT_CTRL && action == KEY_PRESS) {
                g_screens[screen].paused = true
                var onMenu screen_id = g_screens[screen].on_menu
                if (is_valid_screen(onMenu) == true) {
                    show_screen(onMenu)
                }
            }
        }
    }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func show_screen(id screen_id) () {
    uti.assert_(is_valid_screen(id), "show_modal_screen : invalid id")

    var modal bool = g_screens[id.screen].modal
    if (modal == true) {
        g_modals[g_modalCount] = id
        g_modalCount = g_modalCount + 1
    } else {
        g_nextScreen = id
        g_transitionTime = 0.0D
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize() () {
    clear_batches()
    if (is_valid_screen(g_currentScreen)) {
        reset_scope()
        resize_screen(g_currentScreen)
        redock_control(g_currentScreen.base)
        resize_screen(g_currentScreen)
        redock_control(g_currentScreen.base)
    }
    if (is_valid_screen(g_nextScreen) && g_currentScreen.screen != g_nextScreen.screen) {
        reset_scope()
        resize_screen(g_nextScreen)
        redock_control(g_nextScreen.base)
        resize_screen(g_nextScreen)
        redock_control(g_nextScreen.base)
    }

    var i i32 = 0
    for i = 0; i < g_modalCount; i = i + 1 {
        //control_print("before resize : ", g_modals[i].base, false)
        printf("_-------------------------------------------------------------------------------->>>>\n")
        reset_scope()
        resize_screen(g_modals[i])
        redock_control(g_modals[i].base)
        resize_screen(g_modals[i])
        redock_control(g_modals[i].base)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render() () {

    //var clearColor mat.v4 = mat.v4_(1.0, 0.0, 1.0, 1.0)
    var clearColor mat.v4 = g_black
    var target_0 target_s = gfx.lock_target(app.app_width, app.app_height)
    gfx.bind_framebuffer(target_0.framebuffer)
    gfx.clear(gl.COLOR_BUFFER_BIT, clearColor)
    if (is_valid_screen(g_currentScreen)) {
        render_screen(g_currentScreen)
    }

    var target_1 target_s = gfx.lock_target(app.app_width, app.app_height)
    gfx.bind_framebuffer(target_1.framebuffer)
    gfx.clear(gl.COLOR_BUFFER_BIT, clearColor)
    if (is_valid_screen(g_nextScreen) && g_nextScreen.screen != g_currentScreen.screen) {
        render_screen(g_nextScreen)
    }

    var target_2 target_s = gfx.lock_target(app.app_width, app.app_height)
    gfx.bind_framebuffer(target_2.framebuffer)
    gfx.clear(gl.COLOR_BUFFER_BIT, clearColor)
    gfx.disable_depth()
    gfx.disable_blending()
    gfx.effect_use(gfx.g_fxTrans_0)
    gfx.effect_assign_texture(gfx.g_fxTrans_0, 0, target_0.texture.name)
    gfx.effect_assign_texture(gfx.g_fxTrans_0, 1, target_1.texture.name)
    gfx.effect_assign_float(gfx.g_fxTrans_0, 0, f64.f32(g_transitionTime / g_transitionDuration))
    gfx.render_mesh(g_fullscreenQuad)
    gfx.unlock_target(target_0)
    gfx.unlock_target(target_1)

    var i i32 = 0
    for i = 0; i < g_modalCount; i = i + 1 {
        var target target_s = gfx.lock_target(app.app_width, app.app_height)
        gfx.bind_framebuffer(target.framebuffer)
        gfx.clear(gl.COLOR_BUFFER_BIT, clearColor)
        if (is_valid_screen(g_modals[i])) {
            //control_print("modal : ", g_modals[i].base, false)
            render_screen(g_modals[i])
        }

        var target_3 target_s = gfx.lock_target(app.app_width, app.app_height)
        gfx.bind_framebuffer(target_3.framebuffer)
        gfx.clear(gl.COLOR_BUFFER_BIT, clearColor)
        gfx.disable_depth()
        gfx.disable_blending()
        gfx.effect_use(gfx.g_fxTrans_1)
        gfx.effect_assign_texture(gfx.g_fxTrans_1, 0, target_2.texture.name)
        gfx.effect_assign_texture(gfx.g_fxTrans_1, 1, target.texture.name)
        gfx.effect_assign_float(gfx.g_fxTrans_1, 0, 1.0)
        gfx.render_mesh(g_fullscreenQuad)
        gfx.unlock_target(target)
        gfx.unlock_target(target_2)
        target_2 = target_3
    }

    // ##todo fast path if no modals => render in default framebuffer 0
    gfx.bind_framebuffer(0)
    gfx.clear(gl.COLOR_BUFFER_BIT, g_black)
    gfx.disable_depth()
    gfx.disable_blending()
    gfx.effect_use(gfx.g_fxTexture)
    gfx.effect_assign_texture(gfx.g_fxTexture, 0, target_2.texture.name)
    gfx.render_mesh(g_fullscreenQuad)
    gfx.unlock_target(target_2)

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

