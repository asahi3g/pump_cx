//-----------------------------------------------------------------------------
// gui
//-----------------------------------------------------------------------------
package gui

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
import "app"
import "gl"
import "glfw"
import "gltext"
import "gfx"
import "mat"
import "uti"

//-----------------------------------------------------------------------------
// gfx
//-----------------------------------------------------------------------------
var g_opaqueVertexColoredLines      gfx.mesh_id
var g_alphaVertexColoredTriangles   gfx.mesh_id
var g_opaqueVertexColoredTriangles  gfx.mesh_id
var g_fullscreenQuad                gfx.mesh_id

var g_skycoinTexture gfx.texture_s

//-----------------------------------------------------------------------------
// GUI
//-----------------------------------------------------------------------------
var GUI_INVALID     i32 = 0
var GUI_CONTROL     i32 = 1
var GUI_SCREEN      i32 = 2
var GUI_PICTURE     i32 = 3
var GUI_LABEL       i32 = 4
var GUI_PARTITION   i32 = 5
var GUI_KEYBOARD    i32 = 6
var GUI_WINDOW      i32 = 7
var GUI_GRAPH       i32 = 8

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var STATE_CLOSED    i32 = 0
var STATE_SHOWING   i32 = 1
var STATE_OPENED    i32 = 2
var STATE_CLOSING   i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var DOCK_NONE       i32 = 0
var DOCK_LEFT       i32 = 1
var DOCK_RIGHT      i32 = 2
var DOCK_TOP        i32 = 3
var DOCK_BOTTOM     i32 = 4
var DOCK_FILL       i32 = 5

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var DIALOG_NONE      i32 = 0
var DIALOG_OK        i32 = 1
var DIALOG_OK_CANCEL i32 = 2
var DIALOG_YES_NO    i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var ALIGN_NONE          i32 =  0
var ALIGN_LEFT          i32 =  1
var ALIGN_RIGHT         i32 =  2
var ALIGN_HORZ          i32 =  3
var ALIGN_BOTTOM        i32 =  4
var ALIGN_LEFT_BOTTOM   i32 =  5
var ALIGN_RIGHT_BOTTOM  i32 =  6
var ALIGN_HORZ_BOTTOM   i32 =  7
var ALIGN_TOP           i32 =  8
var ALIGN_LEFT_TOP      i32 =  9
var ALIGN_RIGHT_TOP     i32 = 10
var ALIGN_HORZ_TOP      i32 = 11
var ALIGN_VERT          i32 = 12
var ALIGN_VERT_LEFT     i32 = 13
var ALIGN_VERT_RIGHT    i32 = 14
var ALIGN_CENTER        i32 = 15

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTOSIZE_NONE   i32 = 0
var AUTOSIZE_X      i32 = 1
var AUTOSIZE_Y      i32 = 2
var AUTOSIZE        i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTORATIO_NONE  i32 = 0
var AUTORATIO_X     i32 = 1
var AUTORATIO_Y     i32 = 2

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTOSCALE_NONE  i32 = 0
var AUTOSCALE_X     i32 = 1
var AUTOSCALE_Y     i32 = 2
var AUTOSCALE       i32 = 3


//-----------------------------------------------------------------------------
// DUMMY
//-----------------------------------------------------------------------------
/*type dummy_id struct {
    base control_id
    dummy i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type dummy_s struct {
    id dummy_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func dummy_id_(base control_id, dummy i32) (out dummy_id) {
    out.base = base
    out.dummy = dummy
    uti.assert_(is_valid_dummy(out), "dummy_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_dummy(id dummy_id) (out bool) {
    out = id.dummy >= 0 && id.dummy < g_dummyCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_dummys[8] dummy_s
var g_dummyCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func dummy_create(name str) (out dummy_id) {
    out.base = create_control_(name, GUI_DUMMY, out.dummy)
    out.dummy = g_dummyCount

    var dummy dummy_s
    dummy.id = out

    g_dummys[out.dummy] = dummy
    g_dummyCount = out.dummy + 1
    uti.assert_(is_valid_dummy(out), "create_dummy : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func dummy_process_event(id dummy_id, event *event_s) (out i32) {
    uti.assert_(is_valid_dummy(id), "dummy_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func dummy_resize(id dummy_id) () {
    uti.assert_(is_valid_dummy(id), "resize_dummy : invalid id")
    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func dummy_render(id dummy_id) () {
    uti.assert_(is_valid_dummy(id), "render_dummy : invalid id")
    control_render(id.base)
}*/


//-----------------------------------------------------------------------------
// FONT
//-----------------------------------------------------------------------------
type font_id struct {
    font i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type font_s struct {
    id font_id
    name str
    path str
    min i32
    max i32
    direction i32
    textureCount i32
    textures [8]texture_s
    names [8]str
    sizes [8]i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_fonts [8]font_s
var g_fontCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_font()(out font_id) {
    out.font = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_font(id font_id) (out bool) {
    out = id.font >= 0 && id.font < g_fontCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_font(name str, path str, min i32, max i32, direction i32) (out font_id) {
    uti.assert_(g_fontCount < len(g_fonts), "create_font : overflow") // ##1 use slice
    out.font = g_fontCount

    var font font_s
    font.id = out
    font.name = name
    font.path = path
    font.min = min
    font.max = max
    font.direction = direction
    font.textureCount = 0

    g_fonts[out.font] = font
    g_fontCount = out.font + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func font_add_size(id font_id, size i32) {
    uti.assert_(is_valid_font(id), "font_add_size : invalid id")

    var index i32 = id.font

    var name str
    name = g_fonts[index].name

    var path str
    path = g_fonts[index].path

    var min i32 = g_fonts[index].min
    var max i32 = g_fonts[index].max
    var dir i32 = g_fonts[index].direction

    var textureName str
    textureName = sprintf("%s_%d", name, size)

    var textureCount i32 = g_fonts[index].textureCount
    printf("font_add_size %d, : %s, %d\n", textureCount, textureName, size)
    g_fonts[index].textures[textureCount] = gfx.create_font_texture(textureName, path, size, min, max, dir)
    g_fonts[index].names[textureCount] = textureName
    g_fonts[index].sizes[textureCount] = size

    g_fonts[index].textureCount = textureCount + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func font_get_texture_index(id font_id, size i32) (out i32) {
    uti.assert_(is_valid_font(id), "font_get_texture_index : invalid id")

    var textureCount i32 = g_fonts[id.font].textureCount

    out = -1
    if (textureCount > 0) {
        out = 0
    }
    var minSize i32 = size

    var i i32 = 0
    for i= 0 ; i < textureCount; i = i + 1 {
        var fontSize i32 = g_fonts[id.font].sizes[i]
        //printf("i %d, FONT_SIZE %d, size %d, minSize %d\n", i, fontSize, size, minSize)
        if (fontSize >= size && fontSize <= minSize) {
            out = i
        }
    }

    //printf("TEXTURE_INDEX %d\n", out)
}

//-----------------------------------------------------------------------------
// SCOPE
//-----------------------------------------------------------------------------
var g_docks [32]bound_s
var g_offsets [32]rectangle_s
var g_scopeIndex i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type bound_s struct {
    left f32
    bottom f32
    right f32
    top f32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type rectangle_s struct {
    x f32
    y f32
    width f32
    height f32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_dock bound_s
var g_offset rectangle_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func reset_scope()() {
    uti.assert_(g_scopeIndex == 0, "invalid scope")
    g_scopeIndex = 0

    g_dock.left = 0.0
    g_dock.bottom = 0.0
    g_dock.right = 2.0
    g_dock.top = 2.0

    g_offset.x = -1.0
    g_offset.y = -1.0
    g_offset.width = 2.0
    g_offset.height = 2.0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func push_scope()() {
    g_docks[g_scopeIndex] = g_dock
    g_offsets[g_scopeIndex] = g_offset
    g_scopeIndex = g_scopeIndex + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func pop_scope() () {
    uti.assert_(g_scopeIndex > 0, "stack underflow")
    g_scopeIndex = g_scopeIndex - 1
    g_dock = g_docks[g_scopeIndex]
    g_offset = g_offsets[g_scopeIndex]
}

//-----------------------------------------------------------------------------
// LAYER_SKIN
//-----------------------------------------------------------------------------
var g_layerSkins [256]layer_skin_s
var g_layerSkinCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type layer_skin_id struct {
    layer i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_layer_skin() (out layer_skin_id) {
    out.layer = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type layer_skin_s struct {
    id layer_skin_id
    name str
    surface     mat.v4
    left        mat.v4
    bottom      mat.v4
    right       mat.v4
    top         mat.v4
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_layer_skin(id layer_skin_id) (out bool) {
    out = id.layer >= 0 && id.layer < g_layerSkinCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_layer_skin(name str, surface mat.v4, left mat.v4, bottom mat.v4, right mat.v4, top mat.v4) (out layer_skin_id) {
    uti.assert_(g_layerSkinCount < len(g_layerSkins), "create_layer : overflow") // ##1 use slice
    out.layer = g_layerSkinCount

    var layer layer_skin_s
    layer.id  = out
    layer.name    = name
    layer.surface = surface
    layer.left    = left
    layer.bottom  = bottom
    layer.right   = right
    layer.top     = top

    g_layerSkins[out.layer] = layer
    g_layerSkinCount = out.layer + 1
    uti.assert_(is_valid_layer_skin(out), "create_layer_skin : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func layer_skin_print(message str, id layer_skin_id) {
    uti.assert_(is_valid_layer_skin(id), "layer_skin_print : invalid id")
    var index i32 = id.layer
    printf("%s LAYER_SKIN %d - %s, SURFACE %f, %f, %f, %f, LEFT %f, %f, %f, %f, BOTTOM %f, %f, %f, %f, RIGHT %f, %f, %f, %f, TOP %f, %f, %f, %f\n",
        message,
        g_layerSkins[index].id.layer,
        g_layerSkins[index].name,
        g_layerSkins[index].surface.x,
        g_layerSkins[index].surface.y,
        g_layerSkins[index].surface.z,
        g_layerSkins[index].surface.w,
        g_layerSkins[index].left.x,
        g_layerSkins[index].left.y,
        g_layerSkins[index].left.z,
        g_layerSkins[index].left.w,
        g_layerSkins[index].bottom.x,
        g_layerSkins[index].bottom.y,
        g_layerSkins[index].bottom.z,
        g_layerSkins[index].bottom.w,
        g_layerSkins[index].right.x,
        g_layerSkins[index].right.y,
        g_layerSkins[index].right.z,
        g_layerSkins[index].right.w,
        g_layerSkins[index].top.x,
        g_layerSkins[index].top.y,
        g_layerSkins[index].top.z,
        g_layerSkins[index].top.w)
}

//-----------------------------------------------------------------------------
// CONTROL_SKIN
//-----------------------------------------------------------------------------
var g_controlSkins [256]control_skin_s
var g_controlSkinCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_skin_id struct {
    skin i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_skin_s struct {
    id control_skin_id
    name str
    back layer_skin_id
    front layer_skin_id
    hover_back layer_skin_id
    hover_front layer_skin_id
    disabled_back layer_skin_id
    disabled_front layer_skin_id
    focused_back layer_skin_id
    focused_front layer_skin_id
    selected_back layer_skin_id
    selected_front layer_skin_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_control_skin() (out control_skin_id) {
    out.skin = -1
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_control_skin(id control_skin_id) (out bool) {
    //printf("id.skin %d, %d\n", id.skin, g_controlSkinCount)
    out = (id.skin >= 0) && (id.skin < g_controlSkinCount)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_control_skin(name str, back layer_skin_id, front layer_skin_id, hoverBack layer_skin_id, hoverFore layer_skin_id, disabledBack layer_skin_id, disabledFore layer_skin_id, focusedBack layer_skin_id, focusedFore layer_skin_id, selectedBack layer_skin_id, selectedFore layer_skin_id)  (out control_skin_id) {
    printf("EVENT_UNUSED %d\n", EVENT_UNUSED)
    uti.assert_(g_controlSkinCount < len(g_controlSkins), "create_control_skin : overflow") // ##1 use slice
    out.skin = g_controlSkinCount

    var skin control_skin_s
    skin.name = name
    skin.id = out
    skin.back = back
    skin.front = front
    skin.hover_back = hoverBack
    skin.hover_front = hoverFore
    skin.disabled_back = disabledBack
    skin.disabled_front = disabledFore
    skin.focused_back = focusedBack
    skin.focused_front = focusedFore
    skin.selected_back = selectedBack
    skin.selected_front = selectedFore

    g_controlSkins[out.skin] = skin
    g_controlSkinCount = out.skin + 1
    uti.assert_(is_valid_control_skin(out), "create_control_skin : invalid id")
    control_skin_print("create_control_skin : ", out)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_skin_print(message str, id control_skin_id) {
    uti.assert_(is_valid_control_skin(id), "control_skin_print : invalid id")
    var index i32 = id.skin
    printf("%s CONTROL_SKIN %d - %s\n", message, g_controlSkins[index].id.skin, g_controlSkins[index].name)
    if (is_valid_layer_skin(g_controlSkins[index].back)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].back)
    }
    if (is_valid_layer_skin(g_controlSkins[index].front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].front)
    }
    if (is_valid_layer_skin(g_controlSkins[index].hover_back)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].hover_back)
    }
    if (is_valid_layer_skin(g_controlSkins[index].hover_front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].hover_front)
    }
    if (is_valid_layer_skin(g_controlSkins[index].disabled_back)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].disabled_back)
    }
    if (is_valid_layer_skin(g_controlSkins[index].disabled_front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].disabled_front)
    }
    if (is_valid_layer_skin(g_controlSkins[index].focused_back)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].focused_back)
    }
    if (is_valid_layer_skin(g_controlSkins[index].focused_front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].focused_front)
    }
    if (is_valid_layer_skin(g_controlSkins[index].selected_front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].selected_front)
    }
    if (is_valid_layer_skin(g_controlSkins[index].selected_front)) {
        layer_skin_print("control_skin_print : ", g_controlSkins[index].selected_front)
    }
}

//-----------------------------------------------------------------------------
// SKIN
//-----------------------------------------------------------------------------
var g_black             mat.v4 = mat.rgba_ui8( 30,  34,  39, 255)
var g_white             mat.v4 = mat.rgba_ui8(255, 251, 251, 255)
var g_primary_blue      mat.v4 = mat.rgba_ui8(  0, 114, 255, 255)
var g_light_blue        mat.v4 = mat.rgba_ui8(  0, 195, 255, 255)
var g_green             mat.v4 = mat.rgba_ui8(  0, 223, 128, 255)
var g_red               mat.v4 = mat.rgba_ui8(255,   0,  78, 255)
var g_gold              mat.v4 = mat.rgba_ui8(255, 193,  37, 255)
var g_gray_0            mat.v4 = mat.rgba_ui8( 34,  38,  43, 255)
var g_gray_1            mat.v4 = mat.rgba_ui8( 41,  45,  50, 255)
var g_gray_2            mat.v4 = mat.rgba_ui8( 74,  77,  81, 255)
var g_gray_3            mat.v4 = mat.rgba_ui8(140, 142, 145, 255)
var g_gray_4            mat.v4 = mat.rgba_ui8(206, 207, 208, 255)
var g_gray_5            mat.v4 = mat.rgba_ui8(239, 240, 240, 255)
var g_gray_6            mat.v4 = mat.rgba_ui8(247, 247, 247, 255)
var g_gray_7            mat.v4 = mat.rgba_ui8(251, 251, 251, 255)

var g_black_a50 mat.v4 = mat.v4_mul(g_black, mat.v4_(0.5, 0.5, 0.5, 0.8))
var g_primary_blue_a50  mat.v4 = alpha(g_primary_blue, 0.5)

var g_debugLayerSkin layer_skin_id
var g_bootLayerSkin layer_skin_id
var g_blackLayerSkin layer_skin_id
var g_redLayerSkin layer_skin_id
var g_greenLayerSkin layer_skin_id
var g_primaryBlueLayerSkin layer_skin_id
var g_primaryBlueAlphaLayerSkin layer_skin_id
var g_modalLayerSkin layer_skin_id
var g_windowLayerSkin layer_skin_id
var g_headerLayerSkin layer_skin_id
var g_focusedLayerSkin layer_skin_id
var g_stripLayerSkin layer_skin_id

var g_debugControlSkin control_skin_id
var g_bootControlSkin control_skin_id
var g_blackControlSkin control_skin_id
var g_redControlSkin control_skin_id
var g_greenControlSkin control_skin_id
var g_primaryBlueControlSkin control_skin_id
var g_primaryBlueAlphaControlSkin control_skin_id
var g_modalControlSkin control_skin_id
var g_windowControlSkin control_skin_id
var g_headerControlSkin control_skin_id
var g_buttonControlSkin control_skin_id
var g_stripControlSkin control_skin_id

var textureLogo str = "textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png"

var g_boldFont font_id = invalid_font()
var g_regularFont font_id = invalid_font()

var g_fontSizeTitle i32 = 64
var g_fontSizeHeader i32 = 55
var g_fontSizeButton i32 = 38
var g_fontSizeText i32 = 35

func alpha(color mat.v4, a f32) (out mat.v4) {
    //out = mat.v4_(color.x, color.y, color.z, (color.w * a)) // ##issue_57  out.w == 0
    out.x = color.x
    out.y = color.y
    out.z = color.z
    out.w = color.w * a
}

//-----------------------------------------------------------------------------
// CONTROL
//-----------------------------------------------------------------------------
var g_controls [256]control_s
var g_controlCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_id struct {
    control i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_s struct {
    id control_id
    name str
    gui_type i32
    gui_index i32

    skin control_skin_id

    focusIndex i32
    focusable i32
    focused i32

    dock i32
    align i32
    autosize i32
    autoscale i32

    position mat.v2
    size mat.v2
    scale mat.v2
    padding mat.v4

    renderPosition mat.v2
    children [128]control_id // can't make it work with slices
    childCount i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_control() (out control_id) {
    out.control = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_id_(control i32) (out control_id) {
    out.control = control
    uti.assert_(is_valid_control(out), "control_id_ : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_control(id control_id) (out bool) {
    out = id.control >= 0 && id.control < g_controlCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_control(name str) (out control_id) {
    out = create_control_(name, GUI_CONTROL, g_controlCount)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_control_(name str, gui_type i32, gui_index i32) (out control_id) {
    uti.assert_(g_controlCount < len(g_controls), "create_control : overflow") // ##1 use slice
    out.control = g_controlCount

    var control control_s
    control.id = out
    control.name = name
    control.gui_type  = gui_type
    control.gui_index = gui_index

    control.skin = invalid_control_skin()

    control.focusIndex = -1
    control.focusable = 0
    control.focused = 0

    control.dock      = DOCK_NONE
    control.align     = ALIGN_NONE
    control.autosize  = AUTOSIZE_NONE
    control.autoscale = AUTOSCALE_NONE

    control.position = mat.v2_zero
    control.size     = mat.v2_zero
    control.scale    = mat.v2_one

    control.childCount = 0
    g_controls[out.control] = control
    g_controlCount = out.control + 1
    uti.assert_(is_valid_control(out), "create_control : invalid control")
    control_print("create_control : ", out, true)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_print(message str, id control_id, printSkin bool) {
    uti.assert_(is_valid_control(id), "control_print : invalid control")
    var index i32 = id.control
    printf("%s - %d - %s, Type %d, Index %d, Focusable %d, Focusindex %d, Focused %d, Skin %d, Dock %d, Align %d, Autosize %d, Autoscale %d, Position %f, %f, Size %f, %f, Scale %f, %f, Children %d\n",
        message,
        g_controls[index].id.control,
        g_controls[index].name,
        g_controls[index].gui_type,
        g_controls[index].gui_index,
        g_controls[index].focusable,
        g_controls[index].focusIndex,
        g_controls[index].focused,
        g_controls[index].skin,
        g_controls[index].dock,
        g_controls[index].align,
        g_controls[index].autosize,
        g_controls[index].autoscale,
        g_controls[index].position.x,
        g_controls[index].position.y,
        g_controls[index].size.x,
        g_controls[index].size.y,
        g_controls[index].scale.x,
        g_controls[index].scale.y,
        g_controls[index].childCount)

    if (printSkin == true && is_valid_control_skin(g_controls[index].skin)) {
        control_skin_print("control_print : ", g_controls[index].skin)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_skin(id control_id, skin control_skin_id) {
    uti.assert_(is_valid_control(id)   , "control_set_skin : invalid id")
    uti.assert_(is_valid_control_skin(skin), "control_set_skin : invalid skin")
    g_controls[id.control].skin = skin
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_dock(id control_id, dock i32) {
    uti.assert_(is_valid_control(id), "control_set_dock : invalid id")
    g_controls[id.control].dock = dock
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_align(id control_id, align i32) {
    uti.assert_(is_valid_control(id), "control_set_align : invalid id")
    g_controls[id.control].align = align
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_autosize(id control_id, autosize i32) {
    uti.assert_(is_valid_control(id), "control_set_autosize : invalid id")
    g_controls[id.control].autosize = autosize
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_autoscale(id control_id, autoscale i32) {
    uti.assert_(is_valid_control(id), "control_set_autoscale : invalid id")
    g_controls[id.control].autoscale = autoscale
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_position(id control_id, position v2) {
    uti.assert_(is_valid_control(id), "control_set_position : invalid id")
    g_controls[id.control].position = position
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_size(id control_id, size v2) {
    uti.assert_(is_valid_control(id), "control_set_size : invalid id")
    g_controls[id.control].size = size
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_bounds(id control_id, bounds v4) {
    uti.assert_(is_valid_control(id), "control_set_bounds : invalid id")
    g_controls[id.control].position = mat.v4_xy(bounds)
    g_controls[id.control].size = mat.v4_zw(bounds)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_scale(id control_id, scale v2) {
    uti.assert_(is_valid_control(id), "control_set_scale : invalid id")
    g_controls[id.control].scale = scale
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_add_child(parent control_id, child control_id) {
    uti.assert_(is_valid_control(parent), "control_add_child : invalid parent")
    uti.assert_(is_valid_control(child), "control_add_child : invalid child")
    var count i32 = g_controls[parent.control].childCount
    var size i32 = len(g_controls[parent.control].children)
    uti.assert_(count < size, "control_add_child : overflow") // ##1 use slice
    g_controls[child.control].focusIndex = count
    g_controls[parent.control].children[count] = child
    g_controls[parent.control].childCount = count + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_clear_child(id control_id) {
    uti.assert_(is_valid_control(id), "control_clear_child : invalid id")
    var controlIndex i32 = id.control
    g_controls[controlIndex].childCount = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_padding(id control_id, padding mat.v4) {
    uti.assert_(is_valid_control(id), "control_set_padding : invalid id")
    g_controls[id.control].padding = mat.v4_mul(padding, mat.v4_(1.0, gfx.gfx_ratio_y, 1.0, gfx.gfx_ratio_y)) // ##1 id viewport resize
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_focus_index(id control_id, value i32) {
    uti.assert_(is_valid_control(id), "control_set_focus_index : invalid id")
    g_controls[id.control].focusIndex = value
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_focusable(id control_id, value i32) {
    uti.assert_(is_valid_control(id), "control_set_focusable : invalid id")
    g_controls[id.control].focusable = value
    control_print("SET_FOCUSABLE : ", id, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_pair_s struct {
    key screen_id
    value control_id
    focusList [128]control_id
    focusCount i32
    currentFocus i32
}

var g_focused[64]control_pair_s
var g_focusedCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type focus_s struct {
    focusIndex i32
    control control_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func build_focus_list(focusedScreenIndex i32, parent control_id) {
    uti.assert_(is_valid_control(parent), "build_focus_list : invalid parent")
    control_print("build_focus_list : ", parent, false)
    var index i32 = parent.control

    var unsortedList [64]focus_s
    var unsortedCount i32 = 0

    var i i32 = 0
    var childCount i32 = g_controls[index].childCount
    for i = 0; i < childCount; i = i + 1 {
        var child control_id = g_controls[index].children[i]
        uti.assert_(is_valid_control(child), "build_focus_list : invalid child")
        var childIndex i32 = child.control
        var focusIndex i32 = g_controls[childIndex].focusIndex
        if (focusIndex >= 0) {
            var focusable i32 = g_controls[childIndex].focusable
            if (focusable > 0) {
                control_print("FOCUSABLE : ", child, false)
                unsortedList[unsortedCount].focusIndex = focusIndex
                unsortedList[unsortedCount].control = child
                unsortedCount = unsortedCount + 1
            }
        }
    }

    printf("UNORDERED COUNT %d\n", unsortedCount)
    //sort
    var unsorted i32 = 0
    for unsorted = 0; unsorted < unsortedCount; unsorted = unsorted + 1 {
        var focusCount i32 = g_focused[focusedScreenIndex].focusCount
        var focusIndex i32 = unsortedList[unsorted].focusIndex
        var focusControl control_id = unsortedList[unsorted].control
        printf("UNSORTED INDEX %d, %d, FOCUS_COUNT %d\n", unsorted, focusIndex, focusCount)
        control_print("UNSORTED INDEX : ", focusControl, false)
    }

    printf("SORTING\n")
    //sort
    i = 0
    var backUp i32 = 0
    for (i + 1 < unsortedCount) {
        var nextUnsorted i32 = i + 1
        var currentFocusIndex i32 = unsortedList[i].focusIndex
        var nextFocusIndex i32 = unsortedList[nextUnsorted].focusIndex
        var currentControl control_id = unsortedList[i].control
        var nextControl control_id = unsortedList[nextUnsorted].control
        if (currentFocusIndex > nextFocusIndex) {
            unsortedList[nextUnsorted].control = currentControl
            unsortedList[nextUnsorted].focusIndex = currentFocusIndex
            unsortedList[i].control = nextControl
            unsortedList[i].focusIndex = nextFocusIndex
            i = backUp
        } else {
            backUp = i
            i = i + 1
        }
    }

    var sorted i32 = 0;
    for sorted = 0; sorted < unsortedCount; sorted = sorted + 1 {
        var focusCount i32 = g_focused[focusedScreenIndex].focusCount
        printf("SORTED INDEX %d, %d, FOCUS_COUNT %d\n", sorted, unsortedList[sorted], focusCount)
        g_focused[focusedScreenIndex].focusList[focusCount] = unsortedList[sorted].control
        focusCount = focusCount + 1
        g_focused[focusedScreenIndex].focusCount = focusCount
    }

    for i = 0; i <childCount; i = i + 1 {
        var child control_id = g_controls[index].children[i]
        uti.assert_(is_valid_control(child), "build_focus_list: invalid child")
        var childIndex i32 = child.control
        build_focus_list(focusedScreenIndex, child)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func rebuild_focus(id screen_id) {
    uti.assert_(is_valid_screen(id), "rebuild_focus : invalid id")
    control_print("rebuild_focus : ", id.base, false)
    var i i32 = 0

    var lookup screen_id = invalid_screen()
    var lookupIndex i32 = -1
    for i = 0; i < g_focusedCount; i = i + 1 {
        var key screen_id = g_focused[i].key
        if (key.screen == id.screen) {
            printf("LOOKUP FOUND %d\n", i)
            lookup = key
            lookupIndex = i
            i = g_focusedCount // ##pending issue break
        }
    }

    var oldFocusIndex i32 = -1
    var oldFocusCount i32 = 0
    var oldFocus control_id = invalid_control()
    if (is_valid_screen(lookup)) {
        printf("VALID LOOKUP SCREEN\n")
            oldFocusIndex = g_focused[lookupIndex].currentFocus
            oldFocusCount = g_focused[lookupIndex].focusCount
            oldFocus = invalid_control()
            printf("oldFocusIndex %d, oldFocusCount %d\n", oldFocusIndex, oldFocusCount)
            if (oldFocusIndex >= 0 && oldFocusIndex < oldFocusCount) {
                oldFocus = g_focused[lookupIndex].focusList[oldFocusIndex]
            }
    } else {
        lookup = id
        lookupIndex = g_focusedCount
        g_focused[lookupIndex].key = lookup
        g_focusedCount = g_focusedCount + 1
    }

    printf("lookup %d, %d, id %d, %d\n", lookup.screen, lookup.base.control, id.screen, id.base.control)
    uti.assert_(lookup.base.control == id.base.control, "rebuild_focus : internal error")

    printf("HERE %d\n", lookupIndex)
    g_focused[lookupIndex].currentFocus = -1
    printf("HERE %d\n", lookupIndex)
    g_focused[lookupIndex].focusCount = 0
    printf("---------------------------> BEFORE BUILD_FOCUS_LIST %d, %d\n", lookupIndex, g_focused[lookupIndex].focusCount)
    build_focus_list(lookupIndex, lookup.base)
    printf("---------------------------> AFTER BUILD_FOCUS_LIST %d, %d\n", lookupIndex, g_focused[lookupIndex].focusCount)

    var newFocusIndex i32 = -1
    var newFocus control_id = invalid_control()
    var newFocusCount i32 = g_focused[lookupIndex].focusCount
    if (is_valid_control(oldFocus)) {
        newFocusIndex = oldFocusIndex
        newFocus = oldFocus
        printf("RESTORING OLD FOCUS %d\n", oldFocusIndex)
        control_print("RESTORING OLD FOCUS : ", newFocus, false)
    } else if (newFocusCount > 0) {
        newFocusIndex = 0
        newFocus = g_focused[lookupIndex].focusList[0]
        printf("NEW FOCUS %d\n", newFocusIndex)
        control_print("NEW FOCUS : ", newFocus, false)
    }

    set_current_focus(lookup, lookupIndex, newFocus, newFocusIndex)
    var focus i32 = 0
    var focusCount i32 = g_focused[lookupIndex].focusCount
    control_print("---- rebuild_focus : ", id.base, false)
    for focus = 0; focus < focusCount; focus = focus + 1 {
        var focused control_id = g_focused[lookupIndex].focusList[focus]
        control_print("-------- rebuild_focus : ", focused, false)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func set_current_focus(key screen_id, screenIndex i32, value control_id, controlIndex i32) {
    uti.assert_(is_valid_screen(key), "set_current_focus : invalid key")
    control_print("set_current_focus : ", key.base, false)

    var currentFocus i32 = g_focused[screenIndex].currentFocus
    var focusCount i32 = g_focused[screenIndex].focusCount
    if (currentFocus >= 0 && currentFocus < focusCount) {
        var focusId control_id = g_focused[screenIndex].focusList[currentFocus]
        uti.assert_(is_valid_control(focusId), "set_current_focus : invalid current id")
        g_controls[focusId].focused = 0
    }

    if (is_valid_control(value)) {
        control_print("set_current_focus : ", value, false)
        g_focused[screenIndex].key = key
        g_focused[screenIndex].value = value
        g_focused[screenIndex].currentFocus = controlIndex
        g_controls[value.control].focused = 1
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func get_focus_pair(id screen_id) (out i32) {
    out = -1
    uti.assert_(is_valid_screen(id), "get_focus_pair: invalid id")
    control_print("get_focus_pair : ", id.base, false)
    var i i32 = 0
    for i = 0; i < g_focusedCount; i = i + 1 {
        var key screen_id = g_focused[i].key
        if (key.screen == id.screen) {
            out = i
            i = g_focusedCount // ##pending issue break
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func set_next_focus(id screen_id) {
    uti.assert_(is_valid_screen(id), "screen_next_focus : invalid id")
    control_print("set_next_focus : ", id.base, false)
    var pair i32 = get_focus_pair(id)
    if (pair >= 0 && pair < g_focusedCount) {
        var current i32 = g_focused[pair].currentFocus
        var count i32 = g_focused[pair].focusCount
        var next i32 = -1
        if (count > 0) {
            next = (current + 1) % count
            //printf("NEXT_FOCUS %d/%d\n", next, count)
        }
        var nextId control_id = g_focused[pair].focusList[next]
        set_current_focus(id,  pair, nextId, next)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func set_previous_focus(id screen_id) {
    uti.assert_(is_valid_screen(id), "screen_previous_focus : invalid id")
    control_print("set_previous_focus : ", id.base, false)
    var pair i32 = get_focus_pair(id)
    if (pair >= 0 && pair < g_focusedCount) {
        var current i32 = g_focused[pair].currentFocus
        var count i32 = g_focused[pair].focusCount
        var previous i32 = -1
        if (count > 0) {
            previous = current - 1
            if (previous < 0) {
                previous = count - 1
                //printf("PREVIOUS_FOCUS %d/%d\n", previous, count)
            }
        }

        var previousId control_id = g_focused[pair].focusList[previous]
        set_current_focus(id, pair, previousId, previous)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*func control_activate(id control_id) {
    uti.assert_(is_valid_control(id), "control_activate : invalid id")
    control_print("control_activate : ", id, false)

    var index i32 = id.control
    var guiType i32 = g_controls[index].gui_type
    if (guiType == GUI_WINDOW) {
        var guiIndex i32 = g_controls[index].gui_index
        control_print("window found : ", id, false)
        var windowId window_id = window_id_(control_id_(index), guiIndex)
        uti.assert_(is_valid_window(windowId), "control_activate : invalid window id")
        rebuild_focus(windowId)
    } else {
        var focusIndex i32 = g_controls[index].focusIndex
        if (focusIndex >= 0) {
            var i i32 = 0
            var count i32 = g_controls[index].childCount
            for i = 0; i < count; i = i + 1 {
                control_activate(g_controls[index].children[i])
            }
        }
    }
}*/

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func get_current_focus(id control_id) (out control_id) {
    /*out = invalid_control()

    var i i32 = 0
    for i = 0; i < g_focusedCount; i = i + 1 {
        if (g_focused[i].key.control == id.control) {
            var currrentFocus i32 = g_focused[i].currentFocus
            out = g_focused[i].focusedList[currentFocus]
        }
    }*/





    /*uti.assert_(is_valid_control(id), "control_focus : invalid id")
    control_print("control_focus : ", id, false)

    var index i32 = id.control
    var focusIndex i32 = g_controls[index].focusIndex

    if (focusIndex >= 0) {
        //control_print("IS_FOCUSABLE ? ", id, false)
        var focusable i32 = g_controls[index].focusable
        if (focusable > 0) {
            //control_print("YES_FOCUSABLE ? ", id, false)
            out = id
            //control_print("control_0 : ", out, false)
        } else {
            //out = invalid_control()
            //control_print("NO_FOCUSABLE ! ", out, false)
            //printf("out %d\n", out.control)
            //var toto control_id
            //toto = invalid_control()
            //control_print("FUCK ", toto, false)
            var i i32 = 0
            var count i32 = g_controls[index].childCount
            for i = 0; i < count; i = i + 1 {
                //printf("i %d/%d\n", i + 1, count)
                var child control_id = g_controls[index].children[i]
                //control_print("child : ", child, false)
                var focused control_id = control_focus(child)
                if (is_valid_control(focused)) {
                    i = count
                    out = focused
                    //control_print("control_8 : ", out, false)
                }
            }
        }
    }*/
    //out = invalid_control()
    //control_print("control_9 : ", out, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_resize(id control_id) () {
    uti.assert_(is_valid_control(id), "control_resize : invalid id")
    var bounds mat.v2 = g_controls[id.control].size
    var pixelBounds mat.v2 = mat.v2_mul(bounds, gfx.gfx_viewport)
    control_resize_(id, pixelBounds, bounds, mat.v2_zero)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_resize_(id control_id, pixelBounds mat.v2, bounds mat.v2, autoBounds mat.v2) () {
    uti.assert_(is_valid_control(id), "control_resize : invalid id")
    //control_print("begin_control_resize : ", id, false)
    //printf("pixelBounds %f, %f, bounds %f, %f, autoBounds %f, %f\n", pixelBounds.x, pixelBounds.y, bounds.x, bounds.y, autoBounds.x, autoBounds.y)

    var index i32 = id.control

    var dock i32 = g_controls[index].dock
    var autoscale i32 = g_controls[index].autoscale
    var scale mat.v2 = g_controls[index].scale
    var autosize i32 = g_controls[index].autosize

    var padding mat.v4 = g_controls[index].padding
    var newWidth f32 = g_controls[index].size.x
    var newHeight f32 = g_controls[index].size.y

    var paddingLeft f32 = padding.x
    var paddingBottom f32 = padding.y
    var paddingRight f32 = padding.z
    var paddingTop f32 = padding.w
    var paddingX f32 = paddingLeft + paddingRight
    var paddingY f32 = paddingBottom + paddingTop
    var maxWidth f32 = 0.0
    var maxHeight f32 = 0.0

    /*if (autosize == AUTOSIZE) {
        control_print("AUTOSIZE : ", id, false)
    }*/


    var minX f32 = mat.FLOAT_MAX
    var minY f32 = mat.FLOAT_MAX

    var maxX f32 = mat.FLOAT_MIN
    var maxY f32 = mat.FLOAT_MIN

    var count i32 = g_controls[index].childCount
    for i := 0; i < count; i = i + 1 {
        var child control_id = g_controls[index].children[i]
        uti.assert_(is_valid_control(child), "control_resize : invalid child control")
        var guiType i32 = g_controls[child.control].gui_type
        var guiIndex i32 = g_controls[child.control].gui_index

        if (guiType == GUI_INVALID) {
           uti.assert_(false, "invalid gui type (GUI_INVALID)")
        } else if (guiType == GUI_CONTROL) {
            uti.assert_(guiIndex == child.control, "unexpected error")
            control_resize(control_id_(guiIndex))
        } else if (guiType == GUI_SCREEN) {
            uti.assert_(false, "unidd recursive screen")
        } else if (guiType == GUI_PICTURE) {
            picture_resize(picture_id_(child, guiIndex))
        } else if (guiType == GUI_LABEL) {
            label_resize(label_id_(child, guiIndex))
        } else if (guiType == GUI_PARTITION) {
            partition_resize(partition_id_(child, guiIndex))
        } else if (guiType == GUI_KEYBOARD) {
            keyboard_resize(keyboard_id_(child, guiIndex))
        } else if (guiType == GUI_WINDOW) {
            window_resize(window_id_(child, guiIndex))
        } else if (guiType == GUI_GRAPH) {
            graph_resize(graph_id_(child, guiIndex))
        } else {
            printf("GUI TYPE %d\n", guiType)
            uti.assert_(false, "control_resize : unknown gui type")
        }

        var position mat.v2 = g_controls[child.control].renderPosition
        var size mat.v2 = g_controls[child.control].size

        maxWidth = mat.max(maxWidth, size.x)
        maxHeight = mat.max(maxHeight, size.y)

        minX = mat.min(minX, position.x)
        minY = mat.min(minY, position.y)
        maxX = mat.max(maxX, position.x + size.x)
        maxY = mat.max(maxY, position.y + size.y)

        //printf("%s, %d/%d : MAXWIDTH %f, MAXHEIGHT %f\n", g_controls[id.control].name, i + 1, count, maxWidth, maxHeight)
    }


    maxWidth = maxX - minX
    maxHeight = maxY - minY

    if (autosize == AUTOSIZE || autosize == AUTOSIZE_X || autosize == AUTOSIZE_Y) {
        if ((autosize & AUTOSIZE_X) == AUTOSIZE_X) {
            //uti.assert_(dock == DOCK_NONE || dock == DOCK_LEFT || dock == DOCK_RIGHT, "AUTOSIZE_X is not compatible with DOCK_Y")
            uti.assert_((autoscale & AUTOSCALE_X) == 0, "AUTOSIZE_X is not compatible with AUTOSCALE_X")
            //printf("NEW_WIDTH %f, AUTO_BOUNDS_X %f\n", maxWidth, autoBounds.x)
            newWidth = mat.max(maxWidth + paddingX, autoBounds.x)// - paddingX
        }
        if ((autosize & AUTOSIZE_Y) == AUTOSIZE_Y) {
            //uti.assert_(dock == DOCK_NONE || dock == DOCK_BOTTOM || dock == DOCK_TOP, "AUTOSIZE_Y is not compatible with DOCK_X")
            uti.assert_((autoscale & AUTOSCALE_Y) == 0, "AUTOSIZE_Y is not compatible with AUTOSCALE_Y")
            newHeight = mat.max(maxHeight +  paddingY, autoBounds.y)// - paddingY
            //printf("NEW_HEIGHT %f, AUTO_BOUNDS_Y %f\n", maxHeight, autoBounds.y)
        }

        g_controls[index].size = mat.v2_(newWidth, newHeight)
        //control_print("NEW_SIZE : ", id, false)
    } else {
        uti.assert_(autosize == AUTOSIZE_NONE, "invalid AUTOSIZE value")
    }

    if (autoscale == AUTOSCALE || autoscale == AUTOSCALE_X || autoscale == AUTOSCALE_Y) {
        if (autoBounds.x > 0 && autoBounds.y > 0) {
            //control_print("AUTOSCALE : ", id, false)
            //printf("scale %f, %f, newWidth %f, newHeight %f, autoBounds %f, %f\n", scale.x, scale.y, newWidth, newHeight, autoBounds.x, autoBounds.y)
            var scaleW f32 = scale.x
            var scaleH f32 = scale.y
            if ((autoscale & AUTOSCALE_X) == AUTOSCALE_X) {
                uti.assert_((autosize & AUTOSIZE_X) == 0, "AUTOSCALE_X is not compatible with AUTOSIZE_X")
                scaleW = newWidth / autoBounds.x
            }
            if ((autoscale & AUTOSCALE_Y) == AUTOSCALE_Y) {
                uti.assert_((autosize & AUTOSIZE_Y) == 0, "AUTOSCALE_Y is not compatible with AUTOSCALE_Y")
                scaleH = newHeight / autoBounds.y
            }

            if (autoscale == AUTOSCALE) {
                if (scaleW < scaleH) {
                    scaleH = scaleW
                    var newScale mat.v2 = mat.v2_(scaleW, scaleH/* / gfx.gfx_ratio_y*/)
                    g_controls[index].scale = newScale
                    //control_print("after_pop", id, false)

                } else {
                    scaleW = scaleH
                    var newScale mat.v2 = mat.v2_(scaleW/* * gfx.gfx_ratio_x*/, scaleH)
                    g_controls[index].scale = newScale
                }
            } else {
                var newScale mat.v2 = mat.v2_(scaleW, scaleH)
                g_controls[index].scale = newScale
            }
        }
    } else {
        uti.assert_(autoscale == AUTOSCALE_NONE, "invalid AUTOSCALE value")
    }

    //control_print("end_control_resize", id, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func align_control(align i32, posx f32, posy f32, width f32, height f32, contX f32, contY f32, contW f32, contH f32, padding mat.v4) (x f32, y f32) {
    x = posx
    y = posy

    if (align == ALIGN_CENTER) {
        x = contX + (contW - width) / 2.0
        y = contY + (contH - height) / 2.0
        //printf("posx %f, posy %f, width %f, height %f, X %f, Y %f\n", posx, posy, width, height, x, y)
    } else if (align == ALIGN_HORZ_BOTTOM) {
        x = contX + (contW - width) / 2.0
        y = contY + padding.y
        //control_print(index, "ALIGN_HORZ_BOTTOM : ")
    } else if (align == ALIGN_HORZ_TOP) {
        uti.assert_(false, "ALIGN_HORZ_TOP not implemented")
    } else if (align == ALIGN_VERT_LEFT) {
        uti.assert_(false, "ALIGN_VERT_LEFT not implemented")
    } else if (align == ALIGN_VERT_RIGHT) {
        uti.assert_(false, "ALIGN_VERT_RIGHT not implemented")
    } else if (align == ALIGN_LEFT_BOTTOM) {
        uti.assert_(false, "ALIGN_LEFT_BOTTOM not implemented")
    } else if (align == ALIGN_RIGHT_BOTTOM) {
        uti.assert_(false, "ALIGN_RIGHT_BOTTOM not implemented")
    } else if (align == ALIGN_HORZ) {
        uti.assert_(false, "ALIGN_HORZ not implemented")
    } else if (align == ALIGN_VERT) {
        uti.assert_(false, "ALIGN_VERT not implemented")
    } else if (align == ALIGN_LEFT_TOP) {
        uti.assert_(false, "ALIGN_LEFT_TOP not implemented")
    } else if (align == ALIGN_RIGHT_TOP) {
        uti.assert_(false, "ALIGN_RIGHT_TOP not implemented")
    } else if (align == ALIGN_LEFT) {
         uti.assert_(false, "ALIGN_LEFT not implemented")
    } else if (align == ALIGN_RIGHT) {
        uti.assert_(false, "ALIGN_RIGHT not implemented")
    } else if (align == ALIGN_BOTTOM) {
        uti.assert_(false, "ALIGN_BOTTOM not implemented")
    } else if (align == ALIGN_TOP) {
        uti.assert_(false, "ALIGN_TOP not implemented")
    } else if (align != ALIGN_NONE) {
        //x = bounds.x
        //y = bounds.y
        //w = bounds.z
        //h = bounds.w
    //} else {
        uti.assert_(false, "invalid align property")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_redock(id control_id, padding mat.v4) () {
    uti.assert_(is_valid_control(id), "control_redock : invalid id")
    //control_print("begin_control_redock : ", id, false)

    var index i32 = id.control
    var w f32 = 0.0
    var h f32 = 0.0
    var x f32 = 0.0
    var y f32 = 0.0

    var dock i32 = g_controls[index].dock
    var align i32 = g_controls[index].align
    var autosize i32 = g_controls[index].autosize
    var autoscale i32 = g_controls[index].autoscale
    var size mat.v2 = g_controls[index].size
    var position mat.v2 = g_controls[index].position
    var parentPadding mat.v4 = g_controls[index].padding

    var paddingLeft f32 = padding.x
    var paddingBottom f32 = padding.y
    var paddingRight f32 = padding.z
    var paddingTop f32 = padding.w

    var paddingX f32 = paddingLeft + paddingRight
    var paddingY f32 = paddingBottom + paddingTop

    /*if (dock != DOCK_NONE) {
        uti.assert_(align == ALIGN_NONE, "control_redock : incompatible align & dock options")
    }*/

    if (dock == DOCK_FILL) {
        x = g_dock.left + paddingLeft
        w = g_dock.right - g_dock.left - paddingX
        h = g_dock.top - g_dock.bottom - paddingY
        y = g_dock.bottom + paddingBottom
        //uti.assert_(autosize == AUTOSIZE_NONE, "control_redock : DOCK_FILL is not compatible with AUTOSIZE")
        //control_print("DOCK_FILL : ", id, false)
    } else if (dock == DOCK_LEFT) {
        x = g_dock.left + paddingLeft
        w = size.x
        h = g_dock.top - g_dock.bottom - paddingY
        y = g_dock.top - h - paddingTop
        g_dock.left = x + w
        //uti.assert_((autosize & AUTOSIZE_Y) == 0, "control_redock : DOCK_LEFT is not compatible with AUTOSIZE_Y")
    } else if (dock == DOCK_RIGHT) {
        w = size.x
        x = g_dock.right - w - paddingLeft
        h = g_dock.top - g_dock.bottom - paddingY
        y = g_dock.top - h - paddingTop
        g_dock.right = x
        //uti.assert_((autosize & AUTOSIZE_Y) == 0, "control_redock : DOCK_RIGHT is not compatible with AUTOSIZE_Y")
    } else if (dock == DOCK_TOP) {
        x = g_dock.left + paddingLeft
        w = g_dock.right - g_dock.left - paddingX
        h = size.y
        y = g_dock.top - h - paddingTop
        g_dock.top = y
        //uti.assert_((autosize & AUTOSIZE_X) == 0, "control_redock : DOCK_TOP is not compatible with AUTOSIZE_X")
        //control_print("DOCK_TOP : ", id, false)
        //printf("DOCK_TOP %f, %f, %f\n", g_dock.top, y, h)
    } else if (dock == DOCK_BOTTOM) {
        x = g_dock.left + paddingLeft
        w = g_dock.right - g_dock.left - paddingX
        h = size.y
        y = g_dock.bottom + paddingBottom// + h
        g_dock.bottom = y + h
        //uti.assert_((autosize & AUTOSIZE_X) == 0, "control_redock : DOCK_BOTTOM is not compatible with AUTOSIZE_X")
        //control_print("DOCK_BOTTOM : ", id, false)
    } else if (dock == DOCK_NONE) {
        x = position.x
        y = position.y
        w = size.x
        h = size.y
    } else {
        uti.assert_(false, "invalid dock value")
    }

    var contX f32 = g_dock.left
    var contY f32 = g_dock.bottom
    var contW f32 = g_offset.width//g_dock.right - g_dock.left//g_offset.width
    var contH f32 = g_offset.height//g_dock.top - g_dock.bottom//g_offset.height

    //control_print("befor align : ", id, false)
    x, y = align_control(align, x, y, size.x, size.y, contX, contY, contW, contH, padding)
    //control_print("after align : ", id, false)
    push_scope()

    g_offset.x = g_offset.x + x
    g_offset.y = g_offset.y + y
    g_offset.width = w
    g_offset.height = h

    g_dock.left = 0.0
    g_dock.bottom = 0.0
    g_dock.right = w
    g_dock.top = h

    //control_print(index, "child")
    var count i32 = g_controls[index].childCount
    for i := 0; i < count; i = i + 1 {
        var child control_id = g_controls[index].children[i]
        uti.assert_(is_valid_control(child), "control_redock : invalid child control")

        ///printf("REDOCK_CHILD %d/%d\n", i + 1, count)
        var childControl i32 = child.control
        var guiType i32 = g_controls[childControl].gui_type
        var guiIndex i32 = g_controls[childControl].gui_index

        if (guiType == GUI_INVALID) {
            uti.assert_(false, "invalid gui type (GUI_INVALID)")
        } else if (guiType == GUI_CONTROL) {
            uti.assert_(guiIndex == childControl, "unexpected error")
            control_redock(control_id_(childControl), parentPadding)
        } else if (guiType == GUI_SCREEN) {
            uti.assert_(false, "unidd recursive screen")
        } else if (guiType == GUI_PICTURE) {
            //redock_picture(picture_id_(child, guiIndex))
            control_redock(control_id_(childControl), parentPadding)
        } else if (guiType == GUI_LABEL) {
            //redock_label(label_id_(child, guiIndex))
            control_redock(control_id_(childControl), parentPadding)
        } else if (guiType == GUI_PARTITION) {
            //redock_partition(partition_id_(child, guiIndex))
            control_redock(control_id_(childControl), parentPadding)
        } else if (guiType == GUI_KEYBOARD) {
            //redock_keyboard(keyboard_id_(child, guiIndex))
            control_redock(control_id_(childControl), parentPadding)
        } else if (guiType == GUI_WINDOW) {
            //redock_window(window_id_(child, guiIndex))
            control_redock(control_id_(childControl), parentPadding)
        } else if (guiType == GUI_GRAPH) {
            control_redock(control_id_(childControl), parentPadding)
        } else {
            control_print("control_redock parent : ", id, false)
            control_print("control_redock child : ", child, false)
            uti.assert_(false, "control_redock : unknown gui type")
        }
    }

    g_controls[index].renderPosition = mat.v2_(g_offset.x, g_offset.y)
    //g_controls[index].renderSize = mat.v2_(g_offset.width, g_offset.height)
    var newWidth f32 = g_offset.width
    var newHeight f32 = g_offset.height

    if ((autosize & AUTOSIZE_X) == AUTOSIZE_X) {
        uti.assert_((autoscale & AUTOSCALE_X) == 0, "AUTOSIZE_X is not compatible with AUTOSCALE_X")
        //uti.assert_(dock == DOCK_NONE || dock == DOCK_LEFT || dock == DOCK_RIGHT, "AUTOSIZE_X is not compatible with DOCK_Y")
        newWidth = g_controls[index].size.x
        //newWidth = newWidth - paddingX // ##pending_7
        //printf("AUTOSIZE NEW WIDTH %f, %f, %f\n", newWidth, g_controls[index].size.x, paddingX)
    }
    if ((autosize & AUTOSIZE_Y) == AUTOSIZE_Y) {
        uti.assert_((autoscale & AUTOSCALE_Y) == 0, "AUTOSIZE_Y is not compatible with AUTOSCALE_Y")
        //uti.assert_(dock == DOCK_NONE || dock == DOCK_TOP || dock == DOCK_BOTTOM, "AUTOSIZE_Y is not compatible with DOCK_X")
        newHeight = g_controls[index].size.y
        //newHeight = newHeight - paddingY // ##pending_7
        //printf("AUTOSIZE NEW HEIGHT %f, %f, %f\n", newHeight, g_controls[index].size.y, paddingY)
    }
    g_controls[index].size = mat.v2_(newWidth, newHeight)

    //control_print("end_control_redock", id, false)
    pop_scope()
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_surface(id mesh_id, bounds mat.v4, color mat.v4) () {
    if (color.w > 0) {
        gfx.append_quad(id, bounds, mat.v4_(0.0, 0.0, 1.0, 1.0), color)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_border(id mesh_id, bounds mat.v4, left mat.v4, bottom mat.v4, right mat.v4, top mat.v4) () {
    var x0 f32 = bounds.x
    var y0 f32 = bounds.y
    var x1 f32 = x0 + bounds.z
    var y1 f32 = y0 + bounds.w

    if (left.w > 0) {
        gfx.append_line(id, mat.v4_(x0, y0, x0, y1), left)
    }

    if (bottom.w > 0) {
        gfx.append_line(id, mat.v4_(x0, y0, x1, y0), bottom)
    }

    if (right.w > 0) {
        gfx.append_line(id, mat.v4_(x1, y0, x1, y1), right)
    }

    if (top.w > 0) {
        gfx.append_line(id, mat.v4_(x0, y1, x1, y1), top)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_render(id control_id) () {
    //control_print("before control_render : ", id, false)
    uti.assert_(is_valid_control(id), "control_render : invalid control index")

    var index i32 = id.control
    //var renderBounds mat.v4 = mat.v4_v2v2(g_controls[index].renderPosition, g_controls[index].renderSize)
    var renderBounds mat.v4 = mat.v4_v2v2(g_controls[index].renderPosition, g_controls[index].size)
    var controlSkin control_skin_id = g_controls[index].skin
    uti.assert_(is_valid_control_skin(controlSkin) || controlSkin.skin == -1, "control_render : invalid control skin")
    if is_valid_control_skin(controlSkin) {
        var backLayerSkin layer_skin_id = g_controlSkins[controlSkin.skin].back
        var focused i32 = g_controls[index].focused
        if (focused > 0) {
            var backFocusedLayerSkin layer_skin_id = g_controlSkins[controlSkin.skin].focused_back
            if (is_valid_layer_skin(backFocusedLayerSkin)) {
                backLayerSkin = backFocusedLayerSkin
            }
        }
        uti.assert_(is_valid_layer_skin(backLayerSkin) || backLayerSkin.layer == -1, "control_render : invalid layer skin")
        if is_valid_layer_skin(backLayerSkin) {
            render_surface(g_opaqueVertexColoredTriangles, renderBounds, g_layerSkins[backLayerSkin.layer].surface)
            render_border(g_opaqueVertexColoredLines, renderBounds,
                g_layerSkins[backLayerSkin.layer].left,
                g_layerSkins[backLayerSkin.layer].right,
                g_layerSkins[backLayerSkin.layer].bottom,
                g_layerSkins[backLayerSkin.layer].top)
        }
        var frontLayerSkin layer_skin_id = g_controlSkins[controlSkin.skin].front
        uti.assert_(is_valid_layer_skin(frontLayerSkin) || frontLayerSkin.layer == -1, "control_render : invalid layer skin")
        if (is_valid_layer_skin(frontLayerSkin)) {
            render_surface(g_alphaVertexColoredTriangles,renderBounds, g_layerSkins[frontLayerSkin.layer].surface)
            //gfx.append_rect(g_alphaVertexColoredLines, g_controls[index].renderBounds,
              //  g_layerSkins[backLayerSkin].left,
               // g_layerSkins[backLayerSkin].right,
                //g_layerSkins[backLayerSkin].bottom,
                ///g_layerSkins[backLayerSkin].top)
        }
    }

    var count i32 = g_controls[index].childCount
    for i := 0; i < count; i = i + 1 {
        var child control_id = g_controls[index].children[i]
        uti.assert_(is_valid_control(child), "control_render : invalid child control")
        var guiType i32 = g_controls[child].gui_type
        var guiIndex i32 = g_controls[child].gui_index

        if (guiType == GUI_INVALID) {
            uti.assert_(false, "invalid gui type (GUI_INVALID)")
        } else if (guiType == GUI_CONTROL) {
            //control_print(guiIndex, "control_render_child GUI_CONTROL : ")
            uti.assert_(child.control == guiIndex, "unexpected error")
            control_render(child)
        } else if (guiType == GUI_SCREEN) {
            uti.assert_(false, "unidd recursive screen")
        } else if (guiType == GUI_PICTURE) {
            picture_render(picture_id_(child, guiIndex))
        } else if (guiType == GUI_LABEL) {
            label_render(label_id_(child, guiIndex))
        } else if (guiType == GUI_PARTITION) {
            partition_render(partition_id_(child, guiIndex))
        } else if (guiType == GUI_KEYBOARD) {
            keyboard_render(keyboard_id_(child, guiIndex))
        } else if (guiType == GUI_WINDOW) {
            window_render(window_id_(child, guiIndex))
        } else if (guiType == GUI_GRAPH) {
            graph_render(graph_id_(child, guiIndex))
        } else {
            printf("GUI TYPE %d\n", guiType)
            uti.assert_(false, "control_render : unknown gui type")
        }
    }
    //control_print("after control_render : ", id, false)
}

//-----------------------------------------------------------------------------
// SCREEN
//-----------------------------------------------------------------------------
var g_screens [64]screen_s
var g_screenCount i32

var g_modals [64]screen_id
var g_modalCount i32 = 0

var g_currentScreen screen_id = invalid_screen()
var g_nextScreen    screen_id = invalid_screen()

var g_transitionDuration f64 = 0.5D
var g_transitionTime     f64 = 0.0D

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type screen_id struct {
    base control_id
    screen i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type screen_s struct {
    id    screen_id
    on_exit   screen_id
    on_enter  screen_id
    on_menu   screen_id
    on_next   screen_id
    duration  f64
    time      f64
    state     i32
    prevState i32
    modal     bool
    paused    bool
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_id_(base control_id, screen i32) (out screen_id) {
    out.base = base
    out.screen = screen
    uti.assert_(is_valid_screen(out), "screen_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_screen(name str) (out screen_id) {
    uti.assert_(g_screenCount < len(g_screens), "create_screen : overflow") // ##1 use slice
    out.screen = g_screenCount
    out.base = create_control_(name, GUI_SCREEN, out.screen)

    control_set_focus_index(out.base, 0)

    var screen screen_s
    screen.id = out
    screen.on_exit   = invalid_screen()
    screen.on_enter  = invalid_screen()
    screen.on_menu   = invalid_screen()
    screen.on_next   = invalid_screen()
    screen.duration  = -1.0D
    screen.time      = 0.0D
    screen.state     = STATE_CLOSED
    screen.prevState = STATE_CLOSED
    screen.modal     = false
    screen.paused    = false

    g_screens[out.screen] = screen
    g_screenCount = out.screen + 1
    uti.assert_(is_valid_screen(out), "create_screen : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//func invalid_screen() { // ##pending issue
func invalid_screen() (out screen_id) {
    out.base = invalid_control()
    out.screen = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_screen(id screen_id) (out bool) {
    out = id.screen >= 0 && id.screen < g_screenCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func sceen_set_modal(id screen_id, modal bool) () {
    uti.assert_(is_valid_screen(id), "screen_set_modal : invalid id")
    g_screens[id.screen].modal = true
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_exit(id screen_id, exit screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_exit : invalid id")
    uti.assert_(is_valid_screen(exit)  , "screen_on_exit : invalid id")
    g_screens[id.screen].on_exit = exit
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_menu(id screen_id, menu screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_menu : invalid id")
    uti.assert_(is_valid_screen(menu)  , "screen_on_menu : invalid id")
    g_screens[id.screen].on_menu = menu
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_enter(id screen_id, enter screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_enter : invalid id")
    uti.assert_(is_valid_screen(enter) , "screen_on_enter : invalid id")
    g_screens[id.screen].on_enter = enter
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_next(id screen_id, next screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_next : invalid id 0")
    uti.assert_(is_valid_screen(next)  , "screen_on_next : invalid id 1")
    g_screens[id.screen].on_next = next
}

//-----------------------------------------------------------------------------
func screen_set_on_event(id screen_id, event screen_id) () {
    screen_set_on_exit(id, event)
    screen_set_on_enter(id, event)
    screen_set_on_menu(id, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_duration(id screen_id, duration f64) {
    uti.assert_(is_valid_screen(id), "screen_set_duration : invalid id")
    g_screens[id.screen].duration = duration
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_modal(id screen_id, modal bool) {
    uti.assert_(is_valid_screen(id), "screen_set_modal : invalid id")
    g_screens[id.screen].modal = modal
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_process_event(id screen_id, event *event_s) (out i32) {
    uti.assert_(is_valid_screen(id), "screen_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func change_screen_state(id screen_id, state i32) () {
    uti.assert_(is_valid_screen(id), "change_screen_state : invalid id")
    g_screens[id.screen].prevState = g_screens[id.screen].state
    printf("CHANGE %d\n", state)
    g_screens[id.screen].state = state
    var prev i32 = g_screens[id.screen].prevState
    var curr i32 = g_screens[id.screen].state
    if (prev != curr) {
        printf("%d screen state changed %d -> %d\n", id.screen, prev, curr)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_state_changed(id screen_id, prev i32, curr i32) (value bool) {
    uti.assert_(is_valid_screen(id), "screen_state_chaned : invalid id")
    var screenPrev i32 = g_screens[id.screen].prevState
    var screenCurr i32 = g_screens[id.screen].state
    value = ((screenPrev == prev) && (screenCurr == curr))
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func update_screen(id screen_id, deltaTime f64) () {
    uti.assert_(is_valid_screen(id), "update_screen : invalid id")
    var t f64 = g_screens[id.screen].time
    var d f64 = g_screens[id.screen].duration

    g_screens[id.screen].time = t
    var state i32 = g_screens[id.screen].state
    if ((t <= 0) && (state == STATE_CLOSED)) {
        printf("CHANGE SHOWING\n")
        change_screen_state(id, STATE_SHOWING)
    } else if ((t >= d) && (d > 0) && (state == STATE_OPENED)) { // can't use g_screens[screen].state here
        printf("CHANGE CLOSING %d\n", g_screens[id.screen].state)
        change_screen_state(id, STATE_CLOSING)
    }

    t = t + deltaTime
    g_screens[id.screen].time = t
//    printf("time %f", f64.f32(t))
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_resize(id screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_resize : invalid id")
    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func clear_batches() {
    g_renderBatchCount = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func begin_batches() {
    var i i32 = 0;
    //printf("BEGIN_BATCHES %d\n", g_renderBatchCount)
    for i = 0; i < g_renderBatchCount; i = i + 1 {
        //printf("BEGIN_BATCH %d/%d\n", i, g_renderBatchCount)
        var batchId batch_id = g_renderBatches[i]
        uti.assert_(is_valid_batch(batchId), "begin_batch : invaid batch")
        var meshId gfx.mesh_id = g_batches[batchId.batch].mesh
        uti.assert_(gfx.is_valid_mesh(meshId), "begin_batches : invalid mesh")
        gfx.begin_mesh(meshId)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func end_batches() {
    var i i32 = 0;
    for i = 0; i < g_renderBatchCount; i = i + 1 {
        var batchId batch_id = g_renderBatches[i]
        uti.assert_(is_valid_batch(batchId), "end_batch : invalid batch")
        var meshId gfx.mesh_id = g_batches[batchId.batch].mesh
        uti.assert_(gfx.is_valid_mesh(meshId), "end_batches : invalid mesh")
        gfx.end_mesh(meshId)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_batches(alpha bool) {
    var i i32 = 0
    for i = 0; i < g_renderBatchCount; i = i + 1 {
        var batchId batch_id = g_renderBatches[i]
        uti.assert_(is_valid_batch(batchId), "render_batches : invalid batch")
        var batch i32 = batchId.batch
        var meshId gfx.mesh_id = g_batches[batch].mesh
        uti.assert_(gfx.is_valid_mesh(meshId), "render_batches : invalid mesh")
        if (gfx.mesh_is_empty(meshId) == false) {
            var batchAlpha bool = g_batches[batch].alpha
            if (batchAlpha == alpha) {
               if (alpha == true) {
                    gfx.enable_blending(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
                } else {
                   gfx.disable_blending()
                }
                gfx.effect_use(gfx.g_fxTexture)
                gfx.effect_assign_texture(gfx.g_fxTexture, 0, g_batches[batch].texture.name)
                gfx.render_mesh(meshId)
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_render(id screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_render : invalid screen")
    gfx.begin_mesh(g_opaqueVertexColoredTriangles)
    gfx.begin_mesh(g_opaqueVertexColoredLines)
    gfx.begin_mesh(g_alphaVertexColoredTriangles)
    begin_batches()

    control_render(id.base)

    end_batches()
    gfx.end_mesh(g_alphaVertexColoredTriangles)
    gfx.end_mesh(g_opaqueVertexColoredLines)
    gfx.end_mesh(g_opaqueVertexColoredTriangles)

    // opaque
    if gfx.mesh_is_empty(g_opaqueVertexColoredTriangles) == false {
        gfx.disable_blending()
        gfx.effect_use(gfx.g_fxVertexColor)
        gfx.render_mesh(g_opaqueVertexColoredTriangles)
    }

    render_batches(false)

    if gfx.mesh_is_empty(g_opaqueVertexColoredLines) == false {
        gfx.disable_blending()
        gfx.effect_use(gfx.g_fxVertexColor)
        gfx.render_mesh(g_opaqueVertexColoredLines)
    }

    // alpha
    if gfx.mesh_is_empty(g_alphaVertexColoredTriangles) == false {
        gfx.enable_blending(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
        gfx.effect_use(gfx.g_fxVertexColor)
        gfx.render_mesh(g_alphaVertexColoredTriangles)
    }

    render_batches(true)
}

//-----------------------------------------------------------------------------
// LABEL
//-----------------------------------------------------------------------------
var g_labels [256]label_s
var g_labelCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type label_id struct {
    base control_id
    label i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type func_i32_i32_id struct {
    index i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func func_i32_i32(packageName str, functionName str) (out func_i32_i32_id) {
    printf("toto\n")
    out.index = glfw.func_i32_i32(packageName, functionName)
    printf("tata\n")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_func_i32_i32() (out func_i32_i32_id) {
    out.index = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func call_i32_i32(function func_i32_i32_id, a i32, b i32) {
    printf("begin_call_i32_i32 %d, %d, %d\n", function.index, a, b)
    glfw.call_i32_i32(function.index, a, b)
    printf("end_call_i32_i32\n")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type label_s struct {
    id label_id
    font font_id
    batch batch_id
    text str
    textSize i32
    textAlign i32
    textPosition mat.v2
    color_0 mat.v4
    color_1 mat.v4
    on_state func_i32_i32_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_id_(base control_id, label i32) (out label_id) {
    out.base = base
    out.label = label
    uti.assert_(is_valid_label(out), "label_id_ : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_label(id label_id) (out bool) {
    out = id.label >= 0 && id.label < g_labelCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_label(name str) (out label_id) {
    uti.assert_(g_labelCount < len(g_labels), "create_label : overflow") // ##1 use slice
    out.label = g_labelCount
    out.base = create_control_(name, GUI_LABEL, out.label)

    var label label_s
    label.id = out
    label.font = invalid_font()
    label.batch = invalid_batch()
    label.text = ""
    label.textSize = 16
    label.textAlign = ALIGN_NONE
    label.textPosition = mat.v2_zero
    label.color_0 = g_red
    label.color_1 = g_green
    label.on_state = invalid_func_i32_i32()
    g_labels[out.label] = label
    g_labelCount = out.label + 1
    uti.assert_(is_valid_label(out), "create_label : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_font(id label_id, font font_id) {
    uti.assert_(is_valid_label(id), "label_set_font : invalid id")
    uti.assert_(is_valid_font(font), "label_set_font : invalid font")
    g_labels[id.label].font = font
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_text(id label_id, text str) {
    uti.assert_(is_valid_label(id), "label_set_text : invalid id")
    g_labels[id.label].text = text
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_align(id label_id, align i32) {
    uti.assert_(is_valid_label(id), "label_set_align : invalid id")
    g_labels[id.label].textAlign = align
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_size(id label_id, size i32) {
    uti.assert_(is_valid_label(id), "label_set_size : invalid id")
    g_labels[id.label].textSize = size
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_color(id label_id, color mat.v4) {
    uti.assert_(is_valid_label(id), "label_set_color : invalid id")
    g_labels[id.label].color_0 = color
    g_labels[id.label].color_1 = color
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_on_state(i_id label_id, packageName str, functionName str) {
    uti.assert_(is_valid_label(i_id), "label_set_on_state : invalid id")
    g_labels[i_id.label].on_state = func_i32_i32(packageName, functionName)
    var onState func_i32_i32_id = g_labels[i_id.label].on_state
    uti.assert_(onState.index >= 0, "label_set_on_state : invalid function")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type batch_id struct {
    batch i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type batch_s struct {
    texture texture_s
    mesh mesh_id
    alpha bool
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_batches[64] batch_s
var g_batchCount i32 = 0

var g_renderBatches[64] batch_id
var g_renderBatchCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_batch() (out batch_id) {
    out.batch = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_batch(id batch_id) (out bool) {
    out = id.batch >= 0 && id.batch < g_batchCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func get_batch(texture texture_s, alpha bool) (out batch_id) {

    out.batch = -1
    var i i32 = 0
    for i >= 0 {
        if (i < g_batchCount) {
            var textureName i32 = g_batches[i].texture.name
            var textureAlpha bool = g_batches[i].alpha
            if (textureName == texture.name && textureAlpha == alpha) {
                out.batch = i
            }
            i = i + 1
        } else {
            i = -1
        }
    }
    if (out.batch < 0) {
        g_batches[g_batchCount].texture = texture
        var attributes [3]i32 // ##0 harcode
        attributes = [3]i32{3, 4, 2} // ##0 can't use slice yet
        g_batches[g_batchCount].mesh = gfx.lock_mesh(gl.TRIANGLES, attributes, 2048 * 3) // ##0 hardcode
        g_batches[g_batchCount].alpha = alpha
        out.batch = g_batchCount
        g_batchCount = g_batchCount + 1
    }

    i = 0
    var found bool = false
    for i >= 0 {
        if (i < g_renderBatchCount) {
            if (g_renderBatches[i].batch == out.batch) {
               found = true
               i = -1
            } else {
                i = i + 1
            }
        } else {
            i = -1
        }
    }

    if (found == false) {
        //printf("BATCH_NOT FOUND %d\n", out.batch)
        g_renderBatches[g_renderBatchCount] = out
        g_renderBatchCount = g_renderBatchCount + 1
    }

    uti.assert_(is_valid_batch(out), "get_batch : invalid index")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_process_event(id label_id, event *event_s) (out i32) {
    uti.assert_(is_valid_label(id), "label_process_event : invalid label")
    out = control_process_event(id.base, event)

    if (out == EVENT_UNUSED) {
        var index i32 = id.base.control
        var focused i32 = g_controls[index].focused
        var mods i32 = ((*event).keyboard).mods
        if (focused > 0 && mods == MOD_NONE) {
            var key i32 = ((*event).keyboard).key
            var action i32 = ((*event).keyboard).action
            if (key == KEYCODE_ENTER || key == KEYCODE_SPACE) {
                var function func_i32_i32_id = g_labels[id.label].on_state
                var functionIndex i32 = function.index
                if functionIndex >= 0 {
                    //printf("------------------------------------------------------------>>>>> ON_STATE %d\n", functionIndex)
                    call_i32_i32(function, index, action)
                    //printf("label_process_event\n")
                    out = EVENT_CONSUMED
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_resize(id label_id) () {
    uti.assert_(is_valid_label(id), "label_resize : invalid id")
    //control_print("label_resize : ", id.base, false)
    var i32Width i32
    var i32Hheight i32
    var text str = g_labels[id.label].text

    var fontId font_id = g_labels[id.label].font
    var fontIndex i32 = fontId.font
    uti.assert_(is_valid_font(fontId), "label_resize : invalid font")

    var fontSize i32 = g_labels[id.label].textSize
    //printf("fontID %d, fontSize %d\n", fontId.font, fontSize)
    var textureIndex i32 = font_get_texture_index(fontId, fontSize)

    //printf("fontIndex %d, textureIndex %d\n", fontIndex, textureIndex)
    var fontName str = g_fonts[fontIndex].names[textureIndex] // ##0 auto select best size
    i32Width, i32Height := gfx.measure_text(fontName, text)

    var pixelBounds mat.v2 = mat.v2_(i32.f32(i32Width), i32.f32(i32Height))
    var bounds mat.v2 = mat.v2_div(pixelBounds, gfx.gfx_viewport)
    control_resize_(id.base, pixelBounds, bounds, bounds)

    var position mat.v2 = g_controls[id.base].renderPosition
    //var size mat.v2 = g_controls[id.base].renderSize
    var size mat.v2 = g_controls[id.base].size
    var scale mat.v2 = g_controls[id.base].scale
    var padding mat.v4 = g_controls[id.base].padding
    //printf("LABEL_SCALE %f, %f, width %f, height %f, scale.x * width %f, scale.y * height %f\n", scale.x, scale.y, width, height, scale.x * width, scale.y * height)

    var newSize mat.v2 = mat.v2_mul(scale, bounds)

    position.x, position.y = align_control(g_labels[id.label].textAlign, 0.0, 0.0, newSize.x, newSize.y, position.x, position.y, size.x, size.y, padding)
    g_labels[id.label].textPosition = position
    printf("LABEL_TEXT_POSITION %f, %f\n", position.x, position.y)
    g_labels[id.label].batch = get_batch(g_fonts[fontIndex].textures[textureIndex], true)
    //control_print("label_resize :", id.base, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_render(id label_id) () {
    uti.assert_(is_valid_label(id), "label_render : invalid id")
    control_print("label_render : ", id.base, false)
    control_render(id.base)

    var fontId font_id = g_labels[id.label].font
    uti.assert_(is_valid_font(fontId), "label_render : invalid font")

    var fontSize i32 = g_labels[id.label].textSize
    var textureIndex i32 = font_get_texture_index(fontId, fontSize)

    var fontTexture texture_s = g_fonts[fontId.font].textures[textureIndex] // ##0 auto select best size
    var fontName str = g_fonts[fontId.font].names[textureIndex]

    //printf("label_render : using font %s - %d, %d, %d\n", fontName, fontTexture.name, fontTexture.width, fontTexture.height)

    var control i32 = id.base.control
    var renderPosition mat.v2 = g_labels[id.label].textPosition
    var batch batch_id = g_labels[id.label].batch
    uti.assert_(is_valid_batch(batch), "label_render : invalid batch")
    //gfx.append_text(&(gfx.g_meshes[g_batches[batch.batch].mesh.mesh]), fontTexture, fontName, // ##pending
    var meshId gfx.mesh_id = g_batches[batch.batch].mesh
    gfx.append_text(meshId, fontTexture, fontName,
        renderPosition, g_controls[control].scale,
        mat.v4_(1.0, 1.0, 1.0, 1.0), g_labels[id.label].text, true, g_labels[id.label].color_0, g_labels[id.label].color_1)
}

//-----------------------------------------------------------------------------
// PICTURE
//-----------------------------------------------------------------------------
var g_pictures [64]picture_s
var g_pictureCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type picture_id struct {
    base control_id
    picture i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type picture_s struct {
    id picture_id
    texture gfx.texture_s
    batch batch_id
    pictureAlign i32
    picturePosition mat.v2
    alpha bool
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_id_(base control_id, picture i32) (out picture_id) {
    out.base = base
    out.picture = picture
    uti.assert_(is_valid_picture(out), "picture_id_ : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_picture(id picture_id) (out bool) {
    out = id.picture >= 0 && id.picture < g_pictureCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_picture(name str) (out picture_id) {
    uti.assert_(g_pictureCount < len(g_pictures), "create_picture : overflow") // ##1 use slice
    out.picture = g_pictureCount
    out.base = create_control_(name, GUI_PICTURE, out.picture)

    var picture picture_s
    picture.id = out
    picture.texture = gfx.invalid_texture()
    picture.batch = invalid_batch()
    picture.pictureAlign = ALIGN_NONE
    picture.picturePosition = mat.v2_zero
    picture.alpha = false

    g_pictures[out.picture] = picture
    g_pictureCount = out.picture + 1
    uti.assert_(is_valid_picture(out), "create_picture : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_set_texture(id picture_id, texture texture_s) {
    uti.assert_(is_valid_picture(id), "picture_set_texture : invalid id")
    g_pictures[id.picture].texture = texture
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_set_align(id picture_id, align i32) {
    uti.assert_(is_valid_picture(id), "picture_set_align : invalid id")
    g_pictures[id.picture].pictureAlign = align
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_process_event(id picture_id, event *event_s) (out i32) {
    uti.assert_(is_valid_picture(id), "picture_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_resize(id picture_id) () {
   uti.assert_(is_valid_picture(id), "picture_resize : invalid id")

    var i32Width i32 = g_pictures[id.picture].texture.width
    var i32Height i32 = g_pictures[id.picture].texture.height

    var pixelBounds mat.v2 = mat.v2_(i32.f32(i32Width), i32.f32(i32Height))
    var bounds mat.v2 = mat.v2_div(pixelBounds, gfx.gfx_viewport)

    control_resize_(id.base, pixelBounds, bounds, bounds)

    var position mat.v2 = g_controls[id.base].renderPosition
    //var size mat.v2 = g_controls[id.base].renderSize
    var size mat.v2 = g_controls[id.base].size
    var scale mat.v2 = g_controls[id.base].scale
    var padding mat.v4 = g_controls[id.base].padding
    //printf("PICTURE_SCALE %f, %f, width %f, height %f, scale.x * width %f, scale.y * height %f\n", scale.x, scale.y, width, height, scale.x * width, scale.y * height)

    var newSize mat.v2 = mat.v2_mul(scale, bounds)
    //printf("NEW SIZE %f, %f - %f, %f -> %f, %f\n", bounds.x, bounds.y, newSize.x, newSize.y, size.x, size.y)
    position.x, position.y = align_control(g_pictures[id.picture].pictureAlign, 0.0, 0.0, newSize.x, newSize.y, position.x, position.y, size.x, size.y, padding)
    //printf("PICTURE_POSITION %f, %f\n", position.x, position.y)
    g_pictures[id.picture].picturePosition = position
    g_pictures[id.picture].batch = get_batch(g_pictures[id.picture].texture, g_pictures[id.picture].alpha)
    //control_print("picture_resize : AFTER", id.base, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_render(id picture_id) () {
    uti.assert_(is_valid_picture(id), "picture_render : invalid id")

    control_render(id.base)

    var control i32 = id.base.control

    var color mat.v4 = gfx.white
    var controlSkin control_skin_id = g_controls[control].skin
    uti.assert_(is_valid_control_skin(controlSkin) || controlSkin.skin == -1, "picture_render : invalid id")
    if is_valid_control_skin(controlSkin) {
        var backLayerSkin layer_skin_id = g_controlSkins[controlSkin.skin].back
        uti.assert_(is_valid_layer_skin(backLayerSkin) || backLayerSkin.layer == -1, "picture_render : invalid id")
        if is_valid_layer_skin(backLayerSkin) {
            color = g_layerSkins[backLayerSkin.layer].surface
        }
    }

    var texture gfx.texture_s = g_pictures[id.picture].texture
    if texture.name > 0 {
        //printf("RENDER_BOUNDS %f, %f, %f, %f\n",
          //  g_controls[id.control].renderBounds.x,
            //g_controls[id.control].renderBounds.y,
            //g_controls[id.control].renderBounds.z,
            //g_controls[id.control].renderBounds.w)

        var i32Width i32 = g_pictures[id.picture].texture.width
        var i32Height i32 = g_pictures[id.picture].texture.height

        var scale mat.v2 = g_controls[id.base].scale

        //control_print("picture_render : ", id.base, false)
        var width f32 = scale.x * i32.f32(i32Width) / gfx.gfx_width
        var height f32 = scale.y * i32.f32(i32Height) / gfx.gfx_height

        var renderPosition mat.v2 = g_pictures[id.picture].picturePosition
        //var renderPosition mat.v2 = g_controls[id.base].renderPosition

        var batch batch_id = g_pictures[id.picture].batch
        uti.assert_(is_valid_batch(batch), "picture_render : invalid batch")

        var meshId gfx.mesh_id = g_batches[batch.batch].mesh
        gfx.append_quad(meshId, mat.v4_v2v2(renderPosition, mat.v2_(width, height)), mat.v4_(0.0, 0.0, 1.0, 1.0), color)
    }
}

//-----------------------------------------------------------------------------
// WINDOW
//-----------------------------------------------------------------------------
var g_windows[8] window_s
var g_windowCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type window_id struct {
    base control_id
    window i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type window_s struct {
    id window_id
    header control_id
    caption label_id
    container control_id
    strip control_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_id_(base control_id, window i32) (out window_id) {
    out.base = base
    out.window = window
    uti.assert_(is_valid_window(out), "window_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_window(id window_id) (out bool) {
    out = id.window >= 0 && id.window < g_windowCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_set_caption(id window_id, text str) () {
    uti.assert_(is_valid_window(id), " window_set_caption : invalid id")
    label_set_text(g_windows[id.window].caption, text)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_set_containee(id window_id, containee control_id) {
    uti.assert_(is_valid_window(id), "window_set_containee : invalid id")
    uti.assert_(is_valid_control(containee), "window_set_containee : invalid containee")

    var container control_id = g_windows[id.window].container
    uti.assert_(is_valid_control(container), "window_set_containee : invalid container")

    control_add_child(container, containee)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_window(name str) (out window_id) {
    uti.assert_(g_windowCount < len(g_windows), "create_window : overflow") // ##1 use slice
    out.base = create_control_(name, GUI_WINDOW, out.window)
    out.window = g_windowCount

    var window window_s
    window.id = out

    g_windowCount = out.window + 1

    uti.assert_(is_valid_window(out), "create_window : invalid id")

    var padding mat.v4 = mat.v4_(0.01, 0.01, 0.01, 0.01)
    var padding1 mat.v4 = mat.v4_(0.03, 0.03, 0.03, 0.03)
    {
        var header control_id = create_control("header") // ##pending := 
        control_add_child(out.base, header)
        control_set_skin(header, g_headerControlSkin)
        control_set_size(header, mat.v2_(0.0, 0.1))
        control_set_dock(header, DOCK_TOP)
        control_set_autosize(header, AUTOSIZE_Y)
        window.header = header

        {
            var caption label_id = create_label("label")
            control_add_child(header, caption.base)
            control_set_dock(caption.base, DOCK_FILL)
            control_set_autosize(caption.base, AUTOSIZE_Y)
            label_set_align(caption, ALIGN_CENTER)
            label_set_font(caption, g_boldFont) // ##1 skin
            label_set_color(caption, g_white)
            label_set_size(caption, g_fontSizeHeader)
            window.caption = caption
        }
    }

    {
        var container control_id = create_control("container")
        control_add_child(out.base, container)
        //control_set_skin(container, g_redControlSkin)
        control_set_dock(container, DOCK_TOP)
        control_set_autosize(container, AUTOSIZE)
        control_set_padding(container, padding1)
        window.container = container
    }

    {
        var strip control_id = create_control("strip")
        control_add_child(out.base, strip)
        //control_set_skin(strip, g_primaryBlueControlSkin)
        control_set_bounds(strip, mat.v4_(0.0, 0.0, 0.0, 0.12))
        control_set_dock(strip, DOCK_TOP)
        control_set_autosize(strip, AUTOSIZE_Y)
        control_set_padding(strip, padding)
        window.strip = strip
    }

    g_windows[out.window] = window
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_add_button(id window_id, name str, caption str, packageName str, functionName str) {
    uti.assert_(is_valid_window(id), "window_add_button : invalid id")

    var button label_id = create_label(name)
    control_set_skin(button.base, g_buttonControlSkin)
    control_set_bounds(button.base, mat.v4_(0.0, 0.0, 0.15, 0.1))
    control_set_dock(button.base, DOCK_RIGHT)
    control_set_autosize(button.base, AUTOSIZE_Y)
    control_set_padding(button.base, mat.v4_(0.01, 0.01, 0.01, 0.01))
    control_set_focusable(button.base, 1)
    label_set_align(button, ALIGN_CENTER)
    label_set_color(button, g_white)
    label_set_font(button, g_boldFont)
    label_set_text(button, caption)
    label_set_size(button, g_fontSizeButton)
    label_set_on_state(button, packageName, functionName)

    var strip control_id = g_windows[id.window].strip
    control_add_child(strip, button.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_process_event(id window_id, event *event_s) (out i32) {
    uti.assert_(is_valid_window(id), "window_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_resize(id window_id) () {
    uti.assert_(is_valid_window(id), "window_resize : invalid id")
    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_render(id window_id) () {
    uti.assert_(is_valid_window(id), "window_render : invalid id")
    control_render(id.base)
}

//-----------------------------------------------------------------------------
// KEYBOARD
//-----------------------------------------------------------------------------
var g_keyboards[8] keyboard_s
var g_keyboardCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type keyboard_id struct {
    base control_id
    keyboard i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type keyboard_s struct {
    id keyboard_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_id_(base control_id, keyboard i32) (out keyboard_id) {
    out.base = base
    out.keyboard = keyboard
    uti.assert_(is_valid_keyboard(out), "keyboard_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_keyboard(id keyboard_id) (out bool) {
    out = id.keyboard >= 0 && id.keyboard < g_keyboardCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_keyboard(name str) (out keyboard_id) {
    uti.assert_(g_keyboardCount < len(g_keyboards), "create_keyboard : overflow") // ##1 use slice
    out.keyboard = g_keyboardCount
    out.base = create_control_(name, GUI_KEYBOARD, out.keyboard)

    var keyboard keyboard_s
    keyboard.id = out

    g_keyboards[out.keyboard] = keyboard
    g_keyboardCount = out.keyboard + 1
    uti.assert_(is_valid_keyboard(out), "create_keyboard : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_process_event(id keyboard_id, event *event_s) (out i32) {
    uti.assert_(is_valid_keyboard(id), "keyboard_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_resize(id keyboard_id) () {
    uti.assert_(is_valid_keyboard(id), "keyboard_resize : invalid id")
    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*func keyboard_render() () {
    var rowCount i32 = 10
    var lineCount i32 = 4

    var fRowCount f32 = i32.f32(rowCount)
    var fLineCount f32 = i32.f32(lineCount)

    var keyWidth f32 = 0.08
    var keyHeight f32 = 0.08 * gfx.gfx_ratio

    var height f32 = fLineCount * keyHeight + (fLineCount + 1.0) * gui.padding.y
    var width f32 = fRowCount * keyWidth + (fRowCount + 1.0) * gui.padding.x

    var w f32 = width
    var h f32 = height
    var x f32 = -1.0 + (2.0 - w) / 2.0
    var y f32 = -1.0 + gui.padding.y
    gfx.append_quad(g_opaqueVertexColoredTriangles, mat.v4_(x, y, w, h), mat.v4_(0.0, 0.0, 1.0, 1.0), gui.g_gray_2)
    gfx.append_rect(g_opaqueVertexColoredLines, mat.v4_(x, y, w, h), gui.g_gray_3, gui.g_gray_3, gui.g_gray_3, gui.g_gray_3)

    var count i32 = 0
    var i i32 = 0
    var j i32 = 0
    for i = 0; i < rowCount; i = i + 1 {
        for j = 0; j < lineCount; j = j + 1 {
            var kx f32 = gui.padding.x + x + i32.f32(i) * (gui.padding.x + keyWidth)
            var ky f32 = gui.padding.y + y + i32.f32(j) * (gui.padding.y + keyHeight)
            var kw f32 = keyWidth
            var kh f32 = keyHeight
            gfx.append_quad(g_opaqueVertexColoredTriangles, mat.v4_(kx, ky, kw, kh), mat.v4_(0.0, 0.0, 1.0, 1.0), gui.g_primary_blue)
            gfx.append_text(g_alphaTexturedTriangles, g_skycoinFontTexture, "skycoin", kx, ky, gui.g_light_blue, "A", false, false)
            gfx.append_rect(g_opaqueVertexColoredLines, mat.v4_(kx, ky, kw, kh), gui.g_primary_blue, gui.g_primary_blue, gui.g_primary_blue, gui.g_primary_blue)
            count = count + 1
        }
    }
}*/

func keyboard_render(id keyboard_id) () {
    uti.assert_(is_valid_keyboard(id), "keyboard_render : invalid id")
    control_render(id.base)
}

//-----------------------------------------------------------------------------
// PARTITION
//-----------------------------------------------------------------------------
var g_partitions[8] partition_s
var g_partitionCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type partition_id struct {
    base control_id
    partition i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type partition_s struct {
    id partition_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_id_(base control_id, partition i32) (out partition_id) {
    out.base = base
    out.partition = partition
    uti.assert_(is_valid_partition(out), "partition_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_partition(id partition_id) (out bool) {
    out = id.partition >= 0 && id.partition < g_partitionCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_partition(name str) (out partition_id) {
    uti.assert_(g_partitionCount < len(g_partitions), "create_partition : overflow") // ##1 use slice
    out.partition = g_partitionCount
    out.base = create_control_(name, GUI_PARTITION, out.partition)

    var partition partition_s
    partition.id = out

    g_partitions[out.partition] = partition
    g_partitionCount = out.partition + 1
    uti.assert_(is_valid_partition(out), "create_partition : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_process_event(id partition_id, event *event_s) (out i32) {
    uti.assert_(is_valid_partition(id), "partition_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_resize(id partition_id) () {
    uti.assert_(is_valid_partition(id), "partition_resize : invalid id")
    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_render(id partition_id) () {
    uti.assert_(is_valid_partition(id), "partition_render : invalid id")
    control_render(id.base)
}

//-----------------------------------------------------------------------------
// GRAPH
//-----------------------------------------------------------------------------
type graph_id struct {
    base control_id
    graph i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type graph_s struct {
    id graph_id
    unit mat.v2
    scale mat.v2
    offset mat.v2
    expX i32
    expY i32
    coord mat.v2
    labels [256] label_id
    labelCount i32
    horz [128] graph_line_s
    horzCount i32
    vert [128] graph_line_s
    vertCount i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_id_(base control_id, graph i32) (out graph_id) {
    out.base = base
    out.graph = graph
    uti.assert_(is_valid_graph(out), "graph_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_graph(id graph_id) (out bool) {
    out = id.graph >= 0 && id.graph < g_graphCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_graphs[8] graph_s
var g_graphCount i32 = 0

type graph_line_s struct {
    color mat.v4
    bounds mat.v4
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_create(name str) (out graph_id) {
    out.base = create_control_(name, GUI_GRAPH, out.graph)
    control_set_focusable(out.base, 1)

    out.graph = g_graphCount

    g_graphs[g_graphCount].id = out
    g_graphs[g_graphCount].unit = mat.v2_(0.1, 0.1)
    g_graphs[g_graphCount].scale = mat.v2_(1.0, 1.0)
    g_graphs[g_graphCount].offset = mat.v2_(0.0, 0.0)
    g_graphs[g_graphCount].expX = 0
    g_graphs[g_graphCount].expY = 0
    g_graphs[g_graphCount].vertCount = 0
    g_graphs[g_graphCount].horzCount = 0
    var labelCount i32 = 0
    for (labelCount < 64) {
        var label label_id = create_label(sprintf("graphLabel_%d", labelCount))
        g_graphs[g_graphCount].labels[labelCount] = label
        labelCount = labelCount + 1
    }

    g_graphs[g_graphCount].labelCount = labelCount
    g_graphCount = out.graph + 1

    uti.assert_(is_valid_graph(out), "graph_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_process_event(id graph_id, event *event_s) (out i32) {
    uti.assert_(is_valid_graph(id), "graph_process_event : invalid id")
    control_print("graph_process_event : ", id.base, false)

    out = control_process_event(id.base, event)
    if (out == EVENT_UNUSED) {
        var controlIndex i32 = id.base.control
        var focused i32 = g_controls[controlIndex].focused
        if (focused > 0) {
            var key i32 = ((*event).keyboard).key
            var action i32 = ((*event).keyboard).action
            var mods i32 = ((*event).keyboard).mods
            var graphIndex i32 = id.graph
            var unit mat.v2 = g_graphs[graphIndex].unit
            var scale mat.v2 = g_graphs[graphIndex].scale
            var offset mat.v2 = g_graphs[graphIndex].offset
            if (mods == MOD_CTRL) {
                if (action == KEY_PRESS ||
                    action == KEY_REPEAT) {
                    if (key == KEYCODE_LEFT) {
                        out = EVENT_CONSUMED
                        scale.x = scale.x * 0.9
                    } else if (key == KEYCODE_RIGHT) {
                        out = EVENT_CONSUMED
                        scale.x = scale.x * 1.1
                    } else if (key == KEYCODE_DOWN) {
                        out = EVENT_CONSUMED
                        scale.y = scale.y * 0.9
                    } else if (key == KEYCODE_UP) {
                        out = EVENT_CONSUMED
                        scale.y = scale.y * 1.1
                    }
                    if (scale.x > 1.0) {
                        scale.x = 0.1
                        g_graphs[graphIndex].expX = g_graphs[graphIndex].expX + 1
                    } else if (scale.x < 0.1) {
                        scale.x = 1.0
                        g_graphs[graphIndex].expX = g_graphs[graphIndex].expX - 1
                    }

                    if (scale.y > 1.0) {
                        scale.y = 0.1
                        g_graphs[graphIndex].expY = g_graphs[graphIndex].expY + 1
                    } else if (scale.y < 0.1) {
                        scale.y = 1.0
                        g_graphs[graphIndex].expY = g_graphs[graphIndex].expY - 1
                    }
                    g_graphs[graphIndex].scale = scale
                    g_graphs[graphIndex].unit = unit
                }
            } else if (mods == MOD_NONE) {
                if (action == KEY_PRESS ||
                    action == KEY_REPEAT) {
                    if (key == KEYCODE_LEFT) {
                        out = EVENT_CONSUMED
                        offset.x = offset.x - unit.x * 0.1 * scale.x
                    } else if (key == KEYCODE_RIGHT) {
                        out = EVENT_CONSUMED
                        offset.x = offset.x + unit.x * 0.1 * scale.x
                    } else if (key == KEYCODE_DOWN) {
                        out = EVENT_CONSUMED
                        offset.y = offset.y - unit.y * 0.1 * scale.y
                    } else if (key == KEYCODE_UP) {
                        out = EVENT_CONSUMED
                        offset.y = offset.y + unit.y * 0.1 * scale.y
                    }
                    g_graphs[graphIndex].offset = offset
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_resize(id graph_id) () {
    uti.assert_(is_valid_graph(id), "graph_resize : invalid id")
    control_clear_child(id.base)
    control_resize(id.base)

    var graphIndex i32 = id.graph
    g_graphs[graphIndex].coord = mat.v2_(0.1, 0.1)

    var controlIndex i32 = id.base.control

    g_graphs[graphIndex].horzCount = 0
    g_graphs[graphIndex].vertCount = 0
    g_graphs[graphIndex].labelCount = 0

    var graphIndex i32 = id.graph

    var offset mat.v2 = g_graphs[graphIndex].offset
    var unit mat.v2 = g_graphs[graphIndex].unit
    var scale mat.v2 = g_graphs[graphIndex].scale

    var controlIndex i32 = id.base.control

    var width f32 = g_controls[controlIndex].size.x
    var height f32 = g_controls[controlIndex].size.y

    var size mat.v2 = g_controls[controlIndex].size
    var position mat.v2 = g_controls[controlIndex].renderPosition

    var coord mat.v2 = g_graphs[graphIndex].coord

    var stepX f32 = unit.x * scale.x
    var stepY f32 = unit.y * scale.y

    var i i32 = 0
    var ix i32 = 0
    var iy i32 = 0

    var offsetX f32 = offset.x
    if (offsetX > 0) {
        for (offsetX > 0) {
            offsetX = offsetX - stepX
            ix = ix - 1
        }
    } else if (offsetX < 0) {
        for ((offsetX + stepX) < 0) {
            offsetX = offsetX + stepX
            ix = ix + 1
        }
    }

    var offsetY f32 = offset.y
    if (offsetY > 0) {
        for (offsetY > 0) {
            offsetY = offsetY - stepY
            iy = iy - 1
        }
    } else if (offsetY < 0) {
        for ((offsetY + stepY) < 0) {
            offsetY = offsetY + stepY
            iy = iy + 1
        }
    }

    var graphPosition mat.v2
    graphPosition.x = position.x + offsetX + coord.x
    graphPosition.y = position.y + offsetY + coord.y

    var endX f32 = graphPosition.x + size.x - offsetX - coord.x
    var endY f32 = graphPosition.y + size.y - offsetY - coord.y

    //gfx.push_scissor(mat.v4_(coord.x, coord.y, size.x - coord.x, size.y - coord.y))

    var horzMax i32 = len(g_graphs[graphIndex].horz)
    i = 0
    var labelX f32 = coord.x + offsetX - stepX / 2.0
    var x f32 = graphPosition.x
    for (x < endX) {
        var color mat.v4 = g_gray_2
        var font font_id

        if ((ix % 100) == 0) {
            color = g_gray_3
            font = g_boldFont
            //color = mat.v4_(1.0, 0.0, 0.0, 1.0)
        } else if ((ix % 10) == 0) {
            color = mat.v4_mix(g_gray_2, g_gray_3, scale.x)
            font = g_boldFont
            //color = mat.v4_(0.0, 1.0, 0.0, 1.0)
        } else {
            color = mat.v4_mix(g_gray_0, g_gray_2, scale.x)
            font = g_regularFont
            //color = mat.v4_(0.0, 0.0, 1.0, 1.0)
        }

        if (i < horzMax) {
            var graphLine graph_line_s
            graphLine.color = color
            graphLine.bounds = mat.v4_(x, graphPosition.y, x, endY)
            g_graphs[graphIndex].horz[i] = graphLine
            g_graphs[graphIndex].horzCount = i + 1
        }

        var labelCount i32 = g_graphs[graphIndex].labelCount
        if (labelCount < 64) {
        var label label_id = g_graphs[graphIndex].labels[labelCount]
        control_add_child(id.base, label.base)
        var labelBounds mat.v4 = mat.v4_(labelX, 0.0, stepX, coord.y)//stepX, coord.y)
        control_set_bounds(label.base, labelBounds)
        control_set_autoscale(label.base, AUTOSCALE)
        printf("labelBounds %f, %f, %f, %f\n", labelBounds.x, labelBounds.y, labelBounds.z, labelBounds.w)
    
        label_set_font(label, g_regularFont)
        //label_set_color(label, mat.v4_(1.0, 0.0, 1.0, 1.0))
        label_set_color(label, color)
        /*if ((i % 2) == 0) {
            control_set_skin(label.base, g_redControlSkin)
        } else {
            control_set_skin(label.base, g_greenControlSkin)
        }*/
        label_set_text(label, "0")
        label_set_align(label, ALIGN_CENTER)
        label_resize(label)
        control_set_bounds(label.base, labelBounds)
        //control_set_align(label.base, ALIGN_CENTER)
        control_print("label_bounds : ", label.base, false)
        g_graphs[graphIndex].labelCount = labelCount + 1
        }
        //label_resize(label)
        //label_render(label)
        labelX = labelX + stepX
        x = x + stepX
        ix = ix + 1
        i = i + 1
    }

    var vertMax i32 = len(g_graphs[graphIndex].vert)
    i = 0
    var y f32 = graphPosition.y
    for (y < endY) {
        var color mat.v4 = g_gray_2
        if ((iy % 100) == 0) {
            color = g_gray_3
        } else if ((iy % 10) == 0) {
            color = mat.v4_mix(g_gray_2, g_gray_3, scale.y)
        } else {
            color = mat.v4_mix(g_gray_0, g_gray_2, scale.y)
        }

        //color = mat.v4_(1.0, 0.0, 1.0, 1.0)

        if (i < vertMax) {
            var graphLine graph_line_s
            graphLine.color = color
            graphLine.bounds = mat.v4_(graphPosition.x, y, endX, y)
//    printf("i %d, color %f, %f, %f, %f, bounds %f, %f, %f, %f\n",
      //      i, color.x, color.y, color.z, color.w, graphLine.bounds.x, graphLine.bounds.y, graphLine.bounds.z, graphLine.bounds.w)
            g_graphs[graphIndex].vert[i] = graphLine
            g_graphs[graphIndex].vertCount = i + 1
        //} else {
       //     printf("I %d\n", i)
        }
        y = y + stepY
        iy = iy + 1
        i = i + 1
    }

    //control_resize(id.base)
    //gfx.pop_scissor()
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_render(id graph_id) () {
    uti.assert_(is_valid_graph(id), "graph_render : invalid id")
    control_render(id.base)

    var graphIndex i32 = id.graph

    var i i32 = 0
    var horzCount i32 = g_graphs[graphIndex].horzCount
    for i = 0; i < horzCount; i = i + 1 {
        var bounds mat.v4 = g_graphs[graphIndex].horz[i].bounds
        var color mat.v4 = g_graphs[graphIndex].horz[i].color
        gfx.append_line(g_opaqueVertexColoredLines, bounds, color)
    }

    var vertCount i32 = g_graphs[graphIndex].vertCount
    for i = 0; i < vertCount; i = i + 1 {
        var bounds mat.v4 = g_graphs[graphIndex].vert[i].bounds
        var color mat.v4 = g_graphs[graphIndex].vert[i].color
        /*if (i == 3) {
            color = mat.v4_(0.0, 1.0, 0.0, 1.0)
            bounds.y = bounds.y + 0.01
            bounds.w = bounds.w + 0.01
        }*/
//        printf("II %d, COLOR %f, %f, %f, %f, BOUNDS %f, %f, %f, %f\n",
  //          i, color.x, color.y, color.z, color.w, bounds.x, bounds.y, bounds.z, bounds.w)
        gfx.append_line(g_opaqueVertexColoredLines, bounds, color)
    }
}

//-----------------------------------------------------------------------------
// GUI
//-----------------------------------------------------------------------------
func init() () {
   // meshes
    var attributes [3]i32
    attributes = [3]i32{3, 4, 2} // can't use slice yet
    g_opaqueVertexColoredTriangles = gfx.create_mesh(gl.TRIANGLES, attributes, 10 * 2048 * 3)
    g_alphaVertexColoredTriangles = gfx.create_mesh(gl.TRIANGLES, attributes, 10 * 2048 * 3)
    g_opaqueVertexColoredLines = gfx.create_mesh(gl.LINES, attributes, 20 * 2048 * 2)
    g_fullscreenQuad = gfx.create_mesh(gl.TRIANGLES, attributes, 6 * 3)

    gfx.begin_mesh(g_fullscreenQuad)
    gfx.append_quad(g_fullscreenQuad, mat.v4_(-1.0, 1.0, 2.0, -2.0), mat.v4_(0.0, 0.0, 1.0, 1.0), gfx.white)
    gfx.end_mesh(g_fullscreenQuad)

    // fonts
    g_regularFont = create_font("skycoinRegular", "fonts/Skycoin-Regular.ttf", 32, 127, gltext.LeftToRight)
    font_add_size(g_regularFont, g_fontSizeText)
    font_add_size(g_regularFont, g_fontSizeButton)
    font_add_size(g_regularFont, g_fontSizeHeader)
    font_add_size(g_regularFont, g_fontSizeTitle)

    g_boldFont = create_font("skycoinBold", "fonts/Skycoin-Bold.ttf", 32, 127, gltext.LeftToRight)
    font_add_size(g_boldFont, g_fontSizeText)
    font_add_size(g_boldFont, g_fontSizeButton)
    font_add_size(g_boldFont, g_fontSizeHeader)
    font_add_size(g_boldFont, g_fontSizeTitle)

    // textures
    g_skycoinTexture = gfx.create_texture("textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png", gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)

    // layers
    g_debugLayerSkin            = create_layer_skin("debug"         , g_red               , g_green     , g_green     , g_green     , g_green )
    g_bootLayerSkin             = create_layer_skin("boot"          , g_black             , gfx.zero    , gfx.zero    , gfx.zero    , gfx.zero)
    g_blackLayerSkin            = create_layer_skin("black"         , g_black             , g_gray_3    , g_gray_3    , g_gray_3    , g_gray_3)
    g_redLayerSkin              = create_layer_skin("red"           , g_red               , gfx.zero    , gfx.zero    , gfx.zero    , gfx.zero)
    g_greenLayerSkin            = create_layer_skin("green"         , g_green             , gfx.zero    , gfx.zero    , gfx.zero    , gfx.zero)
    g_primaryBlueLayerSkin      = create_layer_skin("primaryBlue"   , g_primary_blue      , gfx.zero    , gfx.zero    , gfx.zero    , gfx.zero)
    g_primaryBlueAlphaLayerSkin = create_layer_skin("primaryBlueA50", g_primary_blue_a50  , gfx.zero    , gfx.zero    , gfx.zero    , gfx.zero)
    g_modalLayerSkin            = create_layer_skin("modal"         , g_black_a50         , gfx.zero    , gfx.zero    , gfx.zero    , gfx.zero)
    g_windowLayerSkin           = create_layer_skin("window"        , g_black             , g_gray_3    , g_gray_3    , g_gray_3    , g_gray_3)
    g_headerLayerSkin           = create_layer_skin("header"        , g_gray_2            , g_gray_3    , g_gray_3    , g_gray_3    , g_gray_3)
    g_focusedLayerSkin          = create_layer_skin("focused"       , g_primary_blue      , g_light_blue, g_light_blue, g_light_blue, g_light_blue)
    g_stripLayerSkin            = create_layer_skin("strip"         , g_gray_1            , g_gray_2    , g_gray_2    , g_gray_2    , g_gray_2)
    // controls
    g_debugControlSkin           = create_control_skin("debug"          , g_debugLayerSkin      , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_bootControlSkin            = create_control_skin("boot"           , g_bootLayerSkin       , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_blackControlSkin           = create_control_skin("black"          , g_blackLayerSkin      , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_redControlSkin             = create_control_skin("red"            , g_redLayerSkin        , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_greenControlSkin           = create_control_skin("green"          , g_greenLayerSkin      , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_primaryBlueControlSkin     = create_control_skin("primaryBlue"    , g_primaryBlueLayerSkin, invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_primaryBlueAlphaControlSkin= create_control_skin("primaryBlueA50" , invalid_layer_skin()  , g_primaryBlueAlphaLayerSkin, invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_modalControlSkin           = create_control_skin("modal"          , g_modalLayerSkin      , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_windowControlSkin          = create_control_skin("window"         , g_windowLayerSkin     , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_headerControlSkin          = create_control_skin("header"         , g_headerLayerSkin     , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_buttonControlSkin          = create_control_skin("button"         , g_headerLayerSkin     , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), g_focusedLayerSkin  , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())
    g_stripControlSkin           = create_control_skin("strip"          , g_stripLayerSkin      , invalid_layer_skin()       , invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin(), invalid_layer_skin())

    printf("C5\n")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func update(deltaTime f64)() { // ##1 rewrite

    //printf("UPDATE %d, %d\n", g_currentScreen.screen, g_nextScreen.screen)
    if (is_valid_screen(g_currentScreen)) {
        update_screen(g_currentScreen, deltaTime)
        if (screen_state_changed(g_currentScreen, STATE_OPENED, STATE_CLOSING)) {
            g_nextScreen = g_screens[g_currentScreen.screen].on_next // ##issue_58 issue array index with struct
            printf("NEXT_SCREEN %d\n", g_nextScreen.screen)
            printf("CURRENT %d, NEXT %d\n", g_currentScreen.screen, g_nextScreen.screen)
            g_transitionTime = 0.0D
            g_screens[g_currentScreen.screen].prevState= g_screens[g_currentScreen.screen].state
            printf("screen : %d, STATE_CLOSING\n", g_currentScreen.screen)
        } else if (screen_state_changed(g_currentScreen, STATE_CLOSING, STATE_CLOSED)) {
            g_screens[g_currentScreen.screen].time = 0.0D
            g_screens[g_currentScreen.screen].prevState = g_screens[g_currentScreen.screen].state
            g_currentScreen = g_nextScreen
            printf("screen : %d, STATE_CLOSED\n", g_currentScreen.screen)
        }
    }

    if (g_currentScreen.screen != g_nextScreen.screen) {
        if (is_valid_screen(g_nextScreen)) {
            update_screen(g_nextScreen, deltaTime)
        }

        if (g_transitionTime <= 0) {
            printf("TRANSITION STARTED %f\n", f64.f32(g_transitionTime + deltaTime))
            g_transitionTime = g_transitionTime + deltaTime
        } else if (g_transitionTime <= g_transitionDuration) {
            g_transitionTime = g_transitionTime + deltaTime
        } else {
            printf("TRANSITION ENDED\n")
            if (is_valid_screen(g_currentScreen)) {
                printf("CHANGE CLOSED\n")
                change_screen_state(g_currentScreen, STATE_CLOSED)
                printf("prev screen : %d, %d, %s\n", g_currentScreen.screen, g_screens[g_currentScreen.screen].state, "STATE_CLOSED")
            }

            g_currentScreen = g_nextScreen
            printf("CURRENT_SCREEN %d\n", g_nextScreen.screen)
            if (is_valid_screen(g_nextScreen)) {
                var nextScreen screen_id = g_screens[g_nextScreen.screen].on_next
                printf("CHANGE OPENED\n")
                change_screen_state(g_nextScreen, STATE_OPENED)
                printf("next screen : %d, %d, %s\n", g_nextScreen.screen, g_screens[g_nextScreen.screen].state, "STATE_OPENED")
                g_transitionTime = 0.0D
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var KEY_RELEASE i32 = 0
var KEY_PRESS   i32 = 1
var KEY_REPEAT  i32 = 2

var KEYCODE_SPACE     i32 =  32
var KEYCODE_ESCAPE    i32 = 256
var KEYCODE_ENTER     i32 = 257
var KEYCODE_RIGHT     i32 = 262
var KEYCODE_LEFT      i32 = 263
var KEYCODE_DOWN      i32 = 264
var KEYCODE_UP        i32 = 265
var KEYCODE_LEFT_CTRL i32 = 341
var KEYCODE_MENU      i32 = 343

var MOD_NONE  i32 = 0
var MOD_SHIFT i32 = 1
var MOD_CTRL  i32 = 2
var MOD_ALT   i32 = 4
var MOD_MENU  i32 = 8

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*func skip_screens()() {
    var next bool = true
    var skipId screen_id = g_currentScreen
    for (next == true) {
        var nextId screen_id = g_screens[skipId].on_next
        if (is_valid_screen(nextId)) {
            if (is_valid_screen(g_screens[nextId.screen].on_exit) ||
                is_valid_screen(g_screens[nextId.screen].on_enter) ||
                is_valid_screen(g_screens[nextId.screen].on_menu)) {
                next = false
            }
            skipId = nextId
        } else {
            next = false
        }
    }
    g_nextScreen = skipId
}*/

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var EVENT_ERROR    i32 = 0
var EVENT_UNUSED   i32 = 1
var EVENT_CONSUMED i32 = 2

type keyboard_event_s struct {
    key i32
    scancode i32
    action i32
    mods i32
}

type mouse_event_s struct {
}

type event_s struct {
    keyboard keyboard_event_s
    mouse mouse_event_s
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_process_event(id control_id, event *event_s) (out i32) {
    uti.assert_(is_valid_control(id), "control_process_event : invalid id")
//    control_print("control_process_event : ", id, false)
    out = EVENT_UNUSED

    var index i32 = id.control
    var count i32 = g_controls[index].childCount
    for i := 0; i < count; i = i + 1 {
        var child control_id = g_controls[index].children[i]
        uti.assert_(is_valid_control(child), "control_process_event : invalid child control")
        var guiType i32 = g_controls[child.control].gui_type
        var guiIndex i32 = g_controls[child.control].gui_index

        if (guiType == GUI_INVALID) {
           uti.assert_(false, "invalid gui type (GUI_INVALID)")
        } else if (guiType == GUI_CONTROL) {
            uti.assert_(guiIndex == child.control, "unexpected error")
            out = control_process_event(control_id_(guiIndex), event)
        } else if (guiType == GUI_SCREEN) {
            out = screen_process_event(screen_id_(child, guiIndex), event)
        } else if (guiType == GUI_PICTURE) {
            out = picture_process_event(picture_id_(child, guiIndex), event)
        } else if (guiType == GUI_LABEL) {
            out = label_process_event(label_id_(child, guiIndex), event)
        } else if (guiType == GUI_PARTITION) {
            out = partition_process_event(partition_id_(child, guiIndex), event)
        } else if (guiType == GUI_KEYBOARD) {
            out = keyboard_process_event(keyboard_id_(child, guiIndex), event)
        } else if (guiType == GUI_WINDOW) {
            out = window_process_event(window_id_(child, guiIndex), event)
        } else if (guiType == GUI_GRAPH) {
            out = graph_process_event(graph_id_(child, guiIndex), event)
        } else {
            printf("GUI TYPE %d\n", guiType)
            uti.assert_(false, "control_process_event : unknown gui type")
        }

               if (out == EVENT_CONSUMED) {
            i = count // ##pending issue brue
        } else if (out == EVENT_ERROR) {
            uti.assert_(false, "EVENT_ERROR")
        } else if (out != EVENT_UNUSED) {
            uti.assert_(false, "invalid EVENT code")
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func hide_modal(id screen_id) {
    //printf("HIDE_MODAL %d\n", g_modalCount)
    uti.assert_(is_valid_screen(id), "hide_modal : invalid screen")
    uti.assert_(g_modalCount > 0, "hide_modal : invalid count")
    if (g_modalCount > 0) {
        var modalIndex i32 = g_modalCount - 1
        var modalScreen screen_id = g_modals[modalIndex]
        uti.assert_(modalScreen.screen == id.screen, "hide_modal : invalid screen")
        if (modalScreen.screen == id.screen) {
            hide_screen(modalScreen)
            g_modalCount = modalIndex
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_keyboard(window str, key i32, scancode i32, action i32, mods i32) () {
    printf("key pressed : %d, scancode %d, action %d, mods %d\n", key, scancode, action, mods)

    var event event_s
    event.keyboard.key = key
    event.keyboard.scancode = scancode
    event.keyboard.action = action
    event.keyboard.mods = mods

    var currentScreen screen_id = invalid_screen()
    if (g_modalCount > 0) {
        var modalIndex i32 = g_modalCount - 1
        var modalScreen screen_id = g_modals[modalIndex]
        if (control_process_event(modalScreen.base, &event) == EVENT_UNUSED) {
            if (key == KEYCODE_ESCAPE && action == KEY_PRESS) {
                hide_modal(modalScreen)
            } else {
                currentScreen = modalScreen
            }
        }
    } else if (is_valid_screen(g_currentScreen)) {
    //printf("NO MODAL\n")
    if (control_process_event(g_currentScreen.base, &event) == EVENT_UNUSED) {
            var screen i32 = g_currentScreen.screen
            var state i32 = g_screens[screen].state
            //if (g_screens[g_currentScreen.screen].state == STATE_OPENED) { // ##pending
            //} else if (g_screens[g_currentScreen.screen].state == STATE_SHOWING) { // ##pending
            if (state == STATE_OPENED || state == STATE_SHOWING) {
                if (key == KEYCODE_ESCAPE && action == KEY_PRESS) {
                    g_screens[screen].paused = true
                    var onExit screen_id = g_screens[screen].on_exit
                    if (is_valid_screen(onExit) == true) {
                        show_screen(onExit)
                    } else {
                        printf("INVALID ON EXIT SCREEN %d, %d\n", onExit.screen, onExit.base)
                    }
                } else if (key == KEYCODE_ENTER && action == KEY_PRESS) {
                    g_screens[screen].paused = true
                    var onEnter screen_id = g_screens[screen].on_enter
                    if (is_valid_screen(onEnter) == true) {
                        show_screen(onEnter)
                    }
                } else if (key == KEYCODE_MENU && action == KEY_PRESS) {
                    g_screens[screen].paused = true
                    var onMenu screen_id = g_screens[screen].on_menu
                    if (is_valid_screen(onMenu) == true) {
                        show_screen(onMenu)
                    }
                } else {
                    currentScreen = g_currentScreen
                }
            }
        }
    }

    if (is_valid_screen(currentScreen)) {
        if (action == KEY_PRESS && mods == MOD_NONE) {
            if (key == KEYCODE_LEFT ||
                key == KEYCODE_UP) {
                set_previous_focus(currentScreen)
            } else if (key == KEYCODE_RIGHT ||
                       key == KEYCODE_DOWN) {
                set_next_focus(currentScreen)
            }
       }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func hide_screen(id screen_id) () {
    uti.assert_(is_valid_screen(id), "hide_screen : invalid screen")

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func show_screen(id screen_id) () {
    uti.assert_(is_valid_screen(id), "show_screen : invalid id")
    control_print("show_screen : ", id.base, false)
    rebuild_focus(id)

    var modal bool = g_screens[id.screen].modal
    if (modal == true) {
        g_modals[g_modalCount] = id
        g_modalCount = g_modalCount + 1
    } else {
        g_nextScreen = id
        g_transitionTime = 0.0D
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize() () {
    clear_batches()
    if (is_valid_screen(g_currentScreen)) {
        reset_scope()
        screen_resize(g_currentScreen)
        control_redock(g_currentScreen.base, mat.v4_zero)
        screen_resize(g_currentScreen)
        control_redock(g_currentScreen.base, mat.v4_zero)
    }
    if (is_valid_screen(g_nextScreen) && g_currentScreen.screen != g_nextScreen.screen) {
        reset_scope()
        screen_resize(g_nextScreen)
        control_redock(g_nextScreen.base, mat.v4_zero)
        screen_resize(g_nextScreen)
        control_redock(g_nextScreen.base, mat.v4_zero)
    }

    var i i32 = 0
    for i = 0; i < g_modalCount; i = i + 1 {
        //control_print("before resize : ", g_modals[i].base, false)
        //printf("_-------------------------------------------------------------------------------->>>>\n")
        reset_scope()
        screen_resize(g_modals[i])
        control_redock(g_modals[i].base, mat.v4_zero)
        screen_resize(g_modals[i])
        control_redock(g_modals[i].base, mat.v4_zero)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render() () {

    //var clearColor mat.v4 = mat.v4_(1.0, 0.0, 1.0, 1.0)
    var clearColor mat.v4 = g_black
    var target_0 target_s = gfx.lock_target(app.app_width, app.app_height)
    gfx.bind_framebuffer(target_0.framebuffer)
    gfx.clear(gl.COLOR_BUFFER_BIT, clearColor)
    if (is_valid_screen(g_currentScreen)) {
        screen_render(g_currentScreen)
    }

    var target_1 target_s = gfx.lock_target(app.app_width, app.app_height)
    gfx.bind_framebuffer(target_1.framebuffer)
    gfx.clear(gl.COLOR_BUFFER_BIT, clearColor)
    if (is_valid_screen(g_nextScreen) && g_nextScreen.screen != g_currentScreen.screen) {
        screen_render(g_nextScreen)
    }

    var target_2 target_s = gfx.lock_target(app.app_width, app.app_height)
    gfx.bind_framebuffer(target_2.framebuffer)
    gfx.clear(gl.COLOR_BUFFER_BIT, clearColor)
    gfx.disable_depth()
    gfx.disable_blending()
    gfx.effect_use(gfx.g_fxTrans_0)
    gfx.effect_assign_texture(gfx.g_fxTrans_0, 0, target_0.texture.name)
    gfx.effect_assign_texture(gfx.g_fxTrans_0, 1, target_1.texture.name)
    gfx.effect_assign_float(gfx.g_fxTrans_0, 0, f64.f32(g_transitionTime / g_transitionDuration))
    gfx.render_mesh(g_fullscreenQuad)
    gfx.unlock_target(target_0)
    gfx.unlock_target(target_1)

    var i i32 = 0
    for i = 0; i < g_modalCount; i = i + 1 {
        var target target_s = gfx.lock_target(app.app_width, app.app_height)
        gfx.bind_framebuffer(target.framebuffer)
        gfx.clear(gl.COLOR_BUFFER_BIT, clearColor)
        if (is_valid_screen(g_modals[i])) {
            //control_print("modal : ", g_modals[i].base, false)
            screen_render(g_modals[i])
        }

        var target_3 target_s = gfx.lock_target(app.app_width, app.app_height)
        gfx.bind_framebuffer(target_3.framebuffer)
        gfx.clear(gl.COLOR_BUFFER_BIT, clearColor)
        gfx.disable_depth()
        gfx.disable_blending()
        gfx.effect_use(gfx.g_fxTrans_1)
        gfx.effect_assign_texture(gfx.g_fxTrans_1, 0, target_2.texture.name)
        gfx.effect_assign_texture(gfx.g_fxTrans_1, 1, target.texture.name)
        gfx.effect_assign_float(gfx.g_fxTrans_1, 0, 1.0)
        gfx.render_mesh(g_fullscreenQuad)
        gfx.unlock_target(target)
        gfx.unlock_target(target_2)
        target_2 = target_3
    }

    // ##todo fast path if no modals => render in default framebuffer 0
    gfx.bind_framebuffer(0)
    gfx.clear(gl.COLOR_BUFFER_BIT, g_black)
    gfx.disable_depth()
    gfx.disable_blending()
    gfx.effect_use(gfx.g_fxTexture)
    gfx.effect_assign_texture(gfx.g_fxTexture, 0, target_2.texture.name)
    gfx.render_mesh(g_fullscreenQuad)
    gfx.unlock_target(target_2)

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

