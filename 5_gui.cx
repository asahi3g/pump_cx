//-----------------------------------------------------------------------------
// gui
//-----------------------------------------------------------------------------
package gui

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
import "app"
import "fps"
import "gl"
import "glfw"
import "gltext"
import "gfx"
import "mat"
import "uti"

//-----------------------------------------------------------------------------
// gfx
//-----------------------------------------------------------------------------
var g_opaqueVertexColoredLines      gfx.mesh_id
var g_opaqueVertexColoredTriangles  gfx.mesh_id
var g_alphaVertexColoredLines       gfx.mesh_id
var g_alphaVertexColoredTriangles   gfx.mesh_id
var g_fullscreenQuad                gfx.mesh_id

var g_skycoinTexture gfx.texture_s
var g_USTexture gfx.texture_s
var g_JPTexture gfx.texture_s
var g_BRTexture gfx.texture_s

var g_depthStencilBuffer i32 = -1

//-----------------------------------------------------------------------------
// GUI
//-----------------------------------------------------------------------------
var GUI_INVALID     i32 =  0
var GUI_CONTROL     i32 =  1
var GUI_SCREEN      i32 =  2
var GUI_PICTURE     i32 =  3
var GUI_LABEL       i32 =  4
var GUI_PARTITION   i32 =  5
var GUI_KEYBOARD    i32 =  6
var GUI_WINDOW      i32 =  7
var GUI_GRAPH       i32 =  8
var GUI_SPLITTER    i32 =  9
var GUI_LIST        i32 = 10
var GUI_SCROLLER    i32 = 11
var GUI_LIFTER      i32 = 12
var GUI_BINDER      i32 = 13
var GUI_VECTOR      i32 = 14
var GUI_COMBO       i32 = 15

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var STATE_CLOSED    i32 = 0
var STATE_SHOWING   i32 = 1
var STATE_OPENED    i32 = 2
var STATE_CLOSING   i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var DOCK_NONE       i32 = 0
var DOCK_LEFT       i32 = 1
var DOCK_RIGHT      i32 = 2
var DOCK_TOP        i32 = 3
var DOCK_BOTTOM     i32 = 4
var DOCK_FILL       i32 = 5

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var DIALOG_NONE      i32 = 0
var DIALOG_OK        i32 = 1
var DIALOG_OK_CANCEL i32 = 2
var DIALOG_YES_NO    i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var ALIGN_NONE          i32 =  0
var ALIGN_LEFT          i32 =  1
var ALIGN_RIGHT         i32 =  2
var ALIGN_HORZ          i32 =  3
var ALIGN_BOTTOM        i32 =  4
var ALIGN_LEFT_BOTTOM   i32 =  5
var ALIGN_RIGHT_BOTTOM  i32 =  6
var ALIGN_HORZ_BOTTOM   i32 =  7
var ALIGN_TOP           i32 =  8
var ALIGN_LEFT_TOP      i32 =  9
var ALIGN_RIGHT_TOP     i32 = 10
var ALIGN_HORZ_TOP      i32 = 11
var ALIGN_VERT          i32 = 12
var ALIGN_VERT_LEFT     i32 = 13
var ALIGN_VERT_RIGHT    i32 = 14
var ALIGN_CENTER        i32 = 15

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTOSIZE_NONE   i32 = 0
var AUTOSIZE_X      i32 = 1
var AUTOSIZE_Y      i32 = 2
var AUTOSIZE        i32 = 3

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTORATIO_NONE  i32 = 0
var AUTORATIO_X     i32 = 1
var AUTORATIO_Y     i32 = 2

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var AUTOSCALE_NONE  i32 = 0
var AUTOSCALE_X     i32 = 1
var AUTOSCALE_Y     i32 = 2
var AUTOSCALE       i32 = 3


//-----------------------------------------------------------------------------
// TEMPLATE
//-----------------------------------------------------------------------------
/*type template_id struct {
    base control_id
    template i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type template_s struct {
    id template_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func template_id_(base control_id, template i32) (out template_id) {
    uti.assert_(g_templateCount < len(g_templates), "template_create : overflow") // ##1 use slice
    out.base = base
    out.template = template
    uti.assert_(is_valid_template(out), "template_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_template() (out template_id) {
    out.base = invalid_control()
    out.template = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_template(id template_id) (out bool) {
    out = id.template >= 0 && id.template < g_templateCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_templates[8] template_s
var g_templateCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func template_create(name str) (out template_id) {
    out.template = g_templateCount
    out.base = control_create_(name, GUI_TEMPLATE, g_templateCount)

    var template template_s
    g_templates[g_templateCount].id = out

    g_templateCount = g_templateCount + 1
    uti.assert_(is_valid_template(out), "create_template : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func template_process_event(id template_id, event *event_s) (out i32) {
    uti.assert_(is_valid_template(id), "template_process_event : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        out = control_process_event(id.base, event)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func template_resize(id template_id) () {
    uti.assert_(is_valid_template(id), "resize_template : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_resize(id.base)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func template_render(id template_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_template(id), "render_template : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_render(id.base, clip, stack)
    }
}*/


//-----------------------------------------------------------------------------
// FONT
//-----------------------------------------------------------------------------
type font_id struct {
    font i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type font_s struct {
    id font_id
    name str
    path str
//    range bool
//    runes []ui32
    min i32
    max i32
    direction i32
    textureCount i32
    textures [8]texture_s
    names [8]str
    sizes [8]i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_fonts [8]font_s
var g_fontCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_font()(out font_id) {
    out.font = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_font(id font_id) (out bool) {
    out = id.font >= 0 && id.font < g_fontCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_font(name str, path str, min i32, max i32, direction i32) (out font_id) {
    uti.assert_(g_fontCount < len(g_fonts), "create_font : overflow") // ##1 use slice
    out.font = g_fontCount

    var font font_s
    font.id = out
    font.min = min
    font.max = max
    font.name = name
    font.path = path

//    font.range = range
  //  font.runes = runes
    font.direction = direction
    font.textureCount = 0

    g_fonts[out.font] = font
    g_fontCount = out.font + 1
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func font_add_size(id font_id, size i32) {
    uti.assert_(is_valid_font(id), "font_add_size : invalid id")

    var index i32 = id.font

    var name str
    name = g_fonts[index].name

    var path str
    path = g_fonts[index].path

//    var range bool = g_fonts[index].range
 //   var runes []ui32 = g_fonts[index].runes
    var dir i32 = g_fonts[index].direction
    var min i32 = g_fonts[index].min
    var max i32 = g_fonts[index].max
    var textureName str
    textureName = sprintf("%s_%d", name, size)

    var textureCount i32 = g_fonts[index].textureCount
    g_fonts[index].textures[textureCount] = gfx.create_font_texture(textureName, path, size, min, max, dir)
    g_fonts[index].names[textureCount] = textureName
    g_fonts[index].sizes[textureCount] = size

    g_fonts[index].textureCount = textureCount + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func font_get_texture_index(id font_id, size i32) (out i32) {
    uti.assert_(is_valid_font(id), "font_get_texture_index : invalid id")

    var textureCount i32 = g_fonts[id.font].textureCount

    out = -1
    if (textureCount > 0) {
        out = 0
    }
    var minSize i32 = size

    var i i32 = 0
    for i= 0 ; i < textureCount; i = i + 1 {
        var fontSize i32 = g_fonts[id.font].sizes[i]
        //printf("i %d, FONT_SIZE %d, size %d, minSize %d\n", i, fontSize, size, minSize)
        if (fontSize >= size && fontSize <= minSize) {
            out = i
        }
    }

    //printf("TEXTURE_INDEX %d\n", out)
}

//-----------------------------------------------------------------------------
// SCOPE
//-----------------------------------------------------------------------------
var g_docks [32]bound_s
var g_offsets [32]rectangle_s
var g_scopeIndex i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type bound_s struct {
    left f32
    bottom f32
    right f32
    top f32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type rectangle_s struct {
    x f32
    y f32
    width f32
    height f32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_dock bound_s
var g_offset rectangle_s

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func reset_scope()() {
    uti.assert_(g_scopeIndex == 0, "invalid scope")
    g_scopeIndex = 0

    g_dock.left = 0.0
    g_dock.bottom = 0.0
    g_dock.right = gfx.gfx_width
    g_dock.top = gfx.gfx_height

    g_offset.x = 0.0
    g_offset.y = 0.0
    g_offset.width = gfx.gfx_width
    g_offset.height = gfx.gfx_height
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func push_scope()() {
    g_docks[g_scopeIndex] = g_dock
    g_offsets[g_scopeIndex] = g_offset
    g_scopeIndex = g_scopeIndex + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func pop_scope() () {
    uti.assert_(g_scopeIndex > 0, "stack underflow")
    g_scopeIndex = g_scopeIndex - 1
    g_dock = g_docks[g_scopeIndex]
    g_offset = g_offsets[g_scopeIndex]
}

//-----------------------------------------------------------------------------
// LAYER_SKIN
//-----------------------------------------------------------------------------
var g_layers [256]layer_s
var g_layerCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type layer_id struct {
    layer i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_layer() (out layer_id) {
    out.layer = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type layer_s struct {
    id layer_id
    name str
    surface     mat.v4
    left        mat.v4
    bottom      mat.v4
    right       mat.v4
    top         mat.v4
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_layer(id layer_id) (out bool) {
    out = id.layer >= 0 && id.layer < g_layerCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func layer_create(name str, surface mat.v4, left mat.v4, bottom mat.v4, right mat.v4, top mat.v4) (out layer_id) {
    uti.assert_(g_layerCount < len(g_layers), "layer_create : overflow") // ##1 use slice
    out.layer = g_layerCount

    var layer layer_s
    layer.id  = out
    layer.name    = name
    layer.surface = surface
    layer.left    = left
    layer.bottom  = bottom
    layer.right   = right
    layer.top     = top

    g_layers[out.layer] = layer
    g_layerCount = out.layer + 1
    uti.assert_(is_valid_layer(out), "layer_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func layer_print(message str, id layer_id) {
    uti.assert_(is_valid_layer(id), "layer_print : invalid id")
    var index i32 = id.layer
    printf("%s LAYER_SKIN %d - %s, SURFACE %f, %f, %f, %f, LEFT %f, %f, %f, %f, BOTTOM %f, %f, %f, %f, RIGHT %f, %f, %f, %f, TOP %f, %f, %f, %f\n",
        message,
        g_layers[index].id.layer,
        g_layers[index].name,
        g_layers[index].surface.x,
        g_layers[index].surface.y,
        g_layers[index].surface.z,
        g_layers[index].surface.w,
        g_layers[index].left.x,
        g_layers[index].left.y,
        g_layers[index].left.z,
        g_layers[index].left.w,
        g_layers[index].bottom.x,
        g_layers[index].bottom.y,
        g_layers[index].bottom.z,
        g_layers[index].bottom.w,
        g_layers[index].right.x,
        g_layers[index].right.y,
        g_layers[index].right.z,
        g_layers[index].right.w,
        g_layers[index].top.x,
        g_layers[index].top.y,
        g_layers[index].top.z,
        g_layers[index].top.w)
}

//-----------------------------------------------------------------------------
// CONTROL_SKIN
//-----------------------------------------------------------------------------
var g_skins [512]skin_s
var g_skinCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type skin_id struct {
    skin i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type skin_s struct {
    id skin_id
    name str
    back layer_id
    front layer_id
    hoverBack layer_id
    hoverFront layer_id
    disabled_back layer_id
    disabled_front layer_id
    focused_back layer_id
    focused_front layer_id
    selected_back layer_id
    selected_front layer_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_skin() (out skin_id) {
    out.skin = -1
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_skin(id skin_id) (out bool) {
    //printf("id.skin %d, %d\n", id.skin, g_skinCount)
    out = (id.skin >= 0) && (id.skin < g_skinCount)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func skin_create(name str, back layer_id, front layer_id, hoverBack layer_id, hoverFore layer_id, disabledBack layer_id, disabledFore layer_id, focusedBack layer_id, focusedFore layer_id, selectedBack layer_id, selectedFore layer_id)  (out skin_id) {
    //printf("EVENT_UNUSED %d\n", EVENT_UNUSED)
    uti.assert_(g_skinCount < len(g_skins), "skin_create : overflow") // ##1 use slice
    out.skin = g_skinCount

    var skin skin_s
    skin.name = name
    skin.id = out
    skin.back = back
    skin.front = front
    skin.hoverBack = hoverBack
    skin.hoverFront = hoverFore
    skin.disabled_back = disabledBack
    skin.disabled_front = disabledFore
    skin.focused_back = focusedBack
    skin.focused_front = focusedFore
    skin.selected_back = selectedBack
    skin.selected_front = selectedFore

    g_skins[out.skin] = skin
    g_skinCount = out.skin + 1
    uti.assert_(is_valid_skin(out), "skin_create : invalid id")
    skin_print("skin_create : ", out)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func skin_print(message str, id skin_id) {
    uti.assert_(is_valid_skin(id), "skin_print : invalid id")
    var index i32 = id.skin
    printf("%s CONTROL_SKIN %d - %s\n", message, g_skins[index].id.skin, g_skins[index].name)
    if (is_valid_layer(g_skins[index].back)) {
        layer_print("skin_print : ", g_skins[index].back)
    }
    if (is_valid_layer(g_skins[index].front)) {
        layer_print("skin_print : ", g_skins[index].front)
    }
    if (is_valid_layer(g_skins[index].hoverBack)) {
        layer_print("skin_print : ", g_skins[index].hoverBack)
    }
    if (is_valid_layer(g_skins[index].hoverFront)) {
        layer_print("skin_print : ", g_skins[index].hoverFront)
    }
    if (is_valid_layer(g_skins[index].disabled_back)) {
        layer_print("skin_print : ", g_skins[index].disabled_back)
    }
    if (is_valid_layer(g_skins[index].disabled_front)) {
        layer_print("skin_print : ", g_skins[index].disabled_front)
    }
    if (is_valid_layer(g_skins[index].focused_back)) {
        layer_print("skin_print : ", g_skins[index].focused_back)
    }
    if (is_valid_layer(g_skins[index].focused_front)) {
        layer_print("skin_print : ", g_skins[index].focused_front)
    }
    if (is_valid_layer(g_skins[index].selected_front)) {
        layer_print("skin_print : ", g_skins[index].selected_front)
    }
    if (is_valid_layer(g_skins[index].selected_front)) {
        layer_print("skin_print : ", g_skins[index].selected_front)
    }
}

//-----------------------------------------------------------------------------
// SKIN
//-----------------------------------------------------------------------------
var g_black             mat.v4 = mat.rgba_ui8( 30,  34,  39, 255)
var g_white             mat.v4 = mat.rgba_ui8(255, 251, 251, 255)
var g_blue              mat.v4 = mat.rgba_ui8(  0, 114, 255, 255)
var g_lightBlue         mat.v4 = mat.rgba_ui8(  0, 195, 255, 255)
var g_darkBlue          mat.v4 = mat.v4_mul(g_blue, mat.v4_(0.5, 0.5, 0.5, 1.0))
var g_green             mat.v4 = mat.rgba_ui8(  0, 223, 128, 255)
var g_red               mat.v4 = mat.rgba_ui8(255,   0,  78, 255)
var g_pink              mat.v4 = mat.rgba_ui8(255, 0,  0, 255)
var g_gold              mat.v4 = mat.rgba_ui8(255, 193,  37, 255)
var g_gray_0            mat.v4 = mat.rgba_ui8( 34,  38,  43, 255)
var g_gray_1            mat.v4 = mat.rgba_ui8( 41,  45,  50, 255)
var g_gray_2            mat.v4 = mat.rgba_ui8( 74,  77,  81, 255)
var g_gray_3            mat.v4 = mat.rgba_ui8(140, 142, 145, 255)
var g_gray_4            mat.v4 = mat.rgba_ui8(206, 207, 208, 255)
var g_gray_5            mat.v4 = mat.rgba_ui8(239, 240, 240, 255)
var g_gray_6            mat.v4 = mat.rgba_ui8(247, 247, 247, 255)
var g_gray_7            mat.v4 = mat.rgba_ui8(251, 251, 251, 255)

var g_black_a10 mat.v4 = mat.v4_mul(g_black, mat.v4_(0.7, 0.7, 0.7, 0.8))
var g_black_a50 mat.v4 = mat.v4_mul(g_black, mat.v4_(0.7, 0.7, 0.7, 0.8))
var g_blue_a50  mat.v4 = alpha(g_blue, 0.5)
var g_goldA50 mat.v4 = alpha(g_gold, 0.5)

var g_debugRedLayer layer_id
var g_debugGreenLayer layer_id
var g_debugBlueLayer layer_id
var g_debugGoldLayer layer_id
var g_goldLayer layer_id
var g_bootLayer layer_id
var g_blackLayer layer_id
var g_zeroBorderLayer layer_id
var g_redLayer layer_id
var g_greenLayer layer_id
var g_blueLayer layer_id
var g_hoverLayer layer_id
var g_popupLayer layer_id
var g_modalLayer layer_id
var g_headerLayer layer_id
var g_textboxLayer layer_id
var g_focusedLayer layer_id
var g_selectedLayer layer_id
var g_borderFocusedLayer layer_id
var g_stripLayer layer_id
var g_pageFocusedBack layer_id
var g_pageFocusedFront layer_id
var g_pageSelectedBack layer_id
var g_pageSelectedFront layer_id

var g_debugRedSkin skin_id
var g_debugGreenSkin skin_id
var g_debugBlueSkin skin_id
var g_debugGoldSkin skin_id
var g_bootSkin skin_id
var g_blackSkin skin_id
var g_zeroBorderSkin skin_id
var g_blackFocusedSkin skin_id
var g_grayFocusedSkin skin_id
var g_redSkin skin_id
var g_greenSkin skin_id
var g_blueSkin skin_id
var g_hoverSkin skin_id
var g_popupSkin skin_id
var g_modalSkin skin_id
var g_windowSkin skin_id
var g_headerSkin skin_id
var g_textboxSkin skin_id
var g_buttonSkin skin_id
var g_stripSkin skin_id
var g_binderPageSkin skin_id
var g_binderSkin skin_id
var g_zeroSkin skin_id

var textureLogo str = "textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png"

var g_boldFont font_id = invalid_font()
var g_regularFont font_id = invalid_font()
var g_awesomeBoldFont font_id = invalid_font()

var g_padding mat.v4 = mat.v4_(3.0, 3.0, 3.0, 3.0)
var g_spacing_x mat.v2 = mat.v2_(0.0, 3.0)
var g_spacing_y mat.v2 = mat.v2_(3.0, 0.0)
var g_spacing mat.v2 = mat.v2_(3.0, 3.0)

var g_fontSizeTitle i32 = 64
var g_fontSizeHeader i32 = 35
var g_fontSizeButton i32 = 30
var g_fontSizeText i32 = 25
var g_fontSizeSmall i32 = 20
func alpha(color mat.v4, a f32) (out mat.v4) {
    //out = mat.v4_(color.x, color.y, color.z, (color.w * a)) // ##issue_57  out.w == 0
    out.x = color.x
    out.y = color.y
    out.z = color.z
    out.w = color.w * a
}

//-----------------------------------------------------------------------------
// CONTROL
//-----------------------------------------------------------------------------
var g_controls [2048]control_s
var g_controlCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_id struct {
    control i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_s struct {
    id control_id
    name str
    gui_type i32
    gui_index i32

    skin skin_id
    parent control_id

    visible i32

    focusIndex i32
    focusable i32
    focused i32
    childFocused i32
    selected i32

    dock i32
    align i32
    autosize i32
    autoscale i32

    position mat.v2
    size mat.v2
    scale mat.v2
    padding mat.v4
    spacing mat.v2

    renderPosition mat.v2
    children [256]control_id // can't make it work with slices
    childCount i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_parent_visible(id control_id) (out bool) {
    uti.assert_(is_valid_control(id), "control_parent_visible : invalid id")
    var visible i32 = g_controls[id.control].visible
    if (visible <= 0) {
        out = false
    } else {
        out = true
        var parent control_id = g_controls[id.control].parent
        if (is_valid_control(parent)) {
            out = control_parent_visible(parent)
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_cursorPos mat.v2

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_hovered(id control_id) (out i32) {
    uti.assert_(is_valid_control(id), "invalid id")
    out = 0

    var position mat.v2 = g_controls[id.control].renderPosition
    var size mat.v2 = g_controls[id.control].size

    var left f32 = position.x
    var right f32 = left + size.x
    var bottom f32 = position.y
    var top f32 = bottom + size.y
    if (g_cursorPos.x >= left && g_cursorPos.x <= right &&
        g_cursorPos.y >= bottom && g_cursorPos.y <= top) {
        out = 1
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_focused(id control_id) (out i32) { // ##pending issue bool
    out = 0
    uti.assert_(is_valid_control(id), "control_focused : invalid id")
    var focused i32 = g_controls[id.control].focused
    if (focused > 0) {
        out = focused
    }

    var childFocused i32 = g_controls[id.control].childFocused
    if (childFocused > 0) {
        out = childFocused
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_control() (out control_id) {
    out.control = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_id_(control i32) (out control_id) {
    out.control = control
    uti.assert_(is_valid_control(out), "control_id_ : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_control(id control_id) (out bool) {
    //printf("control : %d, %d\n", id.control, g_controlCount)
    out = id.control >= 0 && id.control < g_controlCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_create(name str) (out control_id) {
    out = control_create_(name, GUI_CONTROL, g_controlCount)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_create_(name str, gui_type i32, gui_index i32) (out control_id) {
    uti.assert_(g_controlCount < len(g_controls), "control_create : overflow") // ##1 use slice
    out.control = g_controlCount

    g_controls[g_controlCount].id = out
    g_controls[g_controlCount].parent = invalid_control()
    g_controls[g_controlCount].name = name
    g_controls[g_controlCount].gui_type  = gui_type
    g_controls[g_controlCount].gui_index = gui_index

    g_controls[g_controlCount].skin = invalid_skin()

    g_controls[g_controlCount].focusIndex = -1
    g_controls[g_controlCount].focusable = 0
    g_controls[g_controlCount].focused = 0

    g_controls[g_controlCount].visible = 1

    g_controls[g_controlCount].dock      = DOCK_NONE
    g_controls[g_controlCount].align     = ALIGN_NONE
    g_controls[g_controlCount].autosize  = AUTOSIZE_NONE
    g_controls[g_controlCount].autoscale = AUTOSCALE_NONE

    g_controls[g_controlCount].position = mat.v2_zero
    g_controls[g_controlCount].size     = mat.v2_zero
    g_controls[g_controlCount].scale    = mat.v2_one
    g_controls[g_controlCount].padding  = mat.v4_zero
    g_controls[g_controlCount].spacing  = mat.v2_zero

    g_controls[g_controlCount].childCount = 0
    g_controlCount = g_controlCount + 1
    uti.assert_(is_valid_control(out), "control_create : invalid control")
    control_print("control_create : ", out, true)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_print(message str, id control_id, printSkin bool) {
    uti.assert_(is_valid_control(id), "control_print : invalid control")
    var index i32 = id.control
    //if (index == 29 || index == 30) {
    printf("%s - %d - %s, Type %d, Index %d, Focusable %d, Focusindex %d, Focused %d, ChildFocused %d, Selected %d, Visible %d, Skin %d, Dock %d, Align %d, Autosize %d, Autoscale %d, Padding %f, %f, %f, %f, Position %f, %f, RenderPosition %f, %f, Size %f, %f, Scale %f, %f, Children %d\n",
        message,
        g_controls[index].id.control,
        g_controls[index].name,
        g_controls[index].gui_type,
        g_controls[index].gui_index,
        g_controls[index].focusable,
        g_controls[index].focusIndex,
        g_controls[index].focused,
        g_controls[index].childFocused,
        g_controls[index].selected,
        g_controls[index].visible,
        g_controls[index].skin.skin,
        g_controls[index].dock,
        g_controls[index].align,
        g_controls[index].autosize,
        g_controls[index].autoscale,
        g_controls[index].padding.x,
        g_controls[index].padding.y,
        g_controls[index].padding.z,
        g_controls[index].padding.w,
        g_controls[index].position.x,
        g_controls[index].position.y,
        g_controls[index].renderPosition.x,
        g_controls[index].renderPosition.y,
        g_controls[index].size.x,
        g_controls[index].size.y,
        g_controls[index].scale.x,
        g_controls[index].scale.y,
        g_controls[index].childCount)

    if (printSkin == true && is_valid_skin(g_controls[index].skin)) {
        skin_print("control_print : ", g_controls[index].skin)
    }
    //}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_skin(id control_id, skin skin_id) {
    uti.assert_(is_valid_control(id)   , "control_set_skin : invalid id")
    uti.assert_(is_valid_skin(skin), "control_set_skin : invalid skin")
    g_controls[id.control].skin = skin
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_dock(id control_id, dock i32) {
    uti.assert_(is_valid_control(id), "control_set_dock : invalid id")
    g_controls[id.control].dock = dock
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_align(id control_id, align i32) {
    uti.assert_(is_valid_control(id), "control_set_align : invalid id")
    g_controls[id.control].align = align
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_autosize(id control_id, autosize i32) {
    uti.assert_(is_valid_control(id), "control_set_autosize : invalid id")
    g_controls[id.control].autosize = autosize
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_autoscale(id control_id, autoscale i32) {
    uti.assert_(is_valid_control(id), "control_set_autoscale : invalid id")
    g_controls[id.control].autoscale = autoscale
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_position(id control_id, position v2) {
    uti.assert_(is_valid_control(id), "control_set_position : invalid id")
    g_controls[id.control].position = position
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_size(id control_id, size v2) {
    uti.assert_(is_valid_control(id), "control_set_size : invalid id")
    g_controls[id.control].size = size
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_bounds(id control_id, bounds v4) {
    uti.assert_(is_valid_control(id), "control_set_bounds : invalid id")
    g_controls[id.control].position = mat.v4_xy(bounds)
    g_controls[id.control].size = mat.v4_zw(bounds)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_scale(id control_id, scale v2) {
    uti.assert_(is_valid_control(id), "control_set_scale : invalid id")
    g_controls[id.control].scale = scale
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_visible(id control_id, visible i32) {
    uti.assert_(is_valid_control(id), "control_set_visible : invalid id")
    g_controls[id.control].visible = visible
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_selected(id control_id, selected i32) {
    uti.assert_(is_valid_control(id), "control_set_selected : invalid id")
    g_controls[id.control].selected = selected
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_add_child(parent control_id, child control_id) {
    uti.assert_(is_valid_control(parent), "control_add_child : invalid parent")
    uti.assert_(is_valid_control(child), "control_add_child : invalid child")
    var count i32 = g_controls[parent.control].childCount
    var size i32 = len(g_controls[parent.control].children)
    uti.assert_(count < size, "control_add_child : overflow") // ##1 use slice
    g_controls[child.control].focusIndex = count
    g_controls[child.control].parent = parent
    g_controls[parent.control].children[count] = child
    g_controls[parent.control].childCount = count + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_clear_children(id control_id) {
    uti.assert_(is_valid_control(id), "control_clear_children : invalid id")
    var controlIndex i32 = id.control
    g_controls[controlIndex].childCount = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_padding(id control_id, padding mat.v4) {
    uti.assert_(is_valid_control(id), "control_set_padding : invalid id")
    g_controls[id.control].padding = padding // ##1 id viewport resize
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_spacing(id control_id, spacing mat.v2) {
    uti.assert_(is_valid_control(id), "control_set_spacing : invalid id")
    g_controls[id.control].spacing = mat.v2_mul(spacing, mat.v2_(1.0, gfx.gfx_ratio_y)) // ##1 id viewport resize
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_focus_index(id control_id, value i32) {
    uti.assert_(is_valid_control(id), "control_set_focus_index : invalid id")
    g_controls[id.control].focusIndex = value
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_focusable(id control_id, value i32) {
    uti.assert_(is_valid_control(id), "control_set_focusable : invalid id")
    g_controls[id.control].focusable = value
    //control_print("SET_FOCUSABLE : ", id, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_set_parent_focus(id control_id, child control_id, value i32) {
    //printf("set_parent_focus : %d\n", id.control)
    uti.assert_(is_valid_control(id), "control_set_parent_focus : invalid id")
    var parent control_id = g_controls[id.control].parent
    if (is_valid_control(parent)) {
        g_controls[parent.control].childFocused = value
        control_set_parent_focus(parent, child, value)

        var guiType i32 = g_controls[parent.control].gui_type
        var guiIndex i32 = g_controls[parent.control].gui_index

        if (guiType == GUI_INVALID) {
            uti.assert_(false, "invalid gui type (GUI_INVALID)")
        } else if (guiType == GUI_CONTROL) {
            var dummy i32 = 0
        } else if (guiType == GUI_SCREEN) {
            var dummy i32 = 0
        } else if (guiType == GUI_PICTURE) {
            var dummy i32 = 0
        } else if (guiType == GUI_LABEL) {
            var dummy i32 = 0
        } else if (guiType == GUI_PARTITION) {
            var dummy i32 = 0
        } else if (guiType == GUI_KEYBOARD) {
            var dummy i32 = 0
        } else if (guiType == GUI_WINDOW) {
            var dummy i32 = 0
        } else if (guiType == GUI_GRAPH) {
            var dummy i32 = 0
        } else if (guiType == GUI_SPLITTER) {
            var dummy i32 = 0
        } else if (guiType == GUI_LIST) {
            list_child_focused(list_id_(parent, guiIndex), child, value)
        } else if (guiType == GUI_SCROLLER) {
            var dummy i32 = 0
        } else if (guiType == GUI_LIFTER) {
            var dummy i32 = 0
        } else if (guiType == GUI_BINDER) {
            var dummy i32 = 0
        } else if (guiType == GUI_VECTOR) {
            var dummy i32 = 0
        } else if (guiType == GUI_COMBO) {
            var dummy i32 = 0
        } else {
            printf("GUI TYPE %d\n", guiType)
            uti.assert_(false, "control_resize : unknown gui type")
        }

        //control_print("control_set_parent_focus : ", parent, false)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*func control_set_parent_select(id control_id, value i32) {
    //printf("set_parent_focus : %d\n", id.control)
    uti.assert_(is_valid_control(id), "control_set_parent_focus : invalid id")
    var parent control_id = g_controls[id.control].parent
    if (is_valid_control(parent)) {
        g_controls[parent.control].childSelected = value
        control_set_parent_select(parent, value)
    }
}*/

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type control_pair_s struct {
    key screen_id
    value control_id
    focusList [128]control_id
    focusCount i32
    currentFocus i32
}

var g_focused[64]control_pair_s
var g_focusedCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type focus_s struct {
    focusIndex i32
    control control_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func build_focus_list(focusedScreenIndex i32, parent control_id) {
    uti.assert_(is_valid_control(parent), "build_focus_list : invalid parent")
    //control_print("build_focus_list : ", parent, false)
    var index i32 = parent.control

    var unsortedList [64]focus_s
    var unsortedCount i32 = 0

    var i i32 = 0
    var childCount i32 = g_controls[index].childCount
    for i = 0; i < childCount; i = i + 1 {
        var child control_id = g_controls[index].children[i]
        uti.assert_(is_valid_control(child), "build_focus_list : invalid child")
        var childIndex i32 = child.control
        var focusIndex i32 = g_controls[childIndex].focusIndex
        if (focusIndex >= 0) {
                //control_print("FOCUSABLE : ", child, false)
                unsortedList[unsortedCount].focusIndex = focusIndex
                unsortedList[unsortedCount].control = child
                unsortedCount = unsortedCount + 1
            //}
        }
    }

    //printf("UNORDERED COUNT %d\n", unsortedCount)
    //sort
    var unsorted i32 = 0
    for unsorted = 0; unsorted < unsortedCount; unsorted = unsorted + 1 {
        var focusCount i32 = g_focused[focusedScreenIndex].focusCount
        var focusIndex i32 = unsortedList[unsorted].focusIndex
        var focusControl control_id = unsortedList[unsorted].control
    }

    //printf("SORTING\n")
    //sort
    i = 0
    var backUp i32 = 0
    for (i + 1 < unsortedCount) {
        var nextUnsorted i32 = i + 1
        var currentFocusIndex i32 = unsortedList[i].focusIndex
        var nextFocusIndex i32 = unsortedList[nextUnsorted].focusIndex
        var currentControl control_id = unsortedList[i].control
        var nextControl control_id = unsortedList[nextUnsorted].control
        if (currentFocusIndex > nextFocusIndex) {
            unsortedList[nextUnsorted].control = currentControl
            unsortedList[nextUnsorted].focusIndex = currentFocusIndex
            unsortedList[i].control = nextControl
            unsortedList[i].focusIndex = nextFocusIndex
            i = 0 // ##0 better sort...
        } else {
            backUp = i
            i = i + 1
        }
    }


    var sorted i32 = 0;
    for sorted = 0; sorted < unsortedCount; sorted = sorted + 1 {
        var focusCount i32 = g_focused[focusedScreenIndex].focusCount
        //printf("BUILD_SORTED INDEX %d, %d, FOCUS_COUNT %d\n", sorted, unsortedList[sorted].control.control, focusCount)
        var control control_id = unsortedList[sorted].control
        var focusable i32 = g_controls[control.control].focusable
        build_focus_list(focusedScreenIndex, control)
        if (focusable > 0) {
            g_focused[focusedScreenIndex].focusList[focusCount] = control
            focusCount = focusCount + 1
            g_focused[focusedScreenIndex].focusCount = focusCount
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func rebuild_focus(id screen_id) {
    uti.assert_(is_valid_screen(id), "rebuild_focus : invalid id")
    //control_print("rebuild_focus : ", id.base, false)
    var i i32 = 0

    var lookup screen_id = invalid_screen()
    var lookupIndex i32 = -1
    for i = 0; i < g_focusedCount; i = i + 1 {
        var key screen_id = g_focused[i].key
        if (key.screen == id.screen) {
            printf("LOOKUP FOUND %d\n", i)
            lookup = key
            lookupIndex = i
            i = g_focusedCount // ##pending issue break
        }
    }

    var oldFocusIndex i32 = -1
    var oldFocusCount i32 = 0
    var oldFocus control_id = invalid_control()
    var remove i32 = 0
    if (is_valid_screen(lookup)) {
        //printf("VALID LOOKUP SCREEN\n")
            oldFocusIndex = g_focused[lookupIndex].currentFocus
            oldFocusCount = g_focused[lookupIndex].focusCount
            oldFocus = invalid_control()
         //   printf("oldFocusIndex %d, oldFocusCount %d\n", oldFocusIndex, oldFocusCount)
            if (oldFocusIndex >= 0 && oldFocusIndex < oldFocusCount) {
                oldFocus = g_focused[lookupIndex].focusList[oldFocusIndex]
                printf("REMOVE TRUE\n")
                remove = 1
            }
    } else {
        lookup = id
        lookupIndex = g_focusedCount
        g_focused[lookupIndex].key = lookup
        g_focusedCount = g_focusedCount + 1
    }

//    printf("lookup %d, %d, id %d, %d\n", lookup.screen, lookup.base.control, id.screen, id.base.control)
    uti.assert_(lookup.base.control == id.base.control, "rebuild_focus : internal error")

  //  printf("HERE %d\n", lookupIndex)
    g_focused[lookupIndex].currentFocus = -1
    //printf("HERE %d\n", lookupIndex)
    g_focused[lookupIndex].focusCount = 0
    //printf("---------------------------> BEFORE BUILD_FOCUS_LIST %d, %d\n", lookupIndex, g_focused[lookupIndex].focusCount)
    build_focus_list(lookupIndex, lookup.base)
    //printf("---------------------------> AFTER BUILD_FOCUS_LIST %d, %d\n", lookupIndex, g_focused[lookupIndex].focusCount)

    var newFocusIndex i32 = -1
    var newFocus control_id = invalid_control()
    var newFocusCount i32 = g_focused[lookupIndex].focusCount
    if (is_valid_control(oldFocus)) {
        newFocusIndex = oldFocusIndex
        newFocus = oldFocus
      //  printf("RESTORING OLD FOCUS %d\n", oldFocusIndex)
        //control_print("RESTORING OLD FOCUS : ", newFocus, false)
    } else if (newFocusCount > 0) {
        newFocusIndex = 0
        newFocus = g_focused[lookupIndex].focusList[0]
        printf("NEW FOCUS %d\n", newFocusIndex)
        //control_print("NEW FOCUS : ", newFocus, false)
    }

    set_current_focus(lookup, lookupIndex, newFocus, newFocusIndex, remove)
    var focus i32 = 0
    var focusCount i32 = g_focused[lookupIndex].focusCount
    //control_print("---- rebuild_focus : ", id.base, false)
    for focus = 0; focus < focusCount; focus = focus + 1 {
        var focused control_id = g_focused[lookupIndex].focusList[focus]
        //control_print("-------- rebuild_focus : ", focused, false)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func set_current_focus(key screen_id, screenIndex i32, value control_id, controlIndex i32, remove i32) {
    uti.assert_(is_valid_screen(key), "set_current_focus : invalid key")

    var currentFocus i32 = g_focused[screenIndex].currentFocus
    var focusCount i32 = g_focused[screenIndex].focusCount
    printf("REMOVE REMOVE %d\n", remove)
    if (currentFocus >= 0 && currentFocus < focusCount) {
        if (remove > 0) {
        var focusId control_id = g_focused[screenIndex].focusList[currentFocus]
        uti.assert_(is_valid_control(focusId), "set_current_focus : invalid current id")
        g_controls[focusId.control].focused = 0
        control_print("remove_focus : ", focusId, false)
        control_set_parent_focus(focusId, focusId, 0)
        }
    }

    if (is_valid_control(value)) {
        var visible i32 = g_controls[value.control].visible
        uti.assert_(visible > 0, "focused not implemented")
        g_focused[screenIndex].key = key
        g_focused[screenIndex].value = value
        g_focused[screenIndex].currentFocus = controlIndex
        g_controls[value.control].focused = 1
        control_set_parent_focus(value, value, 1)
        control_print("set_current_focus : ", value, false)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func force_focus(id control_id) {
    if (is_valid_screen(g_hotScreen) && is_valid_control(id)) {
        //printf("FORCE_FOCUS_0\n")
        var screenPair i32 = get_focus_pair(g_hotScreen)
        var currentFocus i32 = g_focused[screenPair].currentFocus
        var focusCount i32 = g_focused[screenPair].focusCount
        if (focusCount > 0 && currentFocus >= 0 && currentFocus < focusCount) {
            var i i32 = 0
       //printf("FORCE_FOCUS_1\n")
            for i = 0; i < focusCount; i = i + 1 {
                var focusedId control_id = g_focused[screenPair].focusList[i]
                //printf("test_focus %d, %d\n", focusedId.control, id.control)
                if (focusedId.control == id.control) {
        //printf("FORCE_FOCUS_2\n")
                    set_current_focus(g_hotScreen, screenPair, id, i, 1)
                    i = focusCount
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func get_focus_pair(id screen_id) (out i32) {
    out = -1
    uti.assert_(is_valid_screen(id), "get_focus_pair: invalid id")
    //control_print("get_focus_pair : ", id.base, false)
    var i i32 = 0
    for i = 0; i < g_focusedCount; i = i + 1 {
        var key screen_id = g_focused[i].key
        if (key.screen == id.screen) {
            out = i
            i = g_focusedCount // ##pending issue break
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func set_next_focus(id screen_id) {
    uti.assert_(is_valid_screen(id), "screen_next_focus : invalid id")
    control_print("set_next_focus : ", id.base, false)
    var pair i32 = get_focus_pair(id)
    if (pair >= 0 && pair < g_focusedCount) {
        var current i32 = g_focused[pair].currentFocus
        var count i32 = g_focused[pair].focusCount
        var next i32 = current
        var nextId control_id = invalid_control()
        var i i32 = 0
        for i = 0; i < count; i = i + 1 {
            next = (next + 1) % count
            var controlId control_id = g_focused[pair].focusList[next]
            var visible i32 = control_parent_visible(controlId)
            if (visible > 0) {
                i = count
                nextId = controlId
            }
            //printf("NEXT_FOCUS %d/%d\n", next, count)
        }
        set_current_focus(id,  pair, nextId, next, 1)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func set_previous_focus(id screen_id) {
    uti.assert_(is_valid_screen(id), "screen_previous_focus : invalid id")
    control_print("set_previous_focus : ", id.base, false)
    var pair i32 = get_focus_pair(id)
    if (pair >= 0 && pair < g_focusedCount) {
        var current i32 = g_focused[pair].currentFocus
        var count i32 = g_focused[pair].focusCount
        var previous i32 = current
        var previousId control_id = invalid_control()
        var i i32 = 0
        for i = 0; i < count; i = i + 1 {
            previous = previous - 1
            if (previous < 0) {
                previous = count - 1
                //printf("PREVIOUS_FOCUS %d/%d\n", previous, count)
            }
            var controlId control_id  = g_focused[pair].focusList[previous]
            var visible i32 = control_parent_visible(controlId)
            if (visible > 0) {
                i = count
                previousId = controlId
            }
        }

        set_current_focus(id, pair, previousId, previous, 1)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*func control_activate(id control_id) {
    uti.assert_(is_valid_control(id), "control_activate : invalid id")
    control_print("control_activate : ", id, false)

    var index i32 = id.control
    var guiType i32 = g_controls[index].gui_type
    if (guiType == GUI_WINDOW) {
        var guiIndex i32 = g_controls[index].gui_index
        control_print("window found : ", id, false)
        var windowId window_id = window_id_(control_id_(index), guiIndex)
        uti.assert_(is_valid_window(windowId), "control_activate : invalid window id")
        rebuild_focus(windowId)
    } else {
        var focusIndex i32 = g_controls[index].focusIndex
        if (focusIndex >= 0) {
            var i i32 = 0
            var count i32 = g_controls[index].childCount
            for i = 0; i < count; i = i + 1 {
                control_activate(g_controls[index].children[i])
            }
        }
    }
}*/

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func get_current_focus(id control_id) (out control_id) {
    /*out = invalid_control()

    var i i32 = 0
    for i = 0; i < g_focusedCount; i = i + 1 {
        if (g_focused[i].key.control == id.control) {
            var currrentFocus i32 = g_focused[i].currentFocus
            out = g_focused[i].focusedList[currentFocus]
        }
    }*/





    /*uti.assert_(is_valid_control(id), "control_focus : invalid id")
    control_print("control_focus : ", id, false)

    var index i32 = id.control
    var focusIndex i32 = g_controls[index].focusIndex

    if (focusIndex >= 0) {
        //control_print("IS_FOCUSABLE ? ", id, false)
        var focusable i32 = g_controls[index].focusable
        if (focusable > 0) {
            //control_print("YES_FOCUSABLE ? ", id, false)
            out = id
            //control_print("control_0 : ", out, false)
        } else {
            //out = invalid_control()
            //control_print("NO_FOCUSABLE ! ", out, false)
            //printf("out %d\n", out.control)
            //var toto control_id
            //toto = invalid_control()
            //control_print("FUCK ", toto, false)
            var i i32 = 0
            var count i32 = g_controls[index].childCount
            for i = 0; i < count; i = i + 1 {
                //printf("i %d/%d\n", i + 1, count)
                var child control_id = g_controls[index].children[i]
                //control_print("child : ", child, false)
                var focused control_id = control_focus(child)
                if (is_valid_control(focused)) {
                    i = count
                    out = focused
                    //control_print("control_8 : ", out, false)
                }
            }
        }
    }*/
    //out = invalid_control()
    //control_print("control_9 : ", out, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_resize(id control_id) () {
    uti.assert_(is_valid_control(id), "control_resize : invalid id")
    var visible i32 = g_controls[id.control].visible
    if (visible > 0) {
        var pixelBounds mat.v2 = g_controls[id.control].size
        //var pixelBounds mat.v2 = mat.v2_mul(bounds, gfx.gfx_viewport_size)
        control_resize_(id, pixelBounds, mat.v2_zero)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_measure(id control_id) (width f32, height f32) {
    uti.assert_(is_valid_control(id), "control_resize : invalid id")

    var index i32 = id.control

    var guiType i32 = g_controls[index].gui_type
    var guiIndex i32 = g_controls[index].gui_index

    width = -1.0
    height = -1.0
    if (guiType == GUI_INVALID) {
        uti.assert_(false, "invalid gui type (GUI_INVALID)")
    } else if (guiType == GUI_CONTROL) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_SCREEN) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_PICTURE) {
        width, height = picture_measure(picture_id_(id, guiIndex))
    } else if (guiType == GUI_LABEL) {
        width, height = label_measure(label_id_(id, guiIndex))
    } else if (guiType == GUI_PARTITION) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_KEYBOARD) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_WINDOW) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_GRAPH) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_SPLITTER) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_LIST) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_SCROLLER) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_LIFTER) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_BINDER) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_VECTOR) {
        uti.assert_(false, "not implemented")
    } else if (guiType == GUI_COMBO) {
        uti.assert_(false, "not implemented")
    } else {
        printf("GUI TYPE %d\n", guiType)
        uti.assert_(false, "control_resize : unknown gui type")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_resize_(id control_id, pixelBounds mat.v2, autoBounds mat.v2) () {
    uti.assert_(is_valid_control(id), "control_resize : invalid id")
    var visible i32 = g_controls[id.control].visible
    if (visible > 0) {
    //control_print("begin_control_resize : ", id, false)
    //printf("pixelBounds %f, %f, bounds %f, %f, autoBounds %f, %f\n", pixelBounds.x, pixelBounds.y, bounds.x, bounds.y, autoBounds.x, autoBounds.y)

    var index i32 = id.control

    var dock i32 = g_controls[index].dock
    var autoscale i32 = g_controls[index].autoscale
    var scale mat.v2 = g_controls[index].scale
    var autosize i32 = g_controls[index].autosize

    var padding mat.v4 = g_controls[index].padding
    var newWidth f32 = g_controls[index].size.x
    var newHeight f32 = g_controls[index].size.y

    var paddingLeft f32 = padding.x
    var paddingBottom f32 = padding.y
    var paddingRight f32 = padding.z
    var paddingTop f32 = padding.w
    var paddingX f32 = paddingLeft + paddingRight
    var paddingY f32 = paddingBottom + paddingTop
    var maxWidth f32 = 0.0
    var maxHeight f32 = 0.0

    /*if (autosize == AUTOSIZE) {
        control_print("AUTOSIZE : ", id, false)
    }*/


    var minX f32 = mat.FLOAT_MAX
    var minY f32 = mat.FLOAT_MAX

    var maxX f32 = mat.FLOAT_MIN
    var maxY f32 = mat.FLOAT_MIN

    var count i32 = g_controls[index].childCount
    for i := 0; i < count; i = i + 1 {
        var child control_id = g_controls[index].children[i]
        var childIndex i32 = child.control
        uti.assert_(is_valid_control(child), "control_resize : invalid child control")
        var childVisible i32 = g_controls[child.control].visible
        if (childVisible > 0) {
            var guiType i32 = g_controls[childIndex].gui_type
            var guiIndex i32 = g_controls[childIndex].gui_index

            if (guiType == GUI_INVALID) {
               uti.assert_(false, "invalid gui type (GUI_INVALID)")
            } else if (guiType == GUI_CONTROL) {
                uti.assert_(guiIndex == childIndex, "unexpected error")
                control_resize(control_id_(guiIndex))
            } else if (guiType == GUI_SCREEN) {
                uti.assert_(false, "unidd recursive screen")
            } else if (guiType == GUI_PICTURE) {
                picture_resize(picture_id_(child, guiIndex))
            } else if (guiType == GUI_LABEL) {
                label_resize(label_id_(child, guiIndex))
            } else if (guiType == GUI_PARTITION) {
                partition_resize(partition_id_(child, guiIndex))
            } else if (guiType == GUI_KEYBOARD) {
                keyboard_resize(keyboard_id_(child, guiIndex))
            } else if (guiType == GUI_WINDOW) {
                window_resize(window_id_(child, guiIndex))
            } else if (guiType == GUI_GRAPH) {
                graph_resize(graph_id_(child, guiIndex))
            } else if (guiType == GUI_SPLITTER) {
                splitter_resize(splitter_id_(child, guiIndex))
            } else if (guiType == GUI_LIST) {
                list_resize(list_id_(child, guiIndex))
            } else if (guiType == GUI_SCROLLER) {
                scroller_resize(scroller_id_(child, guiIndex))
            } else if (guiType == GUI_LIFTER) {
                lifter_resize(lifter_id_(child, guiIndex))
            } else if (guiType == GUI_BINDER) {
                binder_resize(binder_id_(child, guiIndex))
            } else if (guiType == GUI_VECTOR) {
                vector_resize(vector_id_(child, guiIndex))
            } else if (guiType == GUI_COMBO) {
                combo_resize(combo_id_(child, guiIndex))
            } else {
                printf("GUI TYPE %d\n", guiType)
                uti.assert_(false, "control_resize : unknown gui type")
            }

            var position mat.v2 = g_controls[child.control].renderPosition
            var size mat.v2 = g_controls[child.control].size

            maxWidth = mat.max(maxWidth, size.x)
            maxHeight = mat.max(maxHeight, size.y)

            minX = mat.min(minX, position.x)
            minY = mat.min(minY, position.y)
            maxX = mat.max(maxX, position.x + size.x)
            maxY = mat.max(maxY, position.y + size.y)

            /*if (index == 36) {
                control_print("control_resize child ", child, false)
                printf("%s, %d/%d : MAXWIDTH %f, MAXHEIGHT %f, POSX %f, POSY %f, SIZEX %f, SIZEY %f\n",
                    g_controls[child.control].name, i + 1, count, maxWidth, maxHeight,
                    position.x, position.y, size.x, size.y)
            }*/
        }
    }


    maxWidth = maxX - minX
    maxHeight = maxY - minY
    /*if (index == 36) {
        printf("MINY %f, MAXY %f, MAXHEIGHT %f, PADDINGY %f\n", minY, maxY, maxHeight, paddingY)
    }*/
    if (autosize == AUTOSIZE || autosize == AUTOSIZE_X || autosize == AUTOSIZE_Y) {
        if ((autosize & AUTOSIZE_X) == AUTOSIZE_X) {
            //uti.assert_(dock == DOCK_NONE || dock == DOCK_LEFT || dock == DOCK_RIGHT, "AUTOSIZE_X is not compatible with DOCK_Y")
            uti.assert_((autoscale & AUTOSCALE_X) == 0, "AUTOSIZE_X is not compatible with AUTOSCALE_X")
            newWidth = mat.max(maxWidth + paddingX, autoBounds.x)// - paddingX
            //if (index == 36) {
            //    printf("NEW_WIDTH %f, MAX_WIDTH %f, AUTO_BOUNDS_X %f, PADDING %f\n", newWidth, maxWidth, autoBounds.x, paddingX)
            //}
        }
        if ((autosize & AUTOSIZE_Y) == AUTOSIZE_Y) {
            //uti.assert_(dock == DOCK_NONE || dock == DOCK_BOTTOM || dock == DOCK_TOP, "AUTOSIZE_Y is not compatible with DOCK_X")
            uti.assert_((autoscale & AUTOSCALE_Y) == 0, "AUTOSIZE_Y is not compatible with AUTOSCALE_Y")
            newHeight = mat.max(maxHeight +  paddingY, autoBounds.y)// - paddingY
            /*if (index == 36) {
                printf("NEW_HEIGHT %f, AUTO_BOUNDS_Y %f\n", maxHeight, autoBounds.y)
            }*/
        }

        g_controls[index].size = mat.v2_(newWidth, newHeight)
        //control_print("NEW_SIZE : ", id, false)
    } else {
        uti.assert_(autosize == AUTOSIZE_NONE, "invalid AUTOSIZE value")
    }

    if (autoscale == AUTOSCALE || autoscale == AUTOSCALE_X || autoscale == AUTOSCALE_Y) {
        if (autoBounds.x > 0 && autoBounds.y > 0) {
            //control_print("AUTOSCALE : ", id, false)
            //printf("scale %f, %f, newWidth %f, newHeight %f, autoBounds %f, %f\n", scale.x, scale.y, newWidth, newHeight, autoBounds.x, autoBounds.y)
            var scaleW f32 = scale.x
            var scaleH f32 = scale.y
            if ((autoscale & AUTOSCALE_X) == AUTOSCALE_X) {
                uti.assert_((autosize & AUTOSIZE_X) == 0, "AUTOSCALE_X is not compatible with AUTOSIZE_X")
                scaleW = newWidth / autoBounds.x
            }

            if ((autoscale & AUTOSCALE_Y) == AUTOSCALE_Y) {
                uti.assert_((autosize & AUTOSIZE_Y) == 0, "AUTOSCALE_Y is not compatible with AUTOSCALE_Y")
                    scaleH = newHeight / autoBounds.y
            }

            if (autoscale == AUTOSCALE) {
                if (scaleW < scaleH) {
                    scaleH = scaleW
                    var newScale mat.v2 = mat.v2_(scaleW, scaleH/* / gfx.gfx_ratio_y*/)
                    g_controls[index].scale = newScale
                    //control_print("after_pop", id, false)

                } else {
                    scaleW = scaleH
                    var newScale mat.v2 = mat.v2_(scaleW/* * gfx.gfx_ratio_x*/, scaleH)
                    g_controls[index].scale = newScale
                }
            } else {
                var newScale mat.v2 = mat.v2_(scaleW, scaleH)
                g_controls[index].scale = newScale
            }
        }
    } else {
        uti.assert_(autoscale == AUTOSCALE_NONE, "invalid AUTOSCALE value")
    }

    /*if (id.control == 36) {
        control_print("end_control_resize", id, false)
    }*/
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func align_control(id control_id, align i32, posx f32, posy f32, width f32, height f32, contX f32, contY f32, contW f32, contH f32, padding mat.v4) (x f32, y f32) {
    x = posx
        y = posy

        if (align == ALIGN_CENTER) {
            x = contX + (contW - width) / 2.0
                y = contY + (contH - height) / 2.0
                /*if (id.control == 57) {
                control_print("align_center : ", id, false)
                  printf("ALIGN_CENTER CONTX %f, CONTY %f, CONTW %f, CONTH %f, WIDTH %f, HEIGHT %f OFFSET X %f, OFFSET Y %f\n", contX, contY, contW, contH, width, height, x, y)
                  }*/
        } else if (align == ALIGN_HORZ_BOTTOM) {
            x = contX + (contW - width) / 2.0
                y = contY + padding.y
                //control_print(index, "ALIGN_HORZ_BOTTOM : ")
        } else if (align == ALIGN_HORZ_TOP) {
            uti.assert_(false, "ALIGN_HORZ_TOP not implemented")
        } else if (align == ALIGN_VERT_LEFT) {
            uti.assert_(false, "ALIGN_VERT_LEFT not implemented")
        } else if (align == ALIGN_VERT_RIGHT) {
            uti.assert_(false, "ALIGN_VERT_RIGHT not implemented")
        } else if (align == ALIGN_LEFT_BOTTOM) {
            uti.assert_(false, "ALIGN_LEFT_BOTTOM not implemented")
        } else if (align == ALIGN_RIGHT_BOTTOM) {
            uti.assert_(false, "ALIGN_RIGHT_BOTTOM not implemented")
        } else if (align == ALIGN_HORZ) {
            uti.assert_(false, "ALIGN_HORZ not implemented")
        } else if (align == ALIGN_VERT) {
            uti.assert_(false, "ALIGN_VERT not implemented")
        } else if (align == ALIGN_LEFT_TOP) {
            uti.assert_(false, "ALIGN_LEFT_TOP not implemented")
        } else if (align == ALIGN_RIGHT_TOP) {
            uti.assert_(false, "ALIGN_RIGHT_TOP not implemented")
        } else if (align == ALIGN_LEFT) {
            uti.assert_(false, "ALIGN_LEFT not implemented")
        } else if (align == ALIGN_RIGHT) {
            x = contX + contW - width - padding.z
                y = contY + padding.w + (contH - height - padding.y - padding.w) / 2.0
                /*if (id.control == 153) {
                  printf("ALIGN_CONTROL CONTX %f, CONTY %f, CONTW %f, CONTH %f, WIDTH %f, HEIGHT %f OFFSET X %f, OFFSET Y %f\n", contX, contY, contW, contH, width, height, x, y)
                  }*/
        } else if (align == ALIGN_BOTTOM) {
            uti.assert_(false, "ALIGN_BOTTOM not implemented")
        } else if (align == ALIGN_TOP) {
            uti.assert_(false, "ALIGN_TOP not implemented")
        } else if (align != ALIGN_NONE) {
            //x = bounds.x
            //y = bounds.y
            //w = bounds.z
            //h = bounds.w
            //} else {
            uti.assert_(false, "invalid align property")
}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_redock(id control_id, padding mat.v4) () {
    uti.assert_(is_valid_control(id), "control_redock : invalid id")
    var visible i32 = g_controls[id.control].visible
    if (visible > 0) {
        /*if (id.control == 85) {
          control_print("begin_control_redock : ", id, false)
          }*/

        var index i32 = id.control
        var w f32 = 0.0
        var h f32 = 0.0
        var x f32 = 0.0
        var y f32 = 0.0

        var dock i32 = g_controls[index].dock
        var align i32 = g_controls[index].align
        var autosize i32 = g_controls[index].autosize
        var autoscale i32 = g_controls[index].autoscale
        var size mat.v2 = g_controls[index].size
        var position mat.v2 = g_controls[index].position
        var parentPadding mat.v4 = g_controls[index].padding

        var paddingLeft f32 = padding.x
        var paddingBottom f32 = padding.y
        var paddingRight f32 = padding.z
        var paddingTop f32 = padding.w

        var paddingX f32 = paddingLeft + paddingRight
        var paddingY f32 = paddingBottom + paddingTop

        /*if (dock != DOCK_NONE) {
          uti.assert_(align == ALIGN_NONE, "control_redock : incompatible align & dock options")
          }*/

        if (dock == DOCK_FILL) {
            x = g_dock.left + paddingLeft
            w = g_dock.right - g_dock.left - paddingX
            h = g_dock.top - g_dock.bottom - paddingY
            y = g_dock.bottom + paddingBottom
            //uti.assert_(mat.is_nan(y) == false, "control_resize : DOCK_FILL y nan")
            //uti.assert_(autosize == AUTOSIZE_NONE, "control_redock : DOCK_FILL is not compatible with AUTOSIZE")
            /*if (index == 153) {
              control_print("DOCK_FILL : ", id, false)
              }*/
        } else if (dock == DOCK_LEFT) {
            x = g_dock.left + paddingLeft
            w = size.x
            h = g_dock.top - g_dock.bottom - paddingY
            y = g_dock.top - h - paddingTop
            //uti.assert_(mat.is_nan(y) == false, "control_resize : DOCK_LEFT y nan")
            g_dock.left = x + w
            //uti.assert_((autosize & AUTOSIZE_Y) == 0, "control_redock : DOCK_LEFT is not compatible with AUTOSIZE_Y")
        } else if (dock == DOCK_RIGHT) {
            w = size.x
            x = g_dock.right - w - paddingLeft
            h = g_dock.top - g_dock.bottom - paddingY
            y = g_dock.top - h - paddingTop
            g_dock.right = x
            //uti.assert_((autosize & AUTOSIZE_Y) == 0, "control_redock : DOCK_RIGHT is not compatible with AUTOSIZE_Y")
        } else if (dock == DOCK_TOP) {
            x = g_dock.left + paddingLeft
            w = g_dock.right - g_dock.left - paddingX
            h = size.y
            y = g_dock.top - h - paddingTop
            //uti.assert_(mat.is_nan(y) == false, "control_resize : DOCK_TOP y nan")
            /*if (index == 29 || index == 30) {
              printf("DOCK_TOP %f, %f, %f, %f\n", g_dock.top, h, paddingTop, y)
              }*/
            g_dock.top = y
            //uti.assert_((autosize & AUTOSIZE_X) == 0, "control_redock : DOCK_TOP is not compatible with AUTOSIZE_X")
            //control_print("DOCK_TOP : ", id, false)
            //printf("DOCK_TOP %f, %f, %f\n", g_dock.top, y, h)
        } else if (dock == DOCK_BOTTOM) {
            x = g_dock.left + paddingLeft
            w = g_dock.right - g_dock.left - paddingX
            h = size.y
            y = g_dock.bottom + paddingBottom// + h
            g_dock.bottom = y + h
            //uti.assert_(mat.is_nan(y) == false, "control_resize : DOCK_BOTTOM y nan")
            //uti.assert_((autosize & AUTOSIZE_X) == 0, "control_redock : DOCK_BOTTOM is not compatible with AUTOSIZE_X")
            //control_print("DOCK_BOTTOM : ", id, false)
        } else if (dock == DOCK_NONE) {
            x = position.x
            y = position.y
            w = size.x
            h = size.y
            //uti.assert_(mat.is_nan(y) == false, "control_resize : DOCK_NONE y nan")
            /*if (index == 50) {
              control_print("control_redock : ", id, false)
              printf("x %f, y %f, w %f, h %f\n", x, y, w, h)
              }*/
        } else {
            uti.assert_(false, "invalid dock value")
        }

        var contX f32 = g_dock.left
        var contY f32 = g_dock.bottom
        var contW f32 = g_offset.width//g_dock.right - g_dock.left//g_offset.width
        var contH f32 = g_offset.height//g_dock.top - g_dock.bottom//g_offset.height

        /*if (index == 153) {
          control_print("befor align : ", id, false)
          printf("redock %f, %f\n", x, y)
          }*/
        x, y = align_control(id, align, x, y, size.x, size.y, contX, contY, contW, contH, padding)
        /*if (index == 153) {
          control_print("after align : ", id, false)
          printf("redock %f, %f\n", x, y)
          }*/
        push_scope()

        //uti.assert_(mat.is_nan(y) == false, "control_resize : y nan")
        g_offset.x = g_offset.x + x
        g_offset.y = g_offset.y + y
        g_offset.width = w
        g_offset.height = h

        g_dock.left = 0.0
        g_dock.bottom = 0.0
        g_dock.right = w
        g_dock.top = h

        //control_print(index, "child")
        var count i32 = g_controls[index].childCount
        for i := 0; i < count; i = i + 1 {
            var child control_id = g_controls[index].children[i]
            uti.assert_(is_valid_control(child), "control_redock : invalid child control")
            var childVisible i32 = g_controls[child.control].visible
            if (childVisible > 0) {
                ///printf("REDOCK_CHILD %d/%d\n", i + 1, count)
                var childControl i32 = child.control
                var guiType i32 = g_controls[childControl].gui_type
                var guiIndex i32 = g_controls[childControl].gui_index

                if (guiType == GUI_INVALID) {
                    uti.assert_(false, "invalid gui type (GUI_INVALID)")
                } else if (guiType == GUI_CONTROL) {
                    uti.assert_(guiIndex == childControl, "unexpected error")
                    /*if (index == 85) {
                      control_print("REDOCK :", child, false)
                      }*/
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_SCREEN) {
                    uti.assert_(false, "unidd recursive screen")
                } else if (guiType == GUI_PICTURE) {
                    //redock_picture(picture_id_(child, guiIndex))
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_LABEL) {
                    //redock_label(label_id_(child, guiIndex))
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_PARTITION) {
                    //redock_partition(partition_id_(child, guiIndex))
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_KEYBOARD) {
                    //redock_keyboard(keyboard_id_(child, guiIndex))
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_WINDOW) {
                    //redock_window(window_id_(child, guiIndex))
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_GRAPH) {
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_SPLITTER) {
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_LIST) {
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_SCROLLER) {
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_LIFTER) {
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_BINDER) {
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_VECTOR) {
                    control_redock(control_id_(childControl), parentPadding)
                } else if (guiType == GUI_COMBO) {
                    control_redock(control_id_(childControl), parentPadding)
                } else {
                    //control_print("control_redock parent : ", id, false)
                    //control_print("control_redock child : ", child, false)
                    uti.assert_(false, "control_redock : unknown gui type")
                }
            }
        }

        g_controls[index].renderPosition = mat.v2_(g_offset.x, g_offset.y)
        //uti.assert_(mat.is_nan(g_offset.y) == false, "control_resize : nan")
        //control_print("after control_redock : ", id, false)
        //g_controls[index].renderSize = mat.v2_(g_offset.width, g_offset.height)
        var newWidth f32 = g_offset.width
        var newHeight f32 = g_offset.height

        if ((autosize & AUTOSIZE_X) == AUTOSIZE_X) {
            uti.assert_((autoscale & AUTOSCALE_X) == 0, "AUTOSIZE_X is not compatible with AUTOSCALE_X")
            //uti.assert_(dock == DOCK_NONE || dock == DOCK_LEFT || dock == DOCK_RIGHT, "AUTOSIZE_X is not compatible with DOCK_Y")
            newWidth = g_controls[index].size.x
            //newWidth = newWidth - paddingX // ##pending_7
            /*if (index == 36) {
              printf("AUTOSIZE NEW WIDTH %f, %f, %f\n", newWidth, g_controls[index].size.x, paddingX)
              }*/
        }
        if ((autosize & AUTOSIZE_Y) == AUTOSIZE_Y) {
            uti.assert_((autoscale & AUTOSCALE_Y) == 0, "AUTOSIZE_Y is not compatible with AUTOSCALE_Y")
            //uti.assert_(dock == DOCK_NONE || dock == DOCK_TOP || dock == DOCK_BOTTOM, "AUTOSIZE_Y is not compatible with DOCK_X")
            newHeight = g_controls[index].size.y
            //newHeight = newHeight - paddingY // ##pending_7
            //printf("AUTOSIZE NEW HEIGHT %f, %f, %f\n", newHeight, g_controls[index].size.y, paddingY)
        }
        g_controls[index].size = mat.v2_(newWidth, newHeight)

        /*if (id.control == 50) {
          control_print("end_control_redock", id, false)
          }*/
        pop_scope()
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_surface(opaque gfx.mesh_id, alpha gfx.mesh_id, bounds mat.v4, color mat.v4, clip mat.v4, depth f32) () {
    if (color.w > 0) {
        var mesh gfx.mesh_id = opaque
        if (color.w < 1.0) {
            mesh = alpha
        }
        gfx.append_quad(mesh, bounds, mat.v4_(0.0, 0.0, 1.0, 1.0), color, clip, depth)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_border(opaque gfx.mesh_id, alpha gfx.mesh_id, bounds mat.v4, left mat.v4, bottom mat.v4, right mat.v4, top mat.v4, clip mat.v4, depth f32) () {
    var x0 f32 = bounds.x
    var y0 f32 = bounds.y
    var x1 f32 = x0 + bounds.z
    var y1 f32 = y0 + bounds.w

    if (left.w > 0) {
        var mesh gfx.mesh_id = opaque
        if (left.w < 1.0) {
            mesh = alpha
        }
        gfx.append_line(mesh, mat.v4_(x0, y0, x0, y1), left, clip, depth)
    }

    if (bottom.w > 0) {
        var mesh gfx.mesh_id = opaque
        if (bottom.w < 1.0) {
            mesh = alpha
        }
        gfx.append_line(mesh, mat.v4_(x0, y0, x1, y0), bottom, clip, depth)
    }

    if (right.w > 0) {
        var mesh gfx.mesh_id = opaque
        if (right.w < 1.0) {
            mesh = alpha
        }
        gfx.append_line(mesh, mat.v4_(x1, y0, x1, y1), right, clip, depth)
    }

    if (top.w > 0) {
        var mesh gfx.mesh_id = opaque
        if (top.w < 1.0) {
            mesh = alpha
        }
        gfx.append_line(mesh, mat.v4_(x0, y1, x1, y1), top, clip, depth)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func compute_depth(stack i32) (out f32) {
    out = i32.f32(stack) / 100.0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func layer_render(layer layer_id, renderBounds mat.v4, renderClips mat.v4, depth f32) {
    if is_valid_layer(layer) {
        render_surface(g_opaqueVertexColoredTriangles, g_alphaVertexColoredTriangles, renderBounds, g_layers[layer.layer].surface, renderClips, depth)
        render_border(g_opaqueVertexColoredLines, g_alphaVertexColoredLines,
                    renderBounds,
                    g_layers[layer.layer].left,
                    g_layers[layer.layer].bottom,
                    g_layers[layer.layer].right,
                    g_layers[layer.layer].top,
                    renderClips, depth + 0.00001)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_render(id control_id, clip mat.v4, stack i32) () {
    //fps.begin_profile(g_profileRenderControlFull)

    uti.assert_(is_valid_control(id), "control_render : invalid control index")

    var index i32 = id.control
    var visible i32 = g_controls[index].visible
    if (visible > 0) {
        var renderBounds mat.v4 = mat.v4_v2v2(g_controls[index].renderPosition, g_controls[index].size)
        var renderClips mat.v4 = gfx.push_scissor(g_controls[index].name, renderBounds)
        //fps.begin_profile(g_profileControlRender)
        var skin skin_id = g_controls[index].skin
        uti.assert_(is_valid_skin(skin) || skin.skin == -1, "control_render : invalid control skin")
        if is_valid_skin(skin) {
            var depth f32 = compute_depth(stack)
            var focused i32 = g_controls[index].focused
            var childFocused i32 = g_controls[index].childFocused
            var selected i32 = g_controls[index].selected
            var backLayer layer_id = g_skins[skin.skin].back
            var frontLayer layer_id = g_skins[skin.skin].front

            if (focused > 0 || childFocused > 0) {
                var backFocusedLayer layer_id = g_skins[skin.skin].focused_back
                if (is_valid_layer(backFocusedLayer)) {
                    backLayer = backFocusedLayer
                }
                var frontFocusedLayer layer_id = g_skins[skin.skin].focused_front
                if (is_valid_layer(frontFocusedLayer)) {
                    frontLayer = frontFocusedLayer
                }
            } else if (selected > 0) {
                var backSelectedLayer layer_id = g_skins[skin.skin].selected_back
                if (is_valid_layer(backSelectedLayer)) {
                    backLayer = backSelectedLayer
                }
                var frontSelectedLayer layer_id = g_skins[skin.skin].selected_front
                if (is_valid_layer(frontSelectedLayer)) {
                    frontLayer = frontSelectedLayer
                }
            }

            var hover i32 = 0
            var hoverFront layer_id = g_skins[skin.skin].hoverFront
            var hoverBack layer_id = g_skins[skin.skin].hoverBack
            if (is_valid_layer(hoverFront) || is_valid_layer(hoverBack)) {
                hover = control_hovered(id)
            }

            layer_render(backLayer, renderBounds, renderClips, depth)
            if (hover > 0) {
                layer_render(hoverBack, renderBounds, renderClips, depth + 0.05)
            }
            layer_render(frontLayer, renderBounds, renderClips, depth + 0.1)
            if (hover > 0) {
                layer_render(hoverFront, renderBounds, renderClips, depth + 0.15)
            }
        }
        //fps.end_profile(g_profileControlRender)

        //fps.begin_profile(g_profileControlRenderChild)
        var childStack i32 = stack + 1
        var count i32 = g_controls[index].childCount
        for i := 0; i < count; i = i + 1 {
            var child control_id = g_controls[index].children[i]
                uti.assert_(is_valid_control(child), "control_render : invalid child control")
                var childVisible i32 = g_controls[child.control].visible
                if (childVisible > 0) {
                    var guiType i32 = g_controls[child].gui_type
                        var guiIndex i32 = g_controls[child].gui_index

                        if (guiType == GUI_INVALID) {
                            uti.assert_(false, "invalid gui type (GUI_INVALID)")
                        } else if (guiType == GUI_CONTROL) {
                            //control_print(guiIndex, "control_render_child GUI_CONTROL : ")
                            uti.assert_(child.control == guiIndex, "unexpected error")
                                control_render(child, renderBounds, childStack)
                        } else if (guiType == GUI_SCREEN) {
                            uti.assert_(false, "unidd recursive screen")
                        } else if (guiType == GUI_PICTURE) {
                            picture_render(picture_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_LABEL) {
                            label_render(label_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_PARTITION) {
                            partition_render(partition_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_KEYBOARD) {
                            keyboard_render(keyboard_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_WINDOW) {
                            window_render(window_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_GRAPH) {
                            graph_render(graph_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_SPLITTER) {
                            splitter_render(splitter_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_LIST) {
                            list_render(list_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_SCROLLER) {
                            scroller_render(scroller_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_LIFTER) {
                            lifter_render(lifter_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_BINDER) {
                            binder_render(binder_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_VECTOR) {
                            vector_render(vector_id_(child, guiIndex), renderBounds, childStack)
                        } else if (guiType == GUI_COMBO) {
                            combo_render(combo_id_(child, guiIndex), renderBounds, childStack)
                        } else {
                            printf("GUI TYPE %d\n", guiType)
                                uti.assert_(false, "control_render : unknown gui type")
                        }
                }
        }
        gfx.pop_scissor()
        //control_print("after control_render : ", id, false)
        //fps.end_profile(g_profileControlRenderChild)
    }
    //fps.end_profile(g_profileRenderControlFull)
}

//-----------------------------------------------------------------------------
// SCREEN
//-----------------------------------------------------------------------------
var g_screens [64]screen_s
var g_screenCount i32

var g_modals [64]screen_id
var g_modalCount i32 = 0

var g_currentScreen screen_id = invalid_screen()
var g_nextScreen    screen_id = invalid_screen()

var g_transitionDuration f64 = 0.5D
var g_transitionTime     f64 = 0.0D

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type screen_id struct {
    base control_id
    screen i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type screen_s struct {
    id    screen_id
    on_exit   screen_id
    on_enter  screen_id
    on_menu   screen_id
    on_next   screen_id
    duration  f64
    time      f64
    state     i32
    prevState i32
    modal     bool
    paused    bool
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_id_(base control_id, screen i32) (out screen_id) {
    out.base = base
    out.screen = screen
    uti.assert_(is_valid_screen(out), "screen_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_create(name str) (out screen_id) {
    uti.assert_(g_screenCount < len(g_screens), "screen_create : overflow") // ##1 use slice
    out.screen = g_screenCount
    out.base = control_create_(name, GUI_SCREEN, out.screen)

    control_set_focus_index(out.base, 0)

    var screen screen_s
    screen.id = out
    screen.on_exit   = invalid_screen()
    screen.on_enter  = invalid_screen()
    screen.on_menu   = invalid_screen()
    screen.on_next   = invalid_screen()
    screen.duration  = -1.0D
    screen.time      = 0.0D
    screen.state     = STATE_CLOSED
    screen.prevState = STATE_CLOSED
    screen.modal     = false
    screen.paused    = false

    g_screens[out.screen] = screen
    g_screenCount = out.screen + 1
    uti.assert_(is_valid_screen(out), "screen_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//func invalid_screen() { // ##pending issue
func invalid_screen() (out screen_id) {
    out.base = invalid_control()
    out.screen = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_screen(id screen_id) (out bool) {
    out = id.screen >= 0 && id.screen < g_screenCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func sceen_set_modal(id screen_id, modal bool) () {
    uti.assert_(is_valid_screen(id), "screen_set_modal : invalid id")
    g_screens[id.screen].modal = true
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_exit(id screen_id, exit screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_exit : invalid id")
    uti.assert_(is_valid_screen(exit)  , "screen_on_exit : invalid id")
    g_screens[id.screen].on_exit = exit
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_menu(id screen_id, menu screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_menu : invalid id")
    uti.assert_(is_valid_screen(menu)  , "screen_on_menu : invalid id")
    g_screens[id.screen].on_menu = menu
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_enter(id screen_id, enter screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_enter : invalid id")
    uti.assert_(is_valid_screen(enter) , "screen_on_enter : invalid id")
    g_screens[id.screen].on_enter = enter
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_on_next(id screen_id, next screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_on_next : invalid id 0")
    uti.assert_(is_valid_screen(next)  , "screen_on_next : invalid id 1")
    g_screens[id.screen].on_next = next
}

//-----------------------------------------------------------------------------
func screen_set_on_event(id screen_id, event screen_id) () {
    screen_set_on_exit(id, event)
    screen_set_on_enter(id, event)
    screen_set_on_menu(id, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_duration(id screen_id, duration f64) {
    uti.assert_(is_valid_screen(id), "screen_set_duration : invalid id")
    g_screens[id.screen].duration = duration
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_set_modal(id screen_id, modal bool) {
    uti.assert_(is_valid_screen(id), "screen_set_modal : invalid id")
    g_screens[id.screen].modal = modal
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_process_event(id screen_id, event *event_s) (out i32) {
    uti.assert_(is_valid_screen(id), "screen_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func change_screen_state(id screen_id, state i32) () {
    uti.assert_(is_valid_screen(id), "change_screen_state : invalid id")
    g_screens[id.screen].prevState = g_screens[id.screen].state
    printf("CHANGE %d\n", state)
    g_screens[id.screen].state = state
    var prev i32 = g_screens[id.screen].prevState
    var curr i32 = g_screens[id.screen].state
    if (prev != curr) {
        printf("%d screen state changed %d -> %d\n", id.screen, prev, curr)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_state_changed(id screen_id, prev i32, curr i32) (value bool) {
    uti.assert_(is_valid_screen(id), "screen_state_chaned : invalid id")
    var screenPrev i32 = g_screens[id.screen].prevState
    var screenCurr i32 = g_screens[id.screen].state
    value = ((screenPrev == prev) && (screenCurr == curr))
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func update_screen(id screen_id, deltaTime f64) () {
    uti.assert_(is_valid_screen(id), "update_screen : invalid id")
    var t f64 = g_screens[id.screen].time
    var d f64 = g_screens[id.screen].duration

    g_screens[id.screen].time = t
    var state i32 = g_screens[id.screen].state
    if ((t <= 0) && (state == STATE_CLOSED)) {
        printf("CHANGE SHOWING\n")
            change_screen_state(id, STATE_SHOWING)
    } else if ((t >= d) && (d > 0) && (state == STATE_OPENED)) { // can't use g_screens[screen].state here
        printf("CHANGE CLOSING %d\n", g_screens[id.screen].state)
            change_screen_state(id, STATE_CLOSING)
    }

    t = t + deltaTime
    g_screens[id.screen].time = t
    //    printf("time %f", f64.f32(t))
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_resize(id screen_id) () {
    uti.assert_(is_valid_screen(id), "screen_resize : invalid id")
    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func clear_batches() {
    g_renderBatchCount = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func begin_batches() {
    var i i32 = 0;
    //printf("BEGIN_BATCHES %d\n", g_renderBatchCount)
    for i = 0; i < g_renderBatchCount; i = i + 1 {
        //printf("BEGIN_BATCH %d/%d\n", i, g_renderBatchCount)
        var batchId batch_id = g_renderBatches[i]
            uti.assert_(is_valid_batch(batchId), "begin_batch : invaid batch")
            var meshId gfx.mesh_id = g_batches[batchId.batch].mesh
            uti.assert_(gfx.is_valid_mesh(meshId), "begin_batches : invalid mesh")
            gfx.begin_mesh(meshId)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func end_batches() {
    var i i32 = 0;
    for i = 0; i < g_renderBatchCount; i = i + 1 {
        var batchId batch_id = g_renderBatches[i]
            uti.assert_(is_valid_batch(batchId), "end_batch : invalid batch")
            var meshId gfx.mesh_id = g_batches[batchId.batch].mesh
            uti.assert_(gfx.is_valid_mesh(meshId), "end_batches : invalid mesh")
            gfx.end_mesh(meshId)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_batches(alpha bool) {
    var i i32 = 0
    for i = 0; i < g_renderBatchCount; i = i + 1 {
        var batchId batch_id = g_renderBatches[i]
        uti.assert_(is_valid_batch(batchId), "render_batches : invalid batch")
        var batch i32 = batchId.batch
        var meshId gfx.mesh_id = g_batches[batch].mesh
        uti.assert_(gfx.is_valid_mesh(meshId), "render_batches : invalid mesh")
        if (gfx.mesh_is_empty(meshId) == false) {
            var batchAlpha bool = g_batches[batch].alpha
            if (batchAlpha == alpha) {
                if (alpha == true) {
                    gfx.enable_blending(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
                } else {
                    gfx.disable_blending()
                }
                gfx.effect_use(gfx.g_fxTexture)
                    gfx.effect_assign_texture(gfx.g_fxTexture, 0, g_batches[batch].texture.name)
                    gfx.render_mesh(meshId)
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func screen_render(id screen_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_screen(id), "screen_render : invalid screen")
    fps.begin_profile(g_profileRenderScreenControl)

    gfx.begin_mesh(g_opaqueVertexColoredTriangles)
    gfx.begin_mesh(g_opaqueVertexColoredLines)
    gfx.begin_mesh(g_alphaVertexColoredTriangles)
    begin_batches()

    clip = gfx.push_scissor(g_controls[id.base.control].name, gfx.gfx_viewportBounds)
    //printf("SCREEN CLIP %f, %f, %f, %f\n", clip.x, clip.y, clip.z, clip.w)
    control_render(id.base, clip, stack)
    gfx.pop_scissor()

    uti.assert_(gfx.g_scissorCount == 0, "screen_render : invalid scissor stack")
    end_batches()
    gfx.end_mesh(g_alphaVertexColoredTriangles)
    gfx.end_mesh(g_opaqueVertexColoredLines)
    gfx.end_mesh(g_opaqueVertexColoredTriangles)

    fps.end_profile(g_profileRenderScreenControl)

    // opaque
    fps.begin_profile(g_profileRenderOpaqueVertexColoredTriangles)
    if gfx.mesh_is_empty(g_opaqueVertexColoredTriangles) == false {
        gfx.disable_blending()
            gfx.effect_use(gfx.g_fxVertexColor)
            gfx.render_mesh(g_opaqueVertexColoredTriangles)
    }
    fps.end_profile(g_profileRenderOpaqueVertexColoredTriangles)

    fps.begin_profile(g_profileRenderOpaqueTexturedTriangles)
    render_batches(false)
    fps.end_profile(g_profileRenderOpaqueTexturedTriangles)

    fps.begin_profile(g_profileRenderOpaqueVertexColoredLines)
    if gfx.mesh_is_empty(g_opaqueVertexColoredLines) == false {
        gfx.disable_blending()
            gfx.effect_use(gfx.g_fxVertexColor)
            gfx.render_mesh(g_opaqueVertexColoredLines)
    }
    fps.end_profile(g_profileRenderOpaqueVertexColoredLines)

    // alpha
    fps.begin_profile(g_profileRenderAlphaTexturedTriangles)
    render_batches(true)
    fps.end_profile(g_profileRenderAlphaTexturedTriangles)

    fps.begin_profile(g_profileRenderAlphaVertexColoredTriangles)
    if gfx.mesh_is_empty(g_alphaVertexColoredTriangles) == false {
        gfx.enable_blending(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
        gfx.effect_use(gfx.g_fxVertexColor)
        gfx.render_mesh(g_alphaVertexColoredTriangles)
    }
    fps.end_profile(g_profileRenderAlphaVertexColoredTriangles)


    /*gfx.color_write(false, false, false, false)
    gfx.disable_depth()
    gfx.disable_blending()
    gfx.stencil_state(true, gl.ALWAYS, 256, 256, gl.KEEP, gl.REPLACE, gl.REPLACE, 256)

    var screenPair i32 = get_focus_pair(id)
    var currentFocus i32 = g_focused[screenPair].currentFocus
    var focusCount i32 = g_focused[screenPair].focusCount
    if (focusCount > 0 && currentFocus >= 0 && currentFocus < focusCount) {
        var focusedId control_id = g_focused[screenPair].focusList[currentFocus]
        gfx.begin_mesh(g_opaqueVertexColoredTriangles)
        var renderBounds mat.v4 = mat.v4_v2v2(g_controls[focusedId.control].renderPosition, g_controls[focusedId.control].size)
        gfx.append_quad(g_opaqueVertexColoredTriangles, renderBounds,
            mat.v4_(0.0, 0.0, 1.0, 1.0), mat.v4_(1.0, 1.0, 1.0, 1.0), gfx.gfx_viewportBounds, 1.0)
        gfx.end_mesh(g_opaqueVertexColoredTriangles)
        gfx.effect_use(gfx.g_fxVertexColor)
        gfx.render_mesh(g_opaqueVertexColoredTriangles)
    }*/
}

//-----------------------------------------------------------------------------
// SPLITTER
//-----------------------------------------------------------------------------
type splitter_id struct {
    base control_id
        splitter i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type splitter_s struct {
    id splitter_id
        direction i32
        master control_id
        slave control_id

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var SPLIT_NONE i32 = 0
var SPLIT_LEFT i32 = 1
var SPLIT_RIGHT i32 = 2
var SPLIT_TOP i32 = 3
var SPLIT_BOTTOM i32 = 4
var SPLIT_HORZ i32 = 5
var SPLIT_VERT i32 = 6

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_id_(base control_id, splitter i32) (out splitter_id) {
    out.base = base
    out.splitter = splitter
    uti.assert_(is_valid_splitter(out), "splitter_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_splitter(id splitter_id) (out bool) {
    out = id.splitter >= 0 && id.splitter < g_splitterCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_set_direction(id splitter_id, direction i32) {
    uti.assert_(is_valid_splitter(id), "splitter_set_direction : invalid id")
    g_splitters[id.splitter].direction = direction
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_set_controls(id splitter_id, master control_id, slave control_id) {
    uti.assert_(is_valid_splitter(id), "splitter_set_master : invalid id")
    control_clear_children(id.base)
    g_splitters[id.splitter].master = master
    control_add_child(id.base, master)

    g_splitters[id.splitter].slave = slave
    control_add_child(id.base, slave)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_splitters[16] splitter_s
var g_splitterCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_create(name str) (out splitter_id) {
    uti.assert_(g_splitterCount < len(g_splitters), "splitter_create : overflow")
    out.splitter = g_splitterCount
    out.base = control_create_(name, GUI_SPLITTER, out.splitter)
    //printf("SPLITTER_CREATE %s, %d, %d\n", name, out.splitter, g_splitterCount)

    g_splitters[g_splitterCount].id = out
    g_splitters[g_splitterCount].direction = SPLIT_NONE
    g_splitters[g_splitterCount].master = invalid_control()
    g_splitters[g_splitterCount].slave = invalid_control()

    g_splitterCount = g_splitterCount + 1
    uti.assert_(is_valid_splitter(out), "splitter_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_process_event(id splitter_id, event *event_s) (out i32) {
    uti.assert_(is_valid_splitter(id), "splitter_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_resize(id splitter_id) () {
    uti.assert_(is_valid_splitter(id), "resize_splitter : invalid id")
    control_resize(id.base)
    //control_print("splitter_resize : ", id.base, false)
    var splitterIndex i32 = id.splitter
    var direction i32 = g_splitters[splitterIndex].direction
    //printf("SPLIT %d, %d, %d\n", id.splitter, g_splitters[id.splitter].direction, direction)

    /*if (id.base.control == 28) {
      printf("28 %d, HORZ %d, VERT %d\n", split, SPLIT_HORZ, SPLIT_VERT)
      uti.assert_(split == SPLIT_VERT, "fuck")
      }*/
    var master control_id = g_splitters[splitterIndex].master
    var slave control_id = g_splitters[splitterIndex].slave

    //control_print("splitter_resize : ", id.base, false)
    //printf("MASTER %d\n", master.control)
    uti.assert_(is_valid_control(master), "splitter_resize : invalid master")
    var masterIndex i32 = master.control

    uti.assert_(is_valid_control(slave), "splitter_resize : invalid slave")
    var slaveIndex i32 = slave.control

    var controlIndex i32 = id.base.control
    var splitterPosition mat.v2 = g_controls[controlIndex].renderPosition
    var splitterSize mat.v2 = g_controls[controlIndex].size

    var padding mat.v4 = g_controls[controlIndex].padding
    var spacing mat.v2 = g_controls[controlIndex].spacing

    if (direction == SPLIT_HORZ) {
        var width f32 = (splitterSize.x - padding.x - padding.z - spacing.x) / 2.0
        var height f32 = (splitterSize.y - padding.y - padding.w)

        var masterPosition mat.v2 = mat.v2_(padding.x, padding.y)
        var masterSize mat.v2 = mat.v2_(width, height)
        g_controls[masterIndex].renderPosition = masterPosition
        g_controls[masterIndex].size = masterSize

        var slaveX f32 = padding.x + spacing.x + width
        var slavePosition mat.v2 = mat.v2_(slaveX, padding.y)
        var slaveSize mat.v2 = mat.v2_(width, height)
        g_controls[slaveIndex].renderPosition = slavePosition
        g_controls[slaveIndex].size = slaveSize
    } else if (direction == SPLIT_VERT) {
        var width f32 = (splitterSize.x - padding.x - padding.z)
        var height f32 = (splitterSize.y - padding.y - padding.w - spacing.y) / 2.0

        var masterPosition mat.v2 = mat.v2_(padding.x, padding.y)
        var masterSize mat.v2 = mat.v2_(width, height)
        g_controls[masterIndex].renderPosition = masterPosition
        g_controls[masterIndex].size = masterSize

        var slaveY f32 = padding.y + spacing.y + height
        var slavePosition mat.v2 = mat.v2_(padding.x, slaveY)
        var slaveSize mat.v2 = mat.v2_(width, height)
        g_controls[slaveIndex].renderPosition = slavePosition
        g_controls[slaveIndex].size = slaveSize
    } else if (direction == SPLIT_BOTTOM) {
        var oldMasterSize mat.v2 = g_controls[masterIndex].size
        var width f32 = (splitterSize.x - padding.x - padding.z)
        var height f32 = (splitterSize.y - padding.y - padding.w - spacing.y - oldMasterSize.y)

        var masterPosition mat.v2 = mat.v2_(padding.x, padding.y)
        var masterSize mat.v2 = mat.v2_(width, oldMasterSize.y)
        g_controls[masterIndex].renderPosition = masterPosition
        g_controls[masterIndex].size = masterSize

        var slaveY f32 = padding.y + oldMasterSize.y + spacing.y
        var slavePosition mat.v2 = mat.v2_(padding.x, slaveY)
        var slaveSize mat.v2 = mat.v2_(width, height)
        g_controls[slaveIndex].renderPosition = slavePosition
        g_controls[slaveIndex].size = slaveSize
    } else if (direction == SPLIT_LEFT) {
        var oldMasterSize mat.v2 = g_controls[masterIndex].size
        var width f32 = (splitterSize.x - padding.x - padding.z - spacing.x - oldMasterSize.x)
        var height f32 = (splitterSize.y - padding.y - padding.w)

        //control_print("splitter_resize : ", master, false)
        var masterPosition mat.v2 = mat.v2_(padding.x, padding.y)
        var masterSize mat.v2 = mat.v2_(oldMasterSize.x, height)
        g_controls[masterIndex].renderPosition = masterPosition
        g_controls[masterIndex].size = masterSize

        var slaveX f32 = padding.x + oldMasterSize.x + spacing.x
        //printf("MASTER_POSITION %f\n", masterPosition.x)
        //printf("SLAVE POSITION %f\n", slaveX)
        var slavePosition mat.v2 = mat.v2_(slaveX + 10.0, padding.y)
        var slaveSize mat.v2 = mat.v2_(width, height)
        g_controls[slaveIndex].renderPosition = slavePosition
        g_controls[slaveIndex].size = slaveSize
    } else {
        uti.assert_(false, "splitter_resize : not implemented")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func splitter_render(id splitter_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_splitter(id), "render_splitter : invalid id")
    control_render(id.base, clip, stack)

    //var direction i32 = g_splitters[id.splitter].direction
    //if (direction == SPLIT_LEFT) {
    //control_print("splitter_render : ", id.base, false)
    //var master control_id = g_splitters[id.splitter].master
    //var slave control_id = g_splitters[id.splitter].slave
    //control_print("splitter_render : MASTER :", master, false)
    //control_print("splitter_render : SLAVE :", slave, false)
    //}
}

//-----------------------------------------------------------------------------
// LABEL
//-----------------------------------------------------------------------------
var g_labels [1024]label_s
var g_labelCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type label_id struct {
    base control_id
        label i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type func_i32_i32_id struct {
    index i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func func_i32_i32(packageName str, functionName str) (out func_i32_i32_id) {
    out.index = glfw.func_i32_i32(packageName, functionName)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_func_i32_i32() (out func_i32_i32_id) {
    out.index = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func call_i32_i32(function func_i32_i32_id, a i32, b i32) {
        printf("FUNCTION_CALL %d\n", function.index)
    glfw.call_i32_i32(function.index, a, b)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type label_s struct {
    id label_id
    font font_id
    batch batch_id
    text str
    rune i32
    textSize i32
    textAlign i32
    textPosition mat.v2
    color_0 mat.v4
    color_1 mat.v4
    on_state func_i32_i32_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_id_(base control_id, label i32) (out label_id) {
    out.base = base
        out.label = label
        uti.assert_(is_valid_label(out), "label_id_ : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_label(id label_id) (out bool) {
    out = id.label >= 0 && id.label < g_labelCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_create(name str) (out label_id) {
    uti.assert_(g_labelCount < len(g_labels), "label_create : overflow") // ##1 use slice
    out.label = g_labelCount
    out.base = control_create_(name, GUI_LABEL, out.label)

    var label label_s
    label.id = out
    label.font = invalid_font()
    label.batch = invalid_batch()
    label.text = ""
    label.rune = -1
    label.textSize = 16
    label.textAlign = ALIGN_NONE
    label.textPosition = mat.v2_zero
    label.color_0 = g_red
    label.color_1 = g_green
    label.on_state = invalid_func_i32_i32()
    g_labels[out.label] = label
    g_labelCount = out.label + 1
    uti.assert_(is_valid_label(out), "label_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_font(id label_id, font font_id) {
    uti.assert_(is_valid_label(id), "label_set_font : invalid id")
    uti.assert_(is_valid_font(font), "label_set_font : invalid font")
    g_labels[id.label].font = font
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_rune(id label_id, rune i32) {
    uti.assert_(is_valid_label(id), "label_set_rune : invalid id")
    g_labels[id.label].rune = rune
    label_set_font(id, g_awesomeBoldFont) // ##0 workaround
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_text(id label_id, text str) {
    uti.assert_(is_valid_label(id), "label_set_text : invalid id")
    g_labels[id.label].text = text
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_align(id label_id, align i32) {
    uti.assert_(is_valid_label(id), "label_set_align : invalid id")
        g_labels[id.label].textAlign = align
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_size(id label_id, size i32) {
    uti.assert_(is_valid_label(id), "label_set_size : invalid id")
        g_labels[id.label].textSize = size
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_color(id label_id, color mat.v4) {
    uti.assert_(is_valid_label(id), "label_set_color : invalid id")
        g_labels[id.label].color_0 = color
        g_labels[id.label].color_1 = color
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_set_on_state(i_id label_id, packageName str, functionName str) {
    uti.assert_(is_valid_label(i_id), "label_set_on_state : invalid id")
        g_labels[i_id.label].on_state = func_i32_i32(packageName, functionName)
        var onState func_i32_i32_id = g_labels[i_id.label].on_state
        uti.assert_(onState.index >= 0, "label_set_on_state : invalid function")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type batch_id struct {
    batch i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type batch_s struct {
    texture texture_s
        mesh mesh_id
        alpha bool
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_batches[64] batch_s
var g_batchCount i32 = 0

var g_renderBatches[64] batch_id
var g_renderBatchCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_batch() (out batch_id) {
    out.batch = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_batch(id batch_id) (out bool) {
    out = id.batch >= 0 && id.batch < g_batchCount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func get_batch(texture texture_s, alpha bool) (out batch_id) {

    out.batch = -1
        var i i32 = 0
        for i >= 0 {
            if (i < g_batchCount) {
                var textureName i32 = g_batches[i].texture.name
                    var textureAlpha bool = g_batches[i].alpha
                    if (textureName == texture.name && textureAlpha == alpha) {
                        out.batch = i
                    }
                i = i + 1
            } else {
                i = -1
            }
        }
    if (out.batch < 0) {
        g_batches[g_batchCount].texture = texture
            var attributes [3]i32 // ##0 harcode
            attributes = [3]i32{3, 4, 2} // ##0 can't use slice yet
        g_batches[g_batchCount].mesh = gfx.lock_mesh(gl.TRIANGLES, attributes, 2048 * 3) // ##0 hardcode
            g_batches[g_batchCount].alpha = alpha
            out.batch = g_batchCount
            g_batchCount = g_batchCount + 1
    }

    i = 0
        var found bool = false
        for i >= 0 {
            if (i < g_renderBatchCount) {
                if (g_renderBatches[i].batch == out.batch) {
                    found = true
                        i = -1
                } else {
                    i = i + 1
                }
            } else {
                i = -1
            }
        }

    if (found == false) {
        //printf("BATCH_NOT FOUND %d\n", out.batch)
        g_renderBatches[g_renderBatchCount] = out
            g_renderBatchCount = g_renderBatchCount + 1
    }

    uti.assert_(is_valid_batch(out), "get_batch : invalid index")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_process_event(id label_id, event *event_s) (out i32) {
    uti.assert_(is_valid_label(id), "label_process_event : invalid label")
    out = control_process_event(id.base, event)

    if (out == EVENT_UNUSED) {
        var index i32 = id.base.control
        var focused i32 = g_controls[index].focused
        var mods i32 = ((*event).keyboard).mods

        if (mods == MOD_NONE) {

            var callAction i32 = 0
            var call bool = false
            var button i32 = (*event).mouse.button
            if (button == BUTTON_LEFT) {
                var action i32 = (*event).mouse.action
                if (action == BUTTON_PRESS) {
                    //printf("BUTTON_PRESS\n")
                    var hover i32 = control_hovered(id.base)
                    if (hover > 0) {
                        call = true
                        callAction = action
                    }
                }
            } else if (focused > 0) {
                var key i32 = (*event).keyboard.key
                if (key == KEYCODE_ENTER || key == KEYCODE_SPACE) {
                    var action i32 = ((*event).keyboard).action
                    if (action == KEY_PRESS) {
                        call = true
                        callAction = action
                    }
                }
            }

            if (call == true) {
                var function func_i32_i32_id = g_labels[id.label].on_state
                var functionIndex i32 = function.index
                if functionIndex >= 0 {
                    //printf("------------------------------------------------------------>>>>> ON_STATE %d\n", functionIndex)
                    call_i32_i32(function, index, callAction)
                    //printf("label_process_event\n")
                    out = EVENT_CONSUMED
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_measure(id label_id) (width f32, height f32) { // ##1 factorize with label_resize
    uti.assert_(is_valid_label(id), "label_resize : invalid id")
    //control_print("label_resize : ", id.base, false)
    var i32Width i32
    var i32Hheight i32
    var text str = g_labels[id.label].text

    var fontId font_id = g_labels[id.label].font
    var fontIndex i32 = fontId.font
    uti.assert_(is_valid_font(fontId), "label_resize : invalid font")

    var fontSize i32 = g_labels[id.label].textSize
    //printf("fontID %d, fontSize %d\n", fontId.font, fontSize)
    var textureIndex i32 = font_get_texture_index(fontId, fontSize)

    //printf("fontIndex %d, textureIndex %d\n", fontIndex, textureIndex)
    var fontName str = g_fonts[fontIndex].names[textureIndex] // ##0 auto select best size

    var i32Width i32 = 0
    var i32Height i32 = 0
    var rune i32 = g_labels[id.label].rune
    if (rune >= 0) {
        i32Width, i32Height = gfx.measure_glyph(fontName, rune)
    } else {
        i32Width, i32Height = gfx.measure_text(fontName, text)
    }

    var pixelBounds mat.v2 = mat.v2_(i32.f32(i32Width), i32.f32(i32Height))

    var padding mat.v4 = g_controls[id.base.control].padding
    var paddingX f32 = padding.x + padding.z
    var paddingY f32 = padding.y + padding.w
    //var bounds mat.v2 = mat.v2_div(pixelBounds, gfx.gfx_viewport_size)
    var autoBounds mat.v2 = mat.v2_add(pixelBounds, mat.v2_(paddingX, paddingY))

    width = autoBounds.x
    height = autoBounds.y
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_resize(id label_id) () {
    uti.assert_(is_valid_label(id), "label_resize : invalid id")
        //control_print("label_resize : ", id.base, false)
        var i32Width i32
        var i32Hheight i32
        var text str = g_labels[id.label].text

        var fontId font_id = g_labels[id.label].font
        var fontIndex i32 = fontId.font
        uti.assert_(is_valid_font(fontId), "label_resize : invalid font")

        var fontSize i32 = g_labels[id.label].textSize
        //printf("fontID %d, fontSize %d\n", fontId.font, fontSize)
        var textureIndex i32 = font_get_texture_index(fontId, fontSize)

        //printf("fontIndex %d, textureIndex %d\n", fontIndex, textureIndex)
        var fontName str = g_fonts[fontIndex].names[textureIndex] // ##0 auto select best size
        var i32Width i32 = 0
        var i32Height i32 = 0
        var rune i32 = g_labels[id.label].rune
        if (rune >= 0) {
            i32Width, i32Height = gfx.measure_glyph(fontName, rune)
        } else {
            i32Width, i32Height = gfx.measure_text(fontName, text)
        }


        var pixelBounds mat.v2 = mat.v2_(i32.f32(i32Width), i32.f32(i32Height))

        var controlIndex i32 = id.base.control
        var padding mat.v4 = g_controls[controlIndex].padding
        var paddingX f32 = padding.x + padding.z
        var paddingY f32 = padding.y + padding.w
        //var bounds mat.v2 = mat.v2_div(pixelBounds, gfx.gfx_viewport_size)
        var autoBounds mat.v2 = mat.v2_add(pixelBounds, mat.v2_(paddingX, paddingY))
        /*if (id.base.control == 36) {
          printf("AUTOBOUNDS %f, %f, PADDING %f, %f\n", bounds.x, bounds.y, paddingX, paddingY)
          }*/
        control_resize_(id.base, pixelBounds, autoBounds)

        var position mat.v2 = g_controls[controlIndex].renderPosition
        //var size mat.v2 = g_controls[controlIndex].renderSize
        var size mat.v2 = g_controls[controlIndex].size
        var scale mat.v2 = g_controls[controlIndex].scale
        var padding mat.v4 = g_controls[controlIndex].padding
        //printf("LABEL_SCALE %f, %f, width %f, height %f, scale.x * width %f, scale.y * height %f\n", scale.x, scale.y, width, height, scale.x * width, scale.y * height)

        var newSize mat.v2 = mat.v2_mul(scale, pixelBounds)
        /*if (id.base.control == 57) {
            printf("PIXEL_BOUNDS %f, %f, AUTO_BOUNSD %f, %f, SCALE %f, %f\n", pixelBounds.x, pixelBounds.y, autoBounds.x, autoBounds.y, scale.x, scale.y)
        }*/

        position.x, position.y = align_control(id.base, g_labels[id.label].textAlign, 0.0, 0.0, newSize.x, newSize.y, position.x, position.y, size.x, size.y, padding)
        //position.y = position.y - newSize.y / 2.0
        g_labels[id.label].textPosition = position
        //printf("LABEL_TEXT_POSITION %f, %f\n", position.x, position.y)
        g_labels[id.label].batch = get_batch(g_fonts[fontIndex].textures[textureIndex], true)
        //control_print("label_resize :", id.base, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func label_render(id label_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_label(id), "label_render : invalid id")
    //control_print("label_render : ", id.base, false)
    control_render(id.base, clip, stack)

    var fontId font_id = g_labels[id.label].font
    uti.assert_(is_valid_font(fontId), "label_render : invalid font")

    var fontSize i32 = g_labels[id.label].textSize
    var textureIndex i32 = font_get_texture_index(fontId, fontSize)

    var fontTexture texture_s = g_fonts[fontId.font].textures[textureIndex] // ##0 auto select best size
    var fontName str = g_fonts[fontId.font].names[textureIndex]

    //printf("label_render : using font %s - %d, %d, %d\n", fontName, fontTexture.name, fontTexture.width, fontTexture.height)

    var control i32 = id.base.control
    var renderPosition mat.v2 = g_labels[id.label].textPosition
    var batch batch_id = g_labels[id.label].batch
    
    if (is_valid_batch(batch)) {
        uti.assert_(is_valid_batch(batch), "label_render : invalid batch")
        //gfx.append_text(&(gfx.g_meshes[g_batches[batch.batch].mesh.mesh]), fontTexture, fontName, // ##pending
        var meshId gfx.mesh_id = g_batches[batch.batch].mesh
        var renderBounds mat.v4 =  mat.v4_v2v2(renderPosition, g_controls[control].size)
        //control_print("label_render : renderBounds ", id.base, false)
        var renderClips mat.v4 = gfx.push_scissor(g_controls[control].name, renderBounds)
        gfx.g_debugMesh = g_opaqueVertexColoredTriangles
        var rune i32 = g_labels[id.label].rune
        if (rune >= 0) {
        gfx.append_glyph(meshId, fontTexture, fontName,
            renderPosition, g_controls[control].scale,
            mat.v4_(1.0, 1.0, 1.0, 1.0), rune, true, g_labels[id.label].color_0, g_labels[id.label].color_1, renderClips, compute_depth(stack))
        } else {
        gfx.append_text(meshId, fontTexture, fontName,
            renderPosition, g_controls[control].scale,
            mat.v4_(1.0, 1.0, 1.0, 1.0), g_labels[id.label].text, true, g_labels[id.label].color_0, g_labels[id.label].color_1, renderClips, compute_depth(stack))
        }
        gfx.pop_scissor()
    }
}

//-----------------------------------------------------------------------------
// PICTURE
//-----------------------------------------------------------------------------
var g_pictures [64]picture_s
var g_pictureCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type picture_id struct {
    base control_id
        picture i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type picture_s struct {
    id picture_id
        texture gfx.texture_s
        batch batch_id
        pictureAlign i32
        picturePosition mat.v2
        alpha bool
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_id_(base control_id, picture i32) (out picture_id) {
    out.base = base
        out.picture = picture
        uti.assert_(is_valid_picture(out), "picture_id_ : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_picture(id picture_id) (out bool) {
    out = id.picture >= 0 && id.picture < g_pictureCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_create(name str) (out picture_id) {
    uti.assert_(g_pictureCount < len(g_pictures), "picture_create : overflow") // ##1 use slice
        out.picture = g_pictureCount
        out.base = control_create_(name, GUI_PICTURE, out.picture)

        var picture picture_s
        picture.id = out
        picture.texture = gfx.invalid_texture()
        picture.batch = invalid_batch()
        picture.pictureAlign = ALIGN_NONE
        picture.picturePosition = mat.v2_zero
        picture.alpha = false

        g_pictures[out.picture] = picture
        g_pictureCount = out.picture + 1
        uti.assert_(is_valid_picture(out), "picture_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_set_texture(id picture_id, texture texture_s) {
    uti.assert_(is_valid_picture(id), "picture_set_texture : invalid id")
        g_pictures[id.picture].texture = texture
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_set_align(id picture_id, align i32) {
    uti.assert_(is_valid_picture(id), "picture_set_align : invalid id")
        g_pictures[id.picture].pictureAlign = align
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_process_event(id picture_id, event *event_s) (out i32) {
    uti.assert_(is_valid_picture(id), "picture_process_event : invalid id")
        out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_measure(id picture_id) (width f32, height f32) { // ##1 factorize with label_resize
    uti.assert_(is_valid_picture(id), "picture_measure : invalid id")

    var i32Width i32 = g_pictures[id.picture].texture.width
    var i32Height i32 = g_pictures[id.picture].texture.height

    width = i32.f32(i32Width)
    height = i32.f32(i32Height)

    var padding mat.v4 = g_controls[id.base.control].padding
    var autoscale i32 = g_controls[id.base.control].autoscale
    if ((autoscale & AUTOSCALE_X) == AUTOSCALE_X) {
        width = g_controls[id.base.control].size.x// + padding.x + padding.z
    }
    if ((autoscale & AUTOSCALE_Y) == AUTOSCALE_Y) {
        height = g_controls[id.base.control].size.y// + padding.y + padding.w
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_resize(id picture_id) () {
   uti.assert_(is_valid_picture(id), "picture_resize : invalid id")

    var i32Width i32 = g_pictures[id.picture].texture.width
    var i32Height i32 = g_pictures[id.picture].texture.height

    var pixelBounds mat.v2 = mat.v2_(i32.f32(i32Width), i32.f32(i32Height))

    control_resize_(id.base, pixelBounds, pixelBounds)
    var controlIndex i32 = id.base.control
    var position mat.v2 = g_controls[controlIndex].renderPosition
    //var size mat.v2 = g_controls[controlIndex].renderSize
    var size mat.v2 = g_controls[controlIndex].size
    var scale mat.v2 = g_controls[controlIndex].scale
    var padding mat.v4 = g_controls[controlIndex].padding
    //printf("PICTURE_SCALE %f, %f, width %f, height %f, scale.x * width %f, scale.y * height %f\n", scale.x, scale.y, width, height, scale.x * width, scale.y * height)

    var newSize mat.v2 = mat.v2_mul(scale, pixelBounds)
    //printf("NEW SIZE %f, %f - %f, %f -> %f, %f\n", pixelBounds.x, pixelBounds.y, newSize.x, newSize.y, size.x, size.y)
    position.x, position.y = align_control(id.base, g_pictures[id.picture].pictureAlign, 0.0, 0.0, newSize.x, newSize.y, position.x, position.y, size.x, size.y, padding)
    //printf("PICTURE_POSITION %f, %f\n", position.x, position.y)
    g_pictures[id.picture].picturePosition = position
    g_pictures[id.picture].batch = get_batch(g_pictures[id.picture].texture, g_pictures[id.picture].alpha)
    //control_print("picture_resize : AFTER", id.base, false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func picture_render(id picture_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_picture(id), "picture_render : invalid id")

    control_render(id.base, clip, stack)

    var controlIndex i32 = id.base.control

    var color mat.v4 = gfx.gfx_white
    var skin skin_id = g_controls[controlIndex].skin
    uti.assert_(is_valid_skin(skin) || skin.skin == -1, "picture_render : invalid id")
    if is_valid_skin(skin) {
        var backLayer layer_id = g_skins[skin.skin].back
        uti.assert_(is_valid_layer(backLayer) || backLayer.layer == -1, "picture_render : invalid id")
        if is_valid_layer(backLayer) {
            color = g_layers[backLayer.layer].surface
        }
    }

    var texture gfx.texture_s = g_pictures[id.picture].texture
    if texture.name > 0 {
        //printf("RENDER_BOUNDS %f, %f, %f, %f\n",
          //  g_controls[id.control].renderBounds.x,
            //g_controls[id.control].renderBounds.y,
            //g_controls[id.control].renderBounds.z,
            //g_controls[id.control].renderBounds.w)

        var i32Width i32 = g_pictures[id.picture].texture.width
        var i32Height i32 = g_pictures[id.picture].texture.height

        var scale mat.v2 = g_controls[controlIndex].scale

        //control_print("picture_render : ", id.base, false)
        var width f32 = scale.x * i32.f32(i32Width)
        var height f32 = scale.y * i32.f32(i32Height)

        var renderPosition mat.v2 = g_pictures[id.picture].picturePosition
        //var renderPosition mat.v2 = g_controls[controlIndex].renderPosition

        var batch batch_id = g_pictures[id.picture].batch
        uti.assert_(is_valid_batch(batch), "picture_render : invalid batch")

        var renderBounds mat.v4 = mat.v4_v2v2(renderPosition, mat.v2_(width, height))
        //control_print("picture_render : renderBounds ", id.base, false)
        //printf("renderBounds %f, %f, %f, %f\n", renderBounds.x, renderBounds.y, renderBounds.z, renderBounds.w)
        var renderClips mat.v4 = gfx.push_scissor(g_controls[controlIndex].name, renderBounds)
        var meshId gfx.mesh_id = g_batches[batch.batch].mesh
        gfx.append_quad(meshId, renderBounds, mat.v4_(0.0, 0.0, 1.0, 1.0), color, renderClips, compute_depth(stack))
        gfx.pop_scissor()
    }
}

//-----------------------------------------------------------------------------
// WINDOW
//-----------------------------------------------------------------------------
var g_windows[8] window_s
var g_windowCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type window_id struct {
    base control_id
    window i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type window_s struct {
    id window_id
    header control_id
    caption label_id
    container control_id
    strip control_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_id_(base control_id, window i32) (out window_id) {
    out.base = base
    out.window = window
    uti.assert_(is_valid_window(out), "window_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_window(id window_id) (out bool) {
    out = id.window >= 0 && id.window < g_windowCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_set_caption(id window_id, text str) () {
    uti.assert_(is_valid_window(id), " window_set_caption : invalid id")
    label_set_text(g_windows[id.window].caption, text)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_set_containee(id window_id, containee control_id) {
    uti.assert_(is_valid_window(id), "window_set_containee : invalid id")
    uti.assert_(is_valid_control(containee), "window_set_containee : invalid containee")

    var container control_id = g_windows[id.window].container
    uti.assert_(is_valid_control(container), "window_set_containee : invalid container")

    control_add_child(container, containee)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_create(name str) (out window_id) {
    uti.assert_(g_windowCount < len(g_windows), "window_create : overflow") // ##1 use slice
    out.base = control_create_(name, GUI_WINDOW, out.window)
    out.window = g_windowCount

    var window window_s
    window.id = out

    g_windowCount = out.window + 1

    uti.assert_(is_valid_window(out), "window_create : invalid id")

    var padding mat.v4 = mat.v4_(0.01, 0.01, 0.01, 0.01)
    var padding1 mat.v4 = mat.v4_(0.03, 0.03, 0.03, 0.03)
    {
        var header control_id = control_create("header") // ##pending := 
        control_add_child(out.base, header)
        control_set_skin(header, g_headerSkin)
        control_set_size(header, mat.v2_(0.0, 0.1))
        control_set_dock(header, DOCK_TOP)
        control_set_autosize(header, AUTOSIZE_Y)
        window.header = header

        {
            var caption label_id = label_create("label")
            control_add_child(header, caption.base)
            control_set_dock(caption.base, DOCK_FILL)
            control_set_autosize(caption.base, AUTOSIZE_Y)
            label_set_align(caption, ALIGN_CENTER)
            label_set_font(caption, g_boldFont) // ##1 skin
            label_set_color(caption, g_white)
            label_set_size(caption, g_fontSizeHeader)
            window.caption = caption
        }
    }

    {
        var container control_id = control_create("container")
        control_add_child(out.base, container)
        //control_set_skin(container, g_redSkin)
        control_set_dock(container, DOCK_TOP)
        control_set_autosize(container, AUTOSIZE)
        control_set_padding(container, padding1)
        window.container = container
    }

    {
        var strip control_id = control_create("strip")
        control_add_child(out.base, strip)
        //control_set_skin(strip, g_blueSkin)
        control_set_bounds(strip, mat.v4_(0.0, 0.0, 0.0, 0.12))
        control_set_dock(strip, DOCK_TOP)
        control_set_autosize(strip, AUTOSIZE_Y)
        control_set_padding(strip, padding)
        window.strip = strip
    }

    g_windows[out.window] = window
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_add_button(id window_id, name str, caption str, packageName str, functionName str) {
    uti.assert_(is_valid_window(id), "window_add_button : invalid id")

    var button label_id = label_create(name)
    control_set_skin(button.base, g_buttonSkin)
    control_set_bounds(button.base, mat.v4_(0.0, 0.0, 0.15, 0.1))
    control_set_dock(button.base, DOCK_RIGHT)
    control_set_autosize(button.base, AUTOSIZE_Y)
    control_set_padding(button.base, mat.v4_(0.01, 0.01, 0.01, 0.01))
    control_set_focusable(button.base, 1)
    label_set_align(button, ALIGN_CENTER)
    label_set_color(button, g_white)
    label_set_font(button, g_boldFont)
    label_set_text(button, caption)
    label_set_size(button, g_fontSizeButton)
    label_set_on_state(button, packageName, functionName)

    var strip control_id = g_windows[id.window].strip
    control_add_child(strip, button.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_process_event(id window_id, event *event_s) (out i32) {
    uti.assert_(is_valid_window(id), "window_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_resize(id window_id) () {
    uti.assert_(is_valid_window(id), "window_resize : invalid id")
    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func window_render(id window_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_window(id), "window_render : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// KEYBOARD
//-----------------------------------------------------------------------------
var g_keyboards[8] keyboard_s
var g_keyboardCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type keyboard_id struct {
    base control_id
    keyboard i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type keyboard_s struct {
    id keyboard_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_id_(base control_id, keyboard i32) (out keyboard_id) {
    out.base = base
    out.keyboard = keyboard
    uti.assert_(is_valid_keyboard(out), "keyboard_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_keyboard(id keyboard_id) (out bool) {
    out = id.keyboard >= 0 && id.keyboard < g_keyboardCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_keyboard(name str) (out keyboard_id) {
    uti.assert_(g_keyboardCount < len(g_keyboards), "create_keyboard : overflow") // ##1 use slice
    out.keyboard = g_keyboardCount
    out.base = control_create_(name, GUI_KEYBOARD, out.keyboard)

    var keyboard keyboard_s
    keyboard.id = out

    g_keyboards[out.keyboard] = keyboard
    g_keyboardCount = out.keyboard + 1
    uti.assert_(is_valid_keyboard(out), "create_keyboard : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_process_event(id keyboard_id, event *event_s) (out i32) {
    uti.assert_(is_valid_keyboard(id), "keyboard_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func keyboard_resize(id keyboard_id) () {
    uti.assert_(is_valid_keyboard(id), "keyboard_resize : invalid id")
    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*func keyboard_render() () {
    var rowCount i32 = 10
    var lineCount i32 = 4

    var fRowCount f32 = i32.f32(rowCount)
    var fLineCount f32 = i32.f32(lineCount)

    var keyWidth f32 = 0.08
    var keyHeight f32 = 0.08 * gfx.gfx_ratio

    var height f32 = fLineCount * keyHeight + (fLineCount + 1.0) * gui.padding.y
    var width f32 = fRowCount * keyWidth + (fRowCount + 1.0) * gui.padding.x

    var w f32 = width
    var h f32 = height
    var x f32 = -1.0 + (2.0 - w) / 2.0
    var y f32 = -1.0 + gui.padding.y
    gfx.append_quad(g_opaqueVertexColoredTriangles, mat.v4_(x, y, w, h), mat.v4_(0.0, 0.0, 1.0, 1.0), gui.g_gray_2)
    gfx.append_rect(g_opaqueVertexColoredLines, mat.v4_(x, y, w, h), gui.g_gray_3, gui.g_gray_3, gui.g_gray_3, gui.g_gray_3)

    var count i32 = 0
    var i i32 = 0
    var j i32 = 0
    for i = 0; i < rowCount; i = i + 1 {
        for j = 0; j < lineCount; j = j + 1 {
            var kx f32 = gui.padding.x + x + i32.f32(i) * (gui.padding.x + keyWidth)
            var ky f32 = gui.padding.y + y + i32.f32(j) * (gui.padding.y + keyHeight)
            var kw f32 = keyWidth
            var kh f32 = keyHeight
            gfx.append_quad(g_opaqueVertexColoredTriangles, mat.v4_(kx, ky, kw, kh), mat.v4_(0.0, 0.0, 1.0, 1.0), gui.g_blue)
            gfx.append_text(g_alphaTexturedTriangles, g_skycoinFontTexture, "skycoin", kx, ky, gui.g_lightBlue, "A", false, false)
            gfx.append_rect(g_opaqueVertexColoredLines, mat.v4_(kx, ky, kw, kh), gui.g_blue, gui.g_blue, gui.g_blue, gui.g_blue)
            count = count + 1
        }
    }
}*/

func keyboard_render(id keyboard_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_keyboard(id), "keyboard_render : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// PARTITION
//-----------------------------------------------------------------------------
var g_partitions[8] partition_s
var g_partitionCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type partition_id struct {
    base control_id
    partition i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type partition_s struct {
    id partition_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_id_(base control_id, partition i32) (out partition_id) {
    out.base = base
    out.partition = partition
    uti.assert_(is_valid_partition(out), "partition_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_partition(id partition_id) (out bool) {
    out = id.partition >= 0 && id.partition < g_partitionCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_partition(name str) (out partition_id) {
    uti.assert_(g_partitionCount < len(g_partitions), "create_partition : overflow") // ##1 use slice
    out.partition = g_partitionCount
    out.base = control_create_(name, GUI_PARTITION, out.partition)

    var partition partition_s
    partition.id = out

    g_partitions[out.partition] = partition
    g_partitionCount = out.partition + 1
    uti.assert_(is_valid_partition(out), "create_partition : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_process_event(id partition_id, event *event_s) (out i32) {
    uti.assert_(is_valid_partition(id), "partition_process_event : invalid id")
    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_resize(id partition_id) () {
    uti.assert_(is_valid_partition(id), "partition_resize : invalid id")
    control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func partition_render(id partition_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_partition(id), "partition_render : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// GRAPH
//-----------------------------------------------------------------------------
type graph_id struct {
    base control_id
    graph i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type graph_s struct {
    id graph_id
    unit mat.v2
    scale mat.v2
    offset mat.v2
    expX i32
    expY i32
    coord mat.v2
    labels [256] label_id
    labelCount i32
    horz [128] graph_line_s
    horzCount i32
    vert [128] graph_line_s
    vertCount i32
    graphClips mat.v4
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_id_(base control_id, graph i32) (out graph_id) {
    out.base = base
    out.graph = graph
    uti.assert_(is_valid_graph(out), "graph_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_graph(id graph_id) (out bool) {
    out = id.graph >= 0 && id.graph < g_graphCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_graphs[8] graph_s
var g_graphCount i32 = 0

type graph_line_s struct {
    color mat.v4
    bounds mat.v4
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_create(name str) (out graph_id) {
    out.base = control_create_(name, GUI_GRAPH, out.graph)
    control_set_focusable(out.base, 1)

    out.graph = g_graphCount

    g_graphs[g_graphCount].id = out
    g_graphs[g_graphCount].unit = mat.v2_(50.0, 50.0)
    g_graphs[g_graphCount].scale = mat.v2_(1.0, 1.0)
    g_graphs[g_graphCount].offset = mat.v2_(0.0, 0.0)
    g_graphs[g_graphCount].expX = 0
    g_graphs[g_graphCount].expY = 0
    g_graphs[g_graphCount].vertCount = 0
    g_graphs[g_graphCount].horzCount = 0
    var labelCount i32 = 0
    for (labelCount < 256) {
        var label label_id = label_create(sprintf("graphLabel_%d", labelCount))
        g_graphs[g_graphCount].labels[labelCount] = label
        labelCount = labelCount + 1
    }

    g_graphs[g_graphCount].labelCount = labelCount
    g_graphCount = out.graph + 1

    uti.assert_(is_valid_graph(out), "graph_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_process_event(id graph_id, event *event_s) (out i32) {
    uti.assert_(is_valid_graph(id), "graph_process_event : invalid id")
    //control_print("graph_process_event : ", id.base, false)

    out = control_process_event(id.base, event)
    if (out == EVENT_UNUSED) {
        var controlIndex i32 = id.base.control
        var focused i32 = g_controls[controlIndex].focused
        var childFocused i32 = g_controls[controlIndex].childFocused
        if (focused > 0 || childFocused > 0) {
            var key i32 = ((*event).keyboard).key
            var action i32 = ((*event).keyboard).action
            var mods i32 = ((*event).keyboard).mods
            var graphIndex i32 = id.graph
            var unit mat.v2 = g_graphs[graphIndex].unit
            var scale mat.v2 = g_graphs[graphIndex].scale
            var offset mat.v2 = g_graphs[graphIndex].offset
            if (mods == MOD_CTRL) {
                if (action == KEY_PRESS ||
                    action == KEY_REPEAT) {
                    if (key == KEYCODE_LEFT) {
                        out = EVENT_CONSUMED
                        scale.x = scale.x * 0.9
                    } else if (key == KEYCODE_RIGHT) {
                        out = EVENT_CONSUMED
                        scale.x = scale.x * 1.1
                    } else if (key == KEYCODE_DOWN) {
                        out = EVENT_CONSUMED
                        scale.y = scale.y * 0.9
                    } else if (key == KEYCODE_UP) {
                        out = EVENT_CONSUMED
                        scale.y = scale.y * 1.1
                    }
                    if (scale.x > 1.0) {
                        scale.x = 0.1
                        g_graphs[graphIndex].expX = g_graphs[graphIndex].expX + 1
                    } else if (scale.x < 0.1) {
                        scale.x = 1.0
                        g_graphs[graphIndex].expX = g_graphs[graphIndex].expX - 1
                    }

                    if (scale.y > 1.0) {
                        scale.y = 0.1
                        g_graphs[graphIndex].expY = g_graphs[graphIndex].expY + 1
                    } else if (scale.y < 0.1) {
                        scale.y = 1.0
                        g_graphs[graphIndex].expY = g_graphs[graphIndex].expY - 1
                    }
                    g_graphs[graphIndex].scale = scale
                    g_graphs[graphIndex].unit = unit
                }
            } else if (mods == MOD_NONE) {
                if (action == KEY_PRESS ||
                    action == KEY_REPEAT) {
                    if (key == KEYCODE_LEFT) {
                        out = EVENT_CONSUMED
                        offset.x = offset.x - unit.x * 0.1 * scale.x
                    } else if (key == KEYCODE_RIGHT) {
                        out = EVENT_CONSUMED
                        offset.x = offset.x + unit.x * 0.1 * scale.x
                    } else if (key == KEYCODE_DOWN) {
                        out = EVENT_CONSUMED
                        offset.y = offset.y - unit.y * 0.1 * scale.y
                    } else if (key == KEYCODE_UP) {
                        out = EVENT_CONSUMED
                        offset.y = offset.y + unit.y * 0.1 * scale.y
                    }
                    g_graphs[graphIndex].offset = offset
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_resize(id graph_id) () {
    uti.assert_(is_valid_graph(id), "graph_resize : invalid id")
    control_clear_children(id.base)
    control_resize(id.base)

    var graphIndex i32 = id.graph
    g_graphs[graphIndex].coord = mat.v2_(32.0, 32.0)

    var controlIndex i32 = id.base.control

    g_graphs[graphIndex].horzCount = 0
    g_graphs[graphIndex].vertCount = 0
    g_graphs[graphIndex].labelCount = 0

    var graphIndex i32 = id.graph

    var offset mat.v2 = g_graphs[graphIndex].offset
    var unit mat.v2 = g_graphs[graphIndex].unit
    var scale mat.v2 = g_graphs[graphIndex].scale

    var controlIndex i32 = id.base.control

    var width f32 = g_controls[controlIndex].size.x
    var height f32 = g_controls[controlIndex].size.y

    var size mat.v2 = g_controls[controlIndex].size
    var position mat.v2 = g_controls[controlIndex].renderPosition

    var coord mat.v2 = g_graphs[graphIndex].coord

    var stepX f32 = unit.x * scale.x
    var stepY f32 = unit.y * scale.y

    var i i32 = 0
    var ix i32 = 0
    var iy i32 = 0

    var offsetX f32 = offset.x
    if (offsetX > 0) {
        for (offsetX > 0) {
            offsetX = offsetX - stepX
            ix = ix - 1
        }
    } else if (offsetX < 0) {
        for ((offsetX + stepX) < 0) {
            offsetX = offsetX + stepX
            ix = ix + 1
        }
    }

    var offsetY f32 = offset.y
    if (offsetY > 0) {
        for (offsetY > 0) {
            offsetY = offsetY - stepY
            iy = iy - 1
        }
    } else if (offsetY < 0) {
        for ((offsetY + stepY) < 0) {
            offsetY = offsetY + stepY
            iy = iy + 1
        }
    }

    var graphPosition mat.v2
    graphPosition.x = position.x + offsetX + coord.x
    graphPosition.y = position.y + offsetY + coord.y

    var endX f32 = graphPosition.x + size.x - offsetX - coord.x
    var endY f32 = graphPosition.y + size.y - offsetY - coord.y

    g_graphs[graphIndex].graphClips = mat.v4_(graphPosition.x, graphPosition.y, size.x - coord.x, size.y - coord.y)

    var graphLine graph_line_s
    var font font_id

    var horzMax i32 = len(g_graphs[graphIndex].horz)
    i = 0
    var labelX f32 = coord.x + offsetX //- stepX / 2.0
    var x f32 = graphPosition.x
    for (x < endX) {
        var color mat.v4 = g_gray_2

        var labelBounds mat.v4 = mat.v4_(labelX, 0.0, stepX, coord.y)
        var big f32 = labelX - 2.0 * stepX
        var bigW f32 = stepX * 4.0
        if ((ix % 100) == 0) {
            color = g_gray_3
            font = g_boldFont
            labelBounds = mat.v4_(big, 0.0, bigW, coord.y)
        } else if ((ix % 10) == 0) {
            color = mat.v4_mix(g_gray_2, g_gray_3, scale.x)
            font = g_boldFont
            labelBounds = mat.v4_(big, 0.0, bigW, coord.y)
        } else {
            color = mat.v4_mix(g_gray_0, g_gray_2, scale.x)
            font = g_regularFont
            var fTmp f32 = labelX - stepX / 2.0
            labelBounds = mat.v4_(fTmp, 0.0, stepX, coord.y)
        }

        if (i < horzMax) {
            //var graphLine graph_line_s
            graphLine.color = color
            graphLine.bounds = mat.v4_(x, graphPosition.y, x, endY)
            g_graphs[graphIndex].horz[i] = graphLine
            g_graphs[graphIndex].horzCount = i + 1
        }

        var labelCount i32 = g_graphs[graphIndex].labelCount
        if (labelCount < 256) { // ##1 use slice
            var label label_id = g_graphs[graphIndex].labels[labelCount]
            control_add_child(id.base, label.base)
            control_set_bounds(label.base, labelBounds)
            control_set_autoscale(label.base, AUTOSCALE)
            /*if ((ix % 2) == 0) {
                control_set_skin(label.base, g_redSkin)
            } else {
                control_set_skin(label.base, g_greenSkin)
            }*/
           label_set_font(label, g_regularFont)
            label_set_color(label, color)
            label_set_text(label, "0")
            label_set_align(label, ALIGN_CENTER)
            label_set_size(label, 10)
            label_resize(label)
            control_set_bounds(label.base, labelBounds)
            g_graphs[graphIndex].labelCount = labelCount + 1
        }

        labelX = labelX + stepX
        x = x + stepX
        ix = ix + 1
        i = i + 1
    }

    var vertMax i32 = len(g_graphs[graphIndex].vert)
    i = 0
    var labelY f32 = coord.y + offsetY// - stepY / 2.0
    var y f32 = graphPosition.y
    for (y < endY) {
        var color mat.v4 = g_gray_2
        //var font font_id

        var fTmp f32 = labelY - stepY / 2.0
        var labelBounds mat.v4 = mat.v4_(0.0, fTmp, coord.x, coord.y)
        //var big f32 = labelY - 2.0 * stepY
        //var bigW f32 = stepY * 4.0
        if ((iy % 100) == 0) {
            color = g_gray_3
            font = g_boldFont
        var fTmp0 f32 = labelY - coord.y / 2.0
            labelBounds = mat.v4_(0.0, fTmp0, coord.x, coord.y)
        } else if ((iy % 10) == 0) {
            color = mat.v4_mix(g_gray_2, g_gray_3, scale.y)
            font = g_boldFont
        var fTmp0 f32 = labelY - coord.y / 2.0
            labelBounds = mat.v4_(0.0, fTmp0, coord.x, coord.y)
        } else {
            color = mat.v4_mix(g_gray_0, g_gray_2, scale.y)
            font = g_regularFont
            labelBounds = mat.v4_(0.0, fTmp, coord.x, stepY)
        }

        if (i < vertMax) {
            //var graphLine graph_line_s
            graphLine.color = color
            graphLine.bounds = mat.v4_(graphPosition.x, y, endX, y)
            g_graphs[graphIndex].vert[i] = graphLine
            g_graphs[graphIndex].vertCount = i + 1
        }

        var labelCount i32 = g_graphs[graphIndex].labelCount
        if (labelCount < 256) { // ##1 use slice
            var label label_id = g_graphs[graphIndex].labels[labelCount]
            control_add_child(id.base, label.base)
            control_set_bounds(label.base, labelBounds)
            control_set_autoscale(label.base, AUTOSCALE)
            /*if ((iy % 2) == 0) {
                control_set_skin(label.base, g_redSkin)
            } else {
                control_set_skin(label.base, g_greenSkin)
            }*/
             label_set_font(label, g_regularFont)
            label_set_color(label, color)
            label_set_text(label, "0")
            label_set_align(label, ALIGN_CENTER)
            label_set_size(label, 50)
            label_resize(label)
            control_set_bounds(label.base, labelBounds)
            g_graphs[graphIndex].labelCount = labelCount + 1
        }

        labelY = labelY + stepY
        y = y + stepY
        iy = iy + 1
        i = i + 1
    }

    //control_resize(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func graph_render(id graph_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_graph(id), "graph_render : invalid id")
    control_render(id.base, clip, stack)

    var controlIndex i32 = id.base.control
    var graphIndex i32 = id.graph

    var renderBounds mat.v4 = mat.v4_v2v2(g_controls[controlIndex].renderPosition, g_controls[controlIndex].size)
    //control_print("graph_render : renderBounds ", id.base, false)
      //  printf("renderBounds %f, %f, %f, %f\n", renderBounds.x, renderBounds.y, renderBounds.z, renderBounds.w)
    var renderClips mat.v4 = gfx.push_scissor(g_controls[controlIndex].name, renderBounds)
    //control_print("graph_render : graphClips ", id.base, false)
    var graphClips mat.v4 = g_graphs[graphIndex].graphClips
      //  printf("graphClips %f, %f, %f, %f\n", graphClips.x, graphClips.y, graphClips.z, graphClips.w)
    renderClips = gfx.push_scissor(g_controls[controlIndex].name, graphClips)

    var i i32 = 0
    var horzCount i32 = g_graphs[graphIndex].horzCount
    for i = 0; i < horzCount; i = i + 1 {
        var bounds mat.v4 = g_graphs[graphIndex].horz[i].bounds
        var color mat.v4 = g_graphs[graphIndex].horz[i].color
        gfx.append_line(g_opaqueVertexColoredLines, bounds, color, renderClips, compute_depth(stack))
    }

    var vertCount i32 = g_graphs[graphIndex].vertCount
    for i = 0; i < vertCount; i = i + 1 {
        var bounds mat.v4 = g_graphs[graphIndex].vert[i].bounds
        var color mat.v4 = g_graphs[graphIndex].vert[i].color
        /*if (i == 3) {
            color = mat.v4_(0.0, 1.0, 0.0, 1.0)
            bounds.y = bounds.y + 0.01
            bounds.w = bounds.w + 0.01
        }*/
//        printf("II %d, COLOR %f, %f, %f, %f, BOUNDS %f, %f, %f, %f\n",
  //          i, color.x, color.y, color.z, color.w, bounds.x, bounds.y, bounds.z, bounds.w)
        gfx.append_line(g_opaqueVertexColoredLines, bounds, color, renderClips, compute_depth(stack))
    }
    gfx.pop_scissor()
    gfx.pop_scissor()
}

//-----------------------------------------------------------------------------
// LIST
//-----------------------------------------------------------------------------
type list_id struct {
    base control_id
    list i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type list_s struct {
    id list_id

    header control_id
    columnCount i32
    scroller scroller_id
    lines control_id
    lineCount i32
    offset mat.v2
    selectedLine i32
    selectedItem i32
    previousSelectedLine i32
    previousSelectedItem i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_id_(base control_id, list i32) (out list_id) {
    out.base = base
    out.list = list
    uti.assert_(is_valid_list(out), "list_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_list(id list_id) (out bool) {
    out = id.list >= 0 && id.list < g_listCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_lists[8] list_s
var g_listCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_create(name str) (out list_id) {
    uti.assert_(g_listCount < len(g_lists), "list_create : overflow") // ##1 use slice
    out.list = g_listCount
    out.base = control_create_(name, GUI_LIST, g_listCount)

    var list list_s
    g_lists[g_listCount].id = out

    var controlIndex i32 = out.base.control
    //control_set_padding(out.base, mat.v4_(0.01, 0.01, 0.01, 0.01))

    var header control_id = control_create("header")
    control_add_child(out.base, header)
    control_set_dock(header, DOCK_TOP)
    //control_set_size(header, mat.v2_(0.0, 28.0))
    control_set_autosize(header, AUTOSIZE_Y)
    control_set_skin(header, g_blackSkin)
    g_lists[g_listCount].header = header

    {
        var scroller scroller_id = scroller_create("scroller")
        control_add_child(out.base, scroller.base)
        control_set_dock(scroller.base, DOCK_FILL)
        //control_set_autosize(scroller.base, AUTOSIZE_Y)

        var lines control_id = control_create("lines")
        //control_set_dock(lines, DOCK_FILL)
        control_set_autosize(lines, AUTOSIZE_Y)
        control_set_skin(lines, g_blackSkin)
        g_lists[g_listCount].lines = lines

        scroller_set_containee(scroller, lines)
        g_lists[g_listCount].scroller = scroller
    }

    g_lists[g_listCount].columnCount = 0
    g_lists[g_listCount].lineCount = 0
    g_lists[g_listCount].selectedItem = -1
    g_lists[g_listCount].selectedLine = -1
    g_lists[g_listCount].previousSelectedItem = -1
    g_lists[g_listCount].previousSelectedLine = -1
    g_listCount = g_listCount + 1
    uti.assert_(is_valid_list(out), "list_create : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_add_column(id list_id, name str, color mat.v4, size i32) {
    uti.assert_(is_valid_list(id), "list_add_column : invalid id")

    var listIndex i32 = id.list
    var columnCount i32 = g_lists[listIndex].columnCount
    var column label_id = label_create(sprintf("column_%d", columnCount))
    control_set_dock(column.base, DOCK_LEFT)
    //control_set_size(column.base, mat.v2_(0.0, 26.0))
    control_set_skin(column.base, g_buttonSkin)
    control_set_focusable(column.base, 1)
    control_set_autosize(column.base, AUTOSIZE_Y)
    control_set_padding(column.base, mat.v4_(3.0, 0.0, 3.0, 0.0))
    label_set_font(column, g_boldFont)
    label_set_text(column, name)
    label_set_size(column, size)
    label_set_color(column, color)
    label_set_align(column, ALIGN_CENTER)

    control_print("list_add_column : ", column.base, false)
    g_lists[listIndex].columnCount = columnCount + 1
    var header control_id = g_lists[listIndex].header
    control_add_child(header, column.base)
    printf("childCount %d\n", g_controls[header.control].childCount)
    //uti.assert_(false, "fuck")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_clear_lines(id list_id) {
    uti.assert_(is_valid_list(id), "list_clear_lines : invalid id")

    var lines control_id = g_lists[id.list].lines
    control_clear_children(lines)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_add_line(id list_id) (out control_id) {
    uti.assert_(is_valid_list(id), "list_add_line")
    var listIndex i32 = id.list
    var lineCount i32 = g_lists[listIndex].lineCount
    var line control_id = control_create(sprintf("line_%d", lineCount))

    var lines control_id = g_lists[id.list].lines
    control_set_dock(line, DOCK_TOP)
    control_set_size(line, mat.v2_(0.0, 0.0))
    control_set_autosize(line, AUTOSIZE_Y)
    control_add_child(lines, line)
    //control_set_skin(line, g_grayFocusedSkin)
    //control_set_focusable(line, 1)
    g_lists[listIndex].lineCount = lineCount + 1
    out = line
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_line_add_label(id control_id, text str, align i32, color mat.v4, size i32, skin skin_id) {
    uti.assert_(is_valid_control(id), "list_line_add_label : invalid id")

    var lineName str = g_controls[id.control].name
    var itemCount i32 = g_controls[id.control].childCount
    var itemName str = sprintf("%s_item_%d", lineName, itemCount)
    var label label_id = label_create(itemName)

    control_add_child(id, label.base)
    control_set_dock(label.base, DOCK_LEFT)
    if (is_valid_skin(skin)) {
    control_set_skin(label.base, skin)
    }
    control_set_padding(label.base, mat.v4_(3.0, 0.0, 3.0, 0.0))
    control_set_focusable(label.base, 1)
    control_set_autosize(label.base, AUTOSIZE_Y)
    label_set_font(label, g_regularFont)
    label_set_text(label, text)
    label_set_size(label, size)
    label_set_color(label, color)
    label_set_align(label, align)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_line_add_picture(id control_id, align i32, texture texture_s) {
    uti.assert_(is_valid_control(id), "list_line_add_picture : invalid id")

    var lineName str = g_controls[id.control].name
    var itemCount i32 = g_controls[id.control].childCount
    var itemName str = sprintf("%s_item_%d", lineName, itemCount)
    var label picture_id = picture_create(itemName)

    control_add_child(id, label.base)
    control_set_dock(label.base, DOCK_LEFT)
    //control_set_skin(label.base, g_grayFocusedSkin)
    control_set_padding(label.base, mat.v4_(3.0, 0.0, 3.0, 0.0))
    control_set_size(label.base, mat.v2_(32.0, 32.0))
    control_set_focusable(label.base, 1)
    control_set_autoscale(label.base, AUTOSCALE)
    //control_set_align(label, align)
    picture_set_align(label, align)
    picture_set_texture(label, texture)
    /*label_set_font(label, g_regularFont)
    label_set_text(label, text)
    label_set_size(label, size)
    label_set_color(label, color)
    label_set_align(label, align)*/
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_child_focused(id list_id, child control_id, value i32) {
    uti.assert_(is_valid_list(id), "list_child_focus : invalid id")

    if (value > 0) {

    var selectedLine i32 = g_lists[id.list].selectedLine
    var selectedItem i32 = g_lists[id.list].selectedItem

    var header control_id = g_lists[id.list].header
    var panel control_id = g_lists[id.list].lines

    var headerFocused i32 = g_controls[header.control].focused
    var headerChildFocused i32 = g_controls[header.control].childFocused
    var headerVisible i32 = g_controls[header.control].visible
    var headerOffset i32 = 0
    if (headerVisible <= 0) {
        headerOffset = 1
    }
    var panelFocused  i32 = g_controls[panel.control].focused
    var panelChildFocused i32 = g_controls[panel.control].childFocused

    if (panelFocused > 0 || panelChildFocused > 0 || headerFocused > 0 || headerChildFocused > 0) {
    //control_print("list_child_focused panel : ", panel, false)
    var columnCount i32 = g_controls[header.control].childCount
    var lineCount i32 = g_controls[panel.control].childCount

    if (columnCount > 0) {

        if (selectedLine < 0) {
            selectedLine = headerOffset
        }

        if (selectedItem < 0) {
            selectedItem = 0
        }

        var selectedLineId control_id
        if (selectedLine > headerOffset) {
            var currentLine i32 = selectedLine - 1
            selectedLineId = g_controls[panel.control].children[currentLine]
        } else {
            selectedLineId = header
        }
        var previousSelectedLine i32 = g_lists[id.list].previousSelectedLine
        var previousSelectedItem i32 = g_lists[id.list].previousSelectedItem
        var selectedItemId control_id = g_controls[selectedLineId.control].children[selectedItem]
        g_lists[id.list].previousSelectedLine = g_lists[id.list].selectedLine
        g_lists[id.list].previousSelectedItem = g_lists[id.list].selectedItem
        g_lists[id.list].selectedLine = selectedLine
        g_lists[id.list].selectedItem = selectedItem

        g_controls[selectedLineId.control].selected = 1
        g_controls[selectedItemId.control].selected = 1
        if (selectedItemId.control != child.control) {
            control_print("list_child_focused : force_focus SELECTED : ", selectedItemId, false)
            control_print("list_child_focused : force_focus CHILD : ", child, false)
            force_focus(selectedItemId)
        }
    }
    }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_process_event(id list_id, event *event_s) (out i32) {
    uti.assert_(is_valid_list(id), "list_process_event : invalid id")
    out = control_process_event(id.base, event)


    if (out == EVENT_UNUSED) {
        var index i32 = id.base.control
        var columns control_id = g_lists[id.list].header
        var columnsIndex i32 = columns.control
        var headerFocused i32 = g_controls[columnsIndex].childFocused
        var headerVisible i32 = g_controls[columnsIndex].visible
        var lines control_id = g_lists[id.list].lines
        var linesIndex i32 = lines.control
        var focused i32 = g_controls[linesIndex].childFocused
        var mods i32 = ((*event).keyboard).mods
        var action i32 = ((*event).keyboard).action
        var lineCount i32 = g_controls[linesIndex].childCount
        var itemCount i32 = g_controls[columnsIndex].childCount
        if (lineCount > 0) {
            if ((headerFocused > 0 || focused > 0) && action == KEY_PRESS) {
                var key i32 = ((*event).keyboard).key
                var action i32 = ((*event).keyboard).action
                var selectedLine i32 = g_lists[id.list].selectedLine
                var selectedItem i32 = g_lists[id.list].selectedItem
     
                var headerOffset i32 = 0
                if (headerVisible <= 0) {
                    headerOffset = 1
                }
                if (key == KEYCODE_LEFT) {
                    selectedItem = selectedItem - 1
                    if (selectedItem < 0) {
                        selectedItem = itemCount - 1
                    }
                    out = EVENT_CONSUMED
                } else if (key == KEYCODE_DOWN) {
                    selectedLine = selectedLine + 1
                    if (selectedLine > lineCount) {
                        if (mods == MOD_CTRL) {
                            selectedLine = lineCount
                            out = EVENT_UNUSED
                            //printf("EVENT_UNUSED\n")
                        }else {
                            selectedLine = headerOffset
                            out = EVENT_CONSUMED
                        }
                   }
                } else if (key == KEYCODE_RIGHT) {
                    selectedItem = selectedItem + 1
                    if (selectedItem >= itemCount) {
                        selectedItem = 0
                    }
                    out = EVENT_CONSUMED
                } else if (key == KEYCODE_UP) {
                    selectedLine = selectedLine - 1
                    if (selectedLine < headerOffset) {
                        if (mods == MOD_CTRL) {
                            selectedLine = selectedLine + 1
                            out = EVENT_UNUSED
                            //printf("EVENT_UNUSED\n")
                        } else {
                            selectedLine = lineCount
                            out = EVENT_CONSUMED
                        }
                    }
                } else if (key == KEYCODE_TAB) {
                    if (mods == MOD_SHIFT) {
                        if (selectedItem > 0) {
                            selectedItem = selectedItem - 1
                            out = EVENT_CONSUMED
                        } else {
                            if (selectedLine > headerOffset) {
                                selectedLine = selectedLine - 1
                                selectedItem = itemCount - 1
                                out = EVENT_CONSUMED
                            } else {
                                out = EVENT_UNUSED
                            }
                        }
                    } else {
                        if ((selectedItem + 1) < itemCount) {
                            selectedItem = selectedItem + 1
                            out = EVENT_CONSUMED
                        } else {
                            if ((selectedLine + 1) <= lineCount) {
                                selectedLine = selectedLine + 1
                                selectedItem = 0
                                out = EVENT_CONSUMED
                            } else {
                                out = EVENT_UNUSED
                            }
                        }
                    }
                }

                g_lists[id.list].selectedLine = selectedLine
                g_lists[id.list].selectedItem = selectedItem
                //printf("SELECTED LINE %d, ITEM %d\n", selectedLine, selectedItem)
            }
        } else {
            g_lists[id.list].selectedLine = -1
            g_lists[id.list].selectedItem = -1
        }
    }
    //printf("list_process_event : OUT %d\n", out)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_resize(id list_id) () {
    uti.assert_(is_valid_list(id), "resize_list : invalid id")

    var listIndex i32 = id.list
    var header control_id = g_lists[listIndex].header
    var headerIndex i32 = header.control

    var scroller scroller_id = g_lists[listIndex].scroller
    var scrollerContainer control_id = g_scrollers[scroller.scroller].container
    var scrollerPanel control_id = g_scrollers[scroller.scroller].panel

    var lines control_id = g_lists[listIndex].lines
    var linesIndex i32 = lines.control
    var columnCount i32 = g_controls[headerIndex].childCount
    var lineCount i32 = g_controls[linesIndex].childCount
    var i i32 = 0

    /*if (id.base.control == 36) {
        printf("--------------------------------> list_resize\n")
        control_print("list_resize : ", id.base, false)
        control_print("list_resize : LINES ", lines, false)
        printf("columnCount %d, lineCount %d, listIndex %d, headerIndex %d, linesIndex %d\n", columnCount, lineCount, listIndex, headerIndex, linesIndex)
    }*/

    var containerWidth f32 = g_controls[scrollerContainer].size.x
    var scrollerWidth f32 = g_controls[scroller.base.control].size.x

    var lineWidth f32 = 0.0
    for i = 0; i < columnCount; i = i + 1 {
    var maxWidth f32 = 0.0
        var column control_id = g_controls[headerIndex].children[i]
        /*if (id.base.control == 36) {
            control_print("list_resize : column ", column, false)
        }*/
        var columnIndex i32 = column.control
        g_controls[column.control].selected = 0

        var width f32
        var height f32
        width, height = control_measure(column)
        //printf("COLUMN_MEASURE %f, %f\n", width, height)
        maxWidth = mat.max(maxWidth, width)
        var k i32 = 0
        for k = 0; k < lineCount; k = k + 1 {
            var line control_id = g_controls[linesIndex].children[k]
            var lineIndex i32 = line.control
            /*if (id.base.control == 36) {
                control_print("list_resize : line ", line, false)
            }*/

            var item control_id = g_controls[lineIndex].children[i]
            //control_print("list_resize : item ", item, false)
            var itemIndex i32 = item.control

            width, height = control_measure(item)
            //printf("ITEM_MEASURE %f, %f\n", width, height)
            maxWidth = mat.max(maxWidth, width)
            //printf("WIDTH %f, MAX_WIDTH %f\n", width, maxWidth)
        }
        //printf("MAX_WIDTH %f\n", maxWidth)
        g_controls[columnIndex].size.x = maxWidth
        if ((i + 1) == columnCount) {
            control_set_dock(column, DOCK_FILL)
            g_controls[columnIndex].size.x = mat.max(maxWidth, scrollerWidth - lineWidth)
        }

        //control_print("column : ", column, false)
        for k = 0; k < lineCount; k = k + 1 {
            var line control_id = g_controls[linesIndex].children[k]
            var lineIndex i32 = line.control
            if (i == 0) {
                g_controls[lineIndex].size.x = 0.0
            }
            var currentWidth f32 = g_controls[lineIndex].size.x
            g_controls[lineIndex].size.x = currentWidth + maxWidth
            //printf("i %d, lineIndex %d, line %d, width %f\n", i, lineIndex, k, width)
            //control_print("line : ", line, false)
            var item control_id = g_controls[lineIndex].children[i]
            var itemIndex i32 = item.control

            g_controls[itemIndex].size.x = maxWidth
            g_controls[itemIndex].selected = 0
            g_controls[lineIndex].selected = 0
            if ((i + 1) == columnCount) {
                control_set_dock(item, DOCK_FILL)
                g_controls[itemIndex].size.x = mat.max(maxWidth, containerWidth - lineWidth)
            }

            /*var focusedItem i32 = g_controls[itemIndex].focused
            if (focusedItem > 0) {
                g_lists[listIndex].selectedLine = k
                g_lists[listIndex].selectedItem = i
            }*/
            //control_print("item : ", item, false)
        }
        lineWidth = lineWidth + maxWidth
    }

    var headerVisible i32 = g_controls[headerIndex].visible
    var headerOffset i32 = 0
    if (headerVisible <= 0) {
        headerOffset = 1
    }
    if (lineCount > 0 && columnCount > 0) {

        var selectedLine i32 = g_lists[listIndex].selectedLine
        if (selectedLine < 0) {
            selectedLine = headerOffset
        }

        var selectedItem i32 = g_lists[listIndex].selectedItem
        if (selectedItem < 0) {
            selectedItem = 0
        }

        var selectedLineId control_id
        if (selectedLine > headerOffset) {
            var currentLine i32 = selectedLine - 1
            selectedLineId = g_controls[linesIndex].children[currentLine]
        } else {
            selectedLineId = header
        }
        var selectedItemId control_id = g_controls[selectedLineId.control].children[selectedItem]

        var previousSelectedLine i32 = g_lists[listIndex].previousSelectedLine
        var previousSelectedItem i32 = g_lists[listIndex].previousSelectedItem
        if (selectedLine != previousSelectedLine || selectedItem != previousSelectedItem) {
            //printf("selectedLine child, %d, index %d, selectedItem child %d, index %d\n", selectedLineId.control, selectedLine, selectedItemId.control, selectedItem)
            force_focus(selectedItemId)
        }

        g_lists[listIndex].previousSelectedLine = g_lists[listIndex].selectedLine
        g_lists[listIndex].previousSelectedItem = g_lists[listIndex].selectedItem
        g_lists[listIndex].selectedLine = selectedLine
        g_lists[listIndex].selectedItem = selectedItem

        //g_controls[selectedLineId.control].selected = 1
        //g_controls[selectedItemId.control].selected = 1
    }

    g_controls[linesIndex].size.x = mat.max(lineWidth, containerWidth)

    {
        control_resize(id.base)
    }


    var focusedLine control_id = invalid_control()
    for i = 0; i < lineCount; i = i + 1 {
        var line control_id = g_controls[linesIndex].children[i]
        var lineIndex i32 = line.control
        if (g_controls[lineIndex].childFocused > 0) {
            focusedLine = line
            i = lineCount
        }
    }


    /*if (is_valid_control(focusedLine)) {
       g_controls[linesIndex].position.x = g_lists[listIndex].offset.x
       g_controls[linesIndex].position.y = g_lists[listIndex].offset.y
    }*/

    //printf("columnCount %d\n", g_controls[headerIndex].childCount)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func list_render(id list_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_list(id), "render_list : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// LIFTER
//-----------------------------------------------------------------------------
var LIFT_VERT i32 = 0
var LIFT_HORZ i32 = 1

type lifter_id struct {
    base control_id
    lifter i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type lifter_s struct {
    id lifter_id
    carret control_id
    direction i32
    offset f32
    size f32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_id_(base control_id, lifter i32) (out lifter_id) {
    uti.assert_(g_lifterCount < len(g_lifters), "lifter_create : overflow") // ##1 use slice
    out.base = base
    out.lifter = lifter
    uti.assert_(is_valid_lifter(out), "lifter_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_lifter(id lifter_id) (out bool) {
    out = id.lifter >= 0 && id.lifter < g_lifterCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_lifter() (out lifter_id) {
    out.base = invalid_control()
    out.lifter = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_set_size(id lifter_id, value f32) {
    uti.assert_(is_valid_lifter(id), "lifter_set_size : invalid id")
    g_lifters[id.lifter].size = value
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_lifters[16] lifter_s
var g_lifterCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_create(name str) (out lifter_id) {
    out.lifter = g_lifterCount
    out.base = control_create_(name, GUI_LIFTER, g_lifterCount)

    var lifter lifter_s
    g_lifters[g_lifterCount].id = out

    control_set_skin(out.base, g_blackSkin)

    var carret control_id = control_create("carret")
    g_lifters[g_lifterCount].carret = carret

    control_add_child(out.base, carret)
    //control_set_dock(carret, DOCK_TOP)
    //control_set_size(carret, mat.v2_(0.03, 0.03 * gfx.gfx_ratio_y))
    control_set_skin(carret, g_buttonSkin)
    control_set_focusable(carret, 1)

    g_lifterCount = g_lifterCount + 1
    uti.assert_(is_valid_lifter(out), "create_lifter : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_set_direction(id lifter_id, direction i32) {
    uti.assert_(is_valid_lifter(id), "lifter_set_direction : invalid id")
    uti.assert_(direction == LIFT_VERT || direction == LIFT_HORZ, "lifter_set_direction : unknown direction")
    g_lifters[id.lifter].direction = direction
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_process_event(id lifter_id, event *event_s) (out i32) {
    uti.assert_(is_valid_lifter(id), "lifter_process_event : invalid id")
    out = control_process_event(id.base, event)

    if (out == EVENT_UNUSED) {
        var focused i32 = g_controls[id.base.control].childFocused
        if (focused > 0) {
            var mods i32 = ((*event).keyboard).mods
            if (mods == MOD_NONE) {
                var action i32 = ((*event).keyboard).action
                if (action == KEY_PRESS) {
                    var key i32 = ((*event).keyboard).key
                    var direction i32 = g_lifters[id.lifter].direction
                    var carret control_id = g_lifters[id.lifter].carret
                    var offset f32 = lifter_get_offset(id)
                    if (key == KEYCODE_LEFT ||
                        key == KEYCODE_UP) {
                        if (direction == LIFT_HORZ ||
                            direction == LIFT_VERT) {
                            offset = offset - 3.0
                            out = EVENT_CONSUMED
                            force_focus(carret)
                        } else {
                            uti.assert_(false, "lifter_process_event : unknown direction")
                        }
                    } else if (key == KEYCODE_RIGHT ||
                               key == KEYCODE_DOWN) {
                        if (direction == LIFT_HORZ ||
                            direction == LIFT_VERT) {
                            offset = offset + 3.0
                            out = EVENT_CONSUMED
                            force_focus(carret)
                        } else {
                            uti.assert_(false, "lifter_process_event : unknown direction")
                        }
                    }
                    lifter_set_offset(id, offset)
                }
            }
        }
    }
    //printf("list_process_event : OUT %d\n", out)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_get_amount(id lifter_id) (out f32) {
    uti.assert_(is_valid_lifter(id), "lifter_get_amount : invalid id")
    var direction i32 = g_lifters[id.lifter].direction
    var carret control_id = g_lifters[id.lifter].carret
    if (direction == LIFT_HORZ) {
        out = g_controls[carret.control].size.x
    } else if (direction == LIFT_VERT) {
        out = g_controls[carret.control].size.y
    } else {
        uti.assert_(false, "invalid direction")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_set_amount(id lifter_id, value f32) {
    uti.assert_(is_valid_lifter(id), "lifter_set_amount : invalid id")
    var direction i32 = g_lifters[id.lifter].direction
    var carret control_id = g_lifters[id.lifter].carret
    if (direction == LIFT_HORZ) {
        g_controls[carret.control].size.x = value
    } else if (direction == LIFT_VERT) {
        g_controls[carret.control].size.y = value
    } else {
        uti.assert_(false, "invalid direction")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_get_max_amount(id lifter_id) (out f32) {
    uti.assert_(is_valid_lifter(id), "lifter_get_amount : invalid id")
    var direction i32 = g_lifters[id.lifter].direction
    var size mat.v2 = g_controls[id.base.control].size
    if (direction == LIFT_HORZ) {
        out = size.x
    } else if (direction == LIFT_VERT) {
        out = size.y
    } else {
        uti.assert_(false, "invalid direction")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_set_max_amount(id lifter_id, value f32) {
    uti.assert_(is_valid_lifter(id), "lifter_set_amount : invalid id")
    var direction i32 = g_lifters[id.lifter].direction
    if (direction == LIFT_HORZ) {
        g_controls[id.base.control].size.x = value
    } else if (direction == LIFT_VERT) {
        g_controls[id.base.control].size.y = value
    } else {
        uti.assert_(false, "invalid direction")
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_get_offset(id lifter_id) (out f32) {
    uti.assert_(is_valid_lifter(id), "lifter_get_amount : invalid id")
    out = g_lifters[id.lifter].offset
    /*var direction i32 = g_lifters[id.lifter].direction
    var carret control_id = g_lifters[id.lifter].carret
    if (direction == LIFT_HORZ) {
        out = g_controls[carret.control].position.x
    } else if (direction == LIFT_VERT) {
        out = g_controls[carret.control].position.y
    } else {
        uti.assert_(false, "invalid direction")
    }*/
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_set_offset(id lifter_id, value f32) {
    uti.assert_(is_valid_lifter(id), "lifter_set_amount : invalid id")
    g_lifters[id.lifter].offset = value
    /*var direction i32 = g_lifters[id.lifter].direction
    if (direction == LIFT_HORZ) {
        g_controls[carret.control].position.x = value
    } else if (direction == LIFT_VERT) {
        g_controls[carret.control].position.y = value
    } else {
        uti.assert_(false, "invalid direction")
    }*/
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_get_max_offset(id lifter_id) (out f32) {
    uti.assert_(is_valid_lifter(id), "lifter_get_max_offset : invalid id")
    var maxAmount f32 = lifter_get_max_amount(id)
    var amount f32 = lifter_get_amount(id)
    out = maxAmount - amount
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_resize(id lifter_id) () {
    uti.assert_(is_valid_lifter(id), "resize_lifter : invalid id")

    var lifterIndex i32 = id.lifter
    var direction i32 = g_lifters[lifterIndex].direction

    //var center control_id = g_lifters[lifterIndex].center
    //var centerIndex i32 = center.control

    var carret control_id = g_lifters[lifterIndex].carret
    var carretIndex i32 = carret.control

    var lifterSize f32 = g_lifters[id.lifter].size

    {
        control_resize(id.base)
    }

    var offset f32 = lifter_get_offset(id)
    var maxAmount f32 = lifter_get_max_amount(id)
    var amount f32 = lifter_get_amount(id)

    if (offset + amount > maxAmount) {
        offset = maxAmount - amount
    }
    if (offset < 0.0) {
        offset = 0.0
    }

    if (direction == LIFT_HORZ) {
        g_controls[carret.control].position.x = offset
        g_controls[carretIndex].size.y = lifterSize * gfx.gfx_ratio_y
    } else if (direction == LIFT_VERT) {
        var centerH f32 = g_controls[id.base.control].size.y
        var carretH f32 = g_controls[carret.control].size.y

        var offsetY f32 = centerH - carretH - offset
        //printf("REOFFSET %f, %f, %f, %f\n", offset, carretH, centerH, offsetY)
        g_controls[carret.control].position.y = offsetY
        g_controls[carretIndex].size.x = lifterSize
    } else {
        uti.assert_(false, "lifter_resize : unknown direction")
    }

    lifter_set_offset(id, offset)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func lifter_render(id lifter_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_lifter(id), "render_lifter : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// SCROLLER
//-----------------------------------------------------------------------------
type scroller_id struct {
    base control_id
    scroller i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type scroller_s struct {
    id scroller_id
    panel control_id
    container control_id
    containee control_id
    vlift lifter_id
    hlift lifter_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_id_(base control_id, scroller i32) (out scroller_id) {
    uti.assert_(g_scrollerCount < len(g_scrollers), "scroller_create : overflow") // ##1 use slice
    out.base = base
    out.scroller = scroller
    uti.assert_(is_valid_scroller(out), "scroller_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_scroller(id scroller_id) (out bool) {
    out = id.scroller >= 0 && id.scroller < g_scrollerCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_set_containee(id scroller_id, containee control_id) {
    uti.assert_(is_valid_scroller(id), "scroller_set_containee : invalid id")
    uti.assert_(is_valid_control(containee), "scroller_set_containee : invalid control")
    var container control_id = g_scrollers[id.scroller].container
    control_clear_children(container)
    control_add_child(container, containee)
    g_scrollers[id.scroller].containee = containee
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_scrollers[8] scroller_s
var g_scrollerCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_create(name str) (out scroller_id) {
    out.scroller = g_scrollerCount
    out.base = control_create_(name, GUI_SCROLLER, g_scrollerCount)

    var lifterSize f32 = 8.0

    var scroller scroller_s
    g_scrollers[g_scrollerCount].id = out

    var vlift lifter_id = lifter_create("vlift")
    control_add_child(out.base, vlift.base)
    control_set_size(vlift.base, mat.v2_(lifterSize, 0.0))
    control_set_dock(vlift.base, DOCK_RIGHT)
    control_set_focus_index(vlift.base, 1)
    //control_set_skin(vlift.base, g_debugBlueSkin)
    lifter_set_direction(vlift, LIFT_VERT)
    lifter_set_size(vlift, lifterSize)
    g_scrollers[g_scrollerCount].vlift = vlift

    var panel control_id = control_create("panel")
    control_add_child(out.base, panel)
    control_set_dock(panel, DOCK_FILL)
 //   control_set_autosize(panel, AUTOSIZE_Y)
    control_set_focus_index(panel, 0)
    g_scrollers[g_scrollerCount].panel = panel

    var hlift lifter_id = lifter_create("hlift")
    control_add_child(panel, hlift.base)
    control_set_size(hlift.base, mat.v2_(0.0, lifterSize))
    control_set_dock(hlift.base, DOCK_BOTTOM)
    control_set_focus_index(hlift.base, 1)
    //control_set_skin(hlift.base, g_greenSkin)
    lifter_set_direction(hlift, LIFT_HORZ)
    lifter_set_size(hlift, lifterSize)
    g_scrollers[g_scrollerCount].hlift = hlift

    var container control_id = control_create("container")
    control_add_child(panel, container)
    control_set_dock(container, DOCK_FILL)
    //control_set_autosize(container, AUTOSIZE_Y)
    //control_set_skin(container, g_blueSkin)
    control_set_focus_index(container, 0)
    g_scrollers[g_scrollerCount].container = container

    g_scrollerCount = g_scrollerCount + 1
    uti.assert_(is_valid_scroller(out), "create_scroller : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_process_event(id scroller_id, event *event_s) (out i32) {
    uti.assert_(is_valid_scroller(id), "scroller_process_event : invalid id")

    out = EVENT_UNUSED
    var vlift lifter_id = g_scrollers[id.scroller].vlift
    var vliftFocused i32 = control_focused(vlift.base)

    var hlift lifter_id = g_scrollers[id.scroller].hlift
    var hliftFocused i32 = control_focused(hlift.base)

    if (vliftFocused > 0 || hliftFocused > 0) {
        var action i32 = ((*event).keyboard).action
        if (action == KEY_PRESS) {
            var key i32 = ((*event).keyboard).key
            var lift lifter_id = invalid_lifter()
            if (/*hliftFocused > 0 &&*/
                (key == KEYCODE_LEFT ||
                 key == KEYCODE_RIGHT)) {
                lift = hlift
                control_print("HLIFT ", hlift.base, false)
            } else if (/*vliftFocused > 0 &&*/
                      (key == KEYCODE_UP ||
                       key == KEYCODE_DOWN)) {
                lift = vlift
                control_print("VLIFT ", vlift.base, false)
            }

            if (is_valid_lifter(lift)) {
                var visible i32 = g_controls[lift.base.control].visible
                if (visible > 0) {
                    var carret control_id = g_lifters[lift.lifter].carret
                    force_focus(carret)
                }
            }
        }
    }

    out = control_process_event(id.base, event)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_resize(id scroller_id) () {
    uti.assert_(is_valid_scroller(id), "resize_scroller : invalid id")

    //control_print("scroller_resize : ", id.base, false)
    var container control_id = g_scrollers[id.scroller].container
    var maxSize mat.v2 = g_controls[container.control].size
    //printf("MAXSIZE %f, %f\n", maxSize.x, maxSize.y)

    var containee control_id = g_scrollers[id.scroller].containee
    var curSize mat.v2 = g_controls[containee.control].size
    //printf("CURSIZE %f, %f\n", curSize.x, curSize.y)

    var hlift lifter_id = g_scrollers[id.scroller].hlift
    var vlift lifter_id = g_scrollers[id.scroller].vlift

    var percent mat.v2 = mat.v2_zero
    var offset mat.v2 = mat.v2_(lifter_get_offset(hlift), lifter_get_offset(vlift))
    //printf("OFFSET %f, %f\n", offset.x, offset.y)

    var maxOffset mat.v2 = mat.v2_(lifter_get_max_offset(hlift), lifter_get_max_offset(vlift))
    //printf("MAXOFFSET %f, %f\n", maxOffset.x, maxOffset.y)

    if (curSize.y > 0) {
        var vliftIndex i32 = vlift.lifter
        var vliftMax f32 = lifter_get_max_amount(vlift)
        var vamount f32 = maxSize.y * vliftMax / curSize.y
        //printf("VAMOUNT %f\n", vamount)
        lifter_set_amount(vlift, vamount)
        if (curSize.y <= maxSize.y) {
            g_controls[vlift.base.control].visible = 0
        } else {
            g_controls[vlift.base.control].visible = 1
            if (maxOffset.y > 0.0) {
                percent.y = offset.y * 100.0 / maxOffset.y
            } else {
                percent.y = 0.0
            }
        }
    } else {
        g_controls[vlift.base.control].visible = 0
    }

    if (curSize.x > 0) {
        var hliftIndex i32 = hlift.lifter
        var hliftMax f32 = lifter_get_max_amount(hlift)
        var hamount f32 = maxSize.x * hliftMax / curSize.x
        lifter_set_amount(hlift, hamount)
        var maxOffsetX f32 = lifter_get_max_offset(hlift)
        if (curSize.x <= maxSize.x) {
            g_controls[hlift.base.control].visible = 0
        } else {
            g_controls[hlift.base.control].visible = 1
            percent.x = offset.x * 100.0 / maxOffset.x
        }
    } else {
        g_controls[hlift.base.control].visible = 0
    }

    //printf("percent %f, %f\n", percent.x, percent.y)

/*    var hvisible i32 = g_controls[hlift.base.control].visible
    var vvisible i32 = g_controls[vlift.base.control].visible

    if (hvisible > 0 && vvisible > 0) {
    } else if (hvisible > 0) {
    } else if (vvisible > 0) {
    }
*/

    var widthOffset f32 = maxSize.x - curSize.x
    var heightOffset f32 = maxSize.y - curSize.y
    //uti.assert_(mat.is_nan(curSize.y) == false, "scroller_resize curSize.y nan")
    //uti.assert_(mat.is_nan(maxSize.y) == false, "scroller_resize maxSize.y nan")
    //uti.assert_(mat.is_nan(heightOffset) == false, "scroller_resize heightOffset nan")
    //uti.assert_(mat.is_nan(percent.y) == false, "scroller_resize percent.y nan")
    
    /*if (id.base.control == 38) {
    printf("heightOffset %f\n", heightOffset)

    printf("position.x %f, position.y : heightOffset + percent.y * maxSize.y / 100.0 %f\n", 0.0 - percent.x * maxSize.x / 100.0, heightOffset + percent.y * maxSize.y / 100.0)
    }*/
    g_controls[containee.control].position = mat.v2_(0.0 + percent.x * widthOffset / 100.0, heightOffset - percent.y * heightOffset / 100.0)
    var after mat.v2 = g_controls[containee.control].position

    /*if (id.base.control == 38) {
    printf("AFTER %f, %f\n", after.x, after.y)
    }*/
    control_resize(id.base)
    //if (id.base.control == 38) {
    //printf("offset %f, %f\n", offsetX, offsetY)
    //control_print("scroller_resize : after ", containee, false)
    //}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func scroller_render(id scroller_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_scroller(id), "render_scroller : invalid id")
    control_render(id.base, clip, stack)
}

//-----------------------------------------------------------------------------
// BINDER
//-----------------------------------------------------------------------------
type binder_id struct {
    base control_id
    binder i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type binder_s struct {
    id binder_id
    header control_id
    container control_id
    selected i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_id_(base control_id, binder i32) (out binder_id) {
    uti.assert_(g_binderCount < len(g_binders), "binder_create : overflow") // ##1 use slice
    out.base = base
    out.binder = binder
    uti.assert_(is_valid_binder(out), "binder_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_binder() (out binder_id) {
    out.base = invalid_control()
    out.binder = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_binder(id binder_id) (out bool) {
    out = id.binder >= 0 && id.binder < g_binderCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_binders[8] binder_s
var g_binderCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_create(name str) (out binder_id) {
    out.binder = g_binderCount
    out.base = control_create_(name, GUI_BINDER, g_binderCount)

    var binder binder_s
    g_binders[g_binderCount].id = out

    var header control_id = control_create("binder.header")
    control_add_child(out.base, header)
    control_set_dock(header, DOCK_TOP)
    //control_set_skin(header, g_debugRedSkin)
    //control_set_size(header, mat.v2_(0.0, 0.08))
    control_set_autosize(header, AUTOSIZE_Y)
    g_binders[g_binderCount].header = header
    g_binders[g_binderCount].selected = -1
    var container control_id = control_create("binder.container")
    control_add_child(out.base, container)
    control_set_skin(container, g_blackSkin)
    control_set_padding(container, mat.v4_(3.0, 3.0, 3.0, 0.0))
    control_set_dock(container, DOCK_FILL)
    g_binders[g_binderCount].container = container

    g_binders[g_binderCount].selected = -1

    g_binderCount = g_binderCount + 1
    uti.assert_(is_valid_binder(out), "create_binder : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_add_page(id binder_id, name str, color mat.v4, size i32, control control_id) {
    uti.assert_(is_valid_binder(id), "binder_add_page : invalid id")
    var header control_id = g_binders[id.binder].header
    var pageCount i32 = g_controls[header.control].childCount

    var page label_id = label_create(sprintf("binder.page_%d", pageCount))
    control_add_child(header, page.base)
    control_set_dock(page.base, DOCK_LEFT)
    control_set_autosize(page.base, AUTOSIZE)
    control_set_skin(page.base, g_binderPageSkin)
    control_set_padding(page.base, mat.v4_(3.0, 0.0, 3.0, 0.0))
    control_set_focusable(page.base, 1)
    label_set_font(page, g_boldFont)
    label_set_text(page, name)
    label_set_size(page, size)
    label_set_color(page, color)
    label_set_align(page, ALIGN_CENTER)

    var container control_id = g_binders[id.binder].container
    control_add_child(container, control)
    control_set_dock(control, DOCK_FILL)
    control_set_visible(control, 0)

    g_binders[id.binder].selected = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_process_event(id binder_id, event *event_s) (out i32) {
    uti.assert_(is_valid_binder(id), "binder_process_event : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        out = control_process_event(id.base, event)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_resize(id binder_id) () {
    uti.assert_(is_valid_binder(id), "resize_binder : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_resize(id.base)

        var selected i32 = g_binders[id.binder].selected
        var header control_id = g_binders[id.binder].header
        var container control_id = g_binders[id.binder].container

        var pageCount i32 = g_controls[header.control].childCount

        var i i32 = 0
        for i = 0; i < pageCount; i = i + 1 {
            var child control_id = g_controls[header.control].children[i]
            var page control_id = g_controls[container.control].children[i]
            //var childFocused i32 = control_focused(child)
            if (selected == i) {
                control_set_visible(page, 1)
                control_set_selected(child, 1)
            } else {
                control_set_visible(page, 0)
                control_set_selected(child, 0)
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func binder_render(id binder_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_binder(id), "render_binder : invalid id")
    //control_print("binder_render : ", id.base, false)
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_render(id.base, clip, stack)
    }
}


//-----------------------------------------------------------------------------
// VECTOR
//-----------------------------------------------------------------------------
type vector_id struct {
    base control_id
    vector i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type vector_s struct {
    id vector_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func vector_id_(base control_id, vector i32) (out vector_id) {
    uti.assert_(g_vectorCount < len(g_vectors), "vector_create : overflow") // ##1 use slice
    out.base = base
    out.vector = vector
    uti.assert_(is_valid_vector(out), "vector_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_vector() (out vector_id) {
    out.base = invalid_control()
    out.vector = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_vector(id vector_id) (out bool) {
    out = id.vector >= 0 && id.vector < g_vectorCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_vectors[8] vector_s
var g_vectorCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func vector_create(name str) (out vector_id) {
    out.vector = g_vectorCount
    out.base = control_create_(name, GUI_VECTOR, g_vectorCount)

    var vector vector_s
    g_vectors[g_vectorCount].id = out

    g_vectorCount = g_vectorCount + 1
    uti.assert_(is_valid_vector(out), "create_vector : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func vector_process_event(id vector_id, event *event_s) (out i32) {
    uti.assert_(is_valid_vector(id), "vector_process_event : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        out = control_process_event(id.base, event)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func vector_resize(id vector_id) () {
    uti.assert_(is_valid_vector(id), "resize_vector : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_resize(id.base)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func vector_render(id vector_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_vector(id), "render_vector : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_render(id.base, clip, stack)
    }
}

//-----------------------------------------------------------------------------
// COMBO
//-----------------------------------------------------------------------------
type combo_id struct {
    base control_id
    combo i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type combo_s struct {
    id combo_id
    splitter splitter_id
    picture label_id
    label label_id
    expand label_id
    screen screen_id
    window window_id
    list list_id
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_id_(base control_id, combo i32) (out combo_id) {
    uti.assert_(g_comboCount < len(g_combos), "combo_create : overflow") // ##1 use slice
    out.base = base
    out.combo = combo
    uti.assert_(is_valid_combo(out), "combo_id_: invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_combo() (out combo_id) {
    out.base = invalid_control()
    out.combo = -1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_combo(id combo_id) (out bool) {
    out = id.combo >= 0 && id.combo < g_comboCount && is_valid_control(id.base)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_combos[8] combo_s
var g_comboCount i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_get_text(id combo_id) (out label_id) {
    uti.assert_(is_valid_combo(id), "combo_get_text : invalid id")
    out = g_combos[id.combo].label
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_get_pic(id combo_id) (out label_id) {
    uti.assert_(is_valid_combo(id), "combo_get_pic : invalid id")
    out = g_combos[id.combo].picture
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_get_list(id combo_id) (out list_id) {
    uti.assert_(is_valid_combo(id), "combo_get_list : invalid id")
    out = g_combos[id.combo].list
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_create(name str) (out combo_id) {
    out.combo = g_comboCount
    out.base = control_create_(name, GUI_COMBO, g_comboCount)

    control_set_padding(out.base, g_padding)
    g_combos[g_comboCount].id = out

    var screen screen_id = screen_create(sprintf("combo_screen_%s", name))
    g_combos[g_comboCount].screen = screen
    control_set_skin(screen.base, g_popupSkin)
    control_set_bounds(screen.base, gfx.gfx_viewportBounds)
    screen_set_duration(screen, -2.0D)
    screen_set_modal(screen, true)

    var window window_id = window_create(sprintf("combo_window_%s", name))
    control_add_child(screen.base, window.base)
    control_set_skin(window.base, g_windowSkin)
   control_set_size(window.base, mat.v2_(100.0, 100.0))
    control_set_autosize(window.base, AUTOSIZE_Y)
    //control_set_align(window.base, ALIGN_CENTER)
    var windowHeader control_id = g_windows[window.window].header
    control_set_visible(windowHeader, 0)
    var windowStrip control_id = g_windows[window.window].strip
    control_set_visible(windowStrip, 0)
    //window_set_caption(window, "combo")
   //         gui.window_add_button(window, "no", "No", "main", "on_exit_app_window_no_state")
     //       gui.window_add_button(window, "yes", "Yes", "main", "on_exit_app_window_yes_state")


    g_combos[g_comboCount].window = window

    var list list_id = list_create(sprintf("combo_list_%s", name))
    control_set_dock(list.base, DOCK_TOP)
    control_set_autosize(list.base, AUTOSIZE_Y)
    var listHeader control_id = g_lists[list.list].header
    g_controls[listHeader.control].visible = 0
    g_combos[g_comboCount].list = list
    window_set_containee(window, list.base)

    var expand label_id = label_create(sprintf("combo_expand_%s", name))
    g_combos[g_comboCount].expand = expand
    control_add_child(out.base, expand.base)
    control_set_autosize(expand.base, AUTOSIZE_X)
  //  control_set_size(expand.base, mat.v2_(32.0, 32.0))
    control_set_dock(expand.base, DOCK_RIGHT)
    label_set_align(expand, ALIGN_CENTER)
    label_set_font(expand, g_awesomeBoldFont)
    label_set_color(expand, g_blue)
    label_set_rune(expand, 214)
    label_set_size(expand, g_fontSizeSmall)

    var picture label_id = label_create(sprintf("combo_picture_%s", name))
    g_combos[g_comboCount].picture = picture
    control_set_autosize(picture.base, AUTOSIZE_X)
//    control_set_size(picture.base, mat.v2_(32.0, 32.0))
    control_set_dock(picture.base, DOCK_LEFT)
    label_set_align(picture, ALIGN_CENTER)
    label_set_font(picture, g_awesomeBoldFont)

    var label label_id = label_create(sprintf("combo_label_%s", name))
    g_combos[g_comboCount].label = label
    control_set_autosize(label.base, AUTOSIZE_X)
    control_set_dock(label.base, DOCK_LEFT)
    label_set_align(label, ALIGN_CENTER)

    var splitter splitter_id = splitter_create(sprintf("combo_splitter_%s", name))
    g_combos[g_comboCount].splitter = splitter
    control_add_child(out.base, splitter.base)
    control_set_dock(splitter.base, DOCK_RIGHT)
    control_set_autosize(splitter.base, AUTOSIZE_X)
    control_set_spacing(splitter.base, g_spacing_x)
    control_set_padding(splitter.base, mat.v4_(5.0, 0.0, 0.0, 0.0))
    splitter_set_direction(splitter, SPLIT_LEFT)
    splitter_set_controls(splitter, picture.base, label.base)

    g_comboCount = g_comboCount + 1
    uti.assert_(is_valid_combo(out), "create_combo : invalid id")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_process_event(id combo_id, event *event_s) (out i32) {
    out = EVENT_UNUSED
    uti.assert_(is_valid_combo(id), "combo_process_event : invalid id")
    var visible i32 = g_controls[id.base.control].visible

    if (visible > 0) {
        var index i32 = id.base.control
        var focused i32 = g_controls[index].focused
        var mods i32 = ((*event).keyboard).mods

        if (mods == MOD_NONE) { // ##1 refactor with label_process_event
            var call bool = false
            var button i32 = (*event).mouse.button
            if (button == BUTTON_LEFT) {
                var action i32 = (*event).mouse.action
                if (action == BUTTON_PRESS) {
                    //printf("BUTTON_PRESS\n")
                    var hover i32 = control_hovered(id.base)
                    if (hover > 0) {
                        call = true
                    }
                }
            } else if (focused > 0) {
                var key i32 = (*event).keyboard.key
                if (key == KEYCODE_ENTER || key == KEYCODE_SPACE) {
                    var action i32 = ((*event).keyboard).action
                    if (action == KEY_PRESS) {
                        call = true
                    }
                }
            }

            if (call == true) {
                var screen screen_id = g_combos[id.combo].screen
                show_screen(screen)
                out = EVENT_CONSUMED
            }
        }
    }

    if (out == EVENT_UNUSED) {
        out = control_process_event(id.base, event)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_resize(id combo_id) () {
    uti.assert_(is_valid_combo(id), "resize_combo : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        var list list_id = g_combos[id.combo].list
        var scroller scroller_id = g_lists[list.list].scroller
        var panel control_id = g_scrollers[scroller.scroller].panel
        var container control_id = g_scrollers[scroller.scroller].container

        control_set_dock(scroller.base, DOCK_TOP)
        control_set_autosize(scroller.base, AUTOSIZE_Y)

        control_set_dock(panel, DOCK_TOP)
        control_set_autosize(panel, AUTOSIZE_Y)

        control_set_dock(container, DOCK_TOP)
        control_set_autosize(container, AUTOSIZE_Y)

        control_resize(id.base)

        var screen screen_id = g_combos[id.combo].screen
        //printf("AAAAAAAA\n")
        if (modal_is_visible(screen) == true) {
        //printf("BBBBBB\n")
            var window window_id = g_combos[id.combo].window
            var comboPosition mat.v2 = g_controls[id.base.control].renderPosition
            var windowSize mat.v2 = g_controls[window.base.control].size
            //printf("###################################################### WINDOW SIZE %f\n", windowSize.y)
            comboPosition.y = comboPosition.y - windowSize.y
            control_set_position(window.base, comboPosition)
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func combo_render(id combo_id, clip mat.v4, stack i32) () {
    uti.assert_(is_valid_combo(id), "render_combo : invalid id")
    var visible i32 = g_controls[id.base.control].visible
    if (visible > 0) {
        control_render(id.base, clip, stack)
    }
}

//-----------------------------------------------------------------------------
// GUI
//-----------------------------------------------------------------------------
func init() () {
   // meshes
    var attributes [3]i32
    attributes = [3]i32{3, 4, 2} // can't use slice yet
    g_opaqueVertexColoredTriangles = gfx.create_mesh(gl.TRIANGLES, attributes, 10 * 2048 * 3)
    g_opaqueVertexColoredLines = gfx.create_mesh(gl.LINES, attributes, 20 * 2048 * 2)
    g_alphaVertexColoredTriangles = gfx.create_mesh(gl.TRIANGLES, attributes, 10 * 2048 * 3)
    g_alphaVertexColoredLines = gfx.create_mesh(gl.LINES, attributes, 20 * 2024 * 2)
    g_fullscreenQuad = gfx.create_mesh(gl.TRIANGLES, attributes, 6 * 3)

    printf("TOTO %d\n", g_fullscreenQuad.mesh)
    gfx.begin_mesh(g_fullscreenQuad)
    printf("TATA\n")
    gfx.append_quad(g_fullscreenQuad, gfx.gfx_viewportBounds, mat.v4_(0.0, 1.0, 1.0, 0.0), gfx.gfx_white, gfx.gfx_viewportBounds, 0.0)
    gfx.end_mesh(g_fullscreenQuad)

    // fonts
    //var skycoinRunes []ui32
//    skycoinRunes = append(skycoinRunes, 32)
  //  skycoinRunes = append(skycoinRunes, 127)
    //printf("RUNES :%d\n", len(skycoinRunes))
//    skycoinRunes = ui32[]{ 32U, 127U
  //  }
    g_regularFont = create_font("skycoinRegular", "fonts/Skycoin-Regular.ttf",32, 127, gltext.LeftToRight)
    font_add_size(g_regularFont, g_fontSizeSmall)
    font_add_size(g_regularFont, g_fontSizeText)
    font_add_size(g_regularFont, g_fontSizeButton)
    font_add_size(g_regularFont, g_fontSizeHeader)
    font_add_size(g_regularFont, g_fontSizeTitle)

    g_boldFont = create_font("skycoinBold", "fonts/Skycoin-Bold.ttf", 32, 127, gltext.LeftToRight)
    font_add_size(g_boldFont, g_fontSizeSmall)
    font_add_size(g_boldFont, g_fontSizeText)
    font_add_size(g_boldFont, g_fontSizeButton)
    font_add_size(g_boldFont, g_fontSizeHeader)
    font_add_size(g_boldFont, g_fontSizeTitle)

    var awesomeRunes []ui32
    awesomeRunes = append(awesomeRunes, 61441)
    awesomeRunes = append(awesomeRunes, 61444)
    g_awesomeBoldFont = create_font("awesomeBold", "fonts/fa-solid-900.ttf", 61441, 61841, gltext.LeftToRight)
    font_add_size(g_awesomeBoldFont, g_fontSizeSmall)
    font_add_size(g_awesomeBoldFont, g_fontSizeText)
    font_add_size(g_awesomeBoldFont, g_fontSizeHeader)

    // depth
    g_depthStencilBuffer = gfx.create_depth_buffer(gl.DEPTH_COMPONENT, app.app_width, app.app_height)

    // textures
    g_USTexture = gfx.create_texture("textures/flags/us.png", gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)
    g_JPTexture = gfx.create_texture("textures/flags/jp.png", gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)
    g_BRTexture = gfx.create_texture("textures/flags/br.png", gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)

    g_skycoinTexture = gfx.create_texture("textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png", gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)

    // layers
    g_blackLayer            = layer_create("black"            , g_black     , g_gray_3    , g_gray_3    , g_gray_3    , g_gray_3)
    g_bootLayer             = layer_create("boot"             , g_black     , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_popupLayer            = layer_create("popup"            , g_black_a10 , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_modalLayer            = layer_create("modal"            , g_black_a50 , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_debugBlueLayer        = layer_create("debugBlue"        , g_blue      , g_gold      , g_gold      , g_gold      , g_gold  )
    g_focusedLayer          = layer_create("focused"          , g_blue      , g_lightBlue , g_lightBlue , g_lightBlue , g_lightBlue)
    g_pageFocusedBack       = layer_create("pageFocusedBack"  , g_blue      , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_blueLayer             = layer_create("blue"             , g_blue      , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_selectedLayer         = layer_create("selected"         , g_darkBlue  , g_blue      , g_blue      , g_blue      , g_blue)
    g_pageSelectedBack      = layer_create("pageSelectedBack" , g_darkBlue  , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_debugGoldLayer        = layer_create("debugGold"        , g_gold      , g_blue      , g_blue      , g_blue      , g_blue  )
    g_goldLayer             = layer_create("gold"             , g_goldA50   , g_gold      , g_gold      , g_gold      , g_gold)
    g_textboxLayer          = layer_create("textbox"          , g_gray_1    , g_gray_3    , g_gray_3    , g_gray_3    , g_gray_3)
    g_stripLayer            = layer_create("strip"            , g_gray_2    , g_gray_2    , g_gray_2    , g_gray_2    , g_gray_2)
    g_headerLayer           = layer_create("header"           , g_gray_2    , g_gray_3    , g_gray_3    , g_gray_3    , g_gray_3)
    g_debugGreenLayer       = layer_create("debugGreen"       , g_green     , g_gold      , g_gold      , g_gold      , g_gold  )
    g_greenLayer            = layer_create("green"            , g_green     , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_debugRedLayer         = layer_create("debugRed"         , g_red       , g_gold      , g_gold      , g_gold      , g_gold  )
    g_redLayer              = layer_create("red"              , g_red       , gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero, gfx.gfx_zero)
    g_borderFocusedLayer    = layer_create("borderFocused"    , gfx.gfx_zero, g_blue      , g_blue      , g_blue      , g_blue)
    g_pageSelectedFront     = layer_create("pageSelectedFront", gfx.gfx_zero, g_gray_3    , g_black     , g_gray_3    , g_gray_3)
    g_zeroBorderLayer       = layer_create("zeroBorder"       , gfx.gfx_zero, g_gray_3    , g_gray_3    , g_gray_3    , g_gray_3)
    g_pageFocusedFront      = layer_create("pageFocusedFront" , gfx.gfx_zero, g_lightBlue , g_lightBlue , g_lightBlue , g_lightBlue)
    g_hoverLayer            = layer_create("blueA50"          , g_blue_a50  , g_lightBlue , g_lightBlue , g_lightBlue , g_lightBlue)

    // skins
g_blackSkin      =skin_create("black"       , g_blackLayer     ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_borderFocusedLayer,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_grayFocusedSkin=skin_create("grayFocused" , g_blackLayer     ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_windowSkin     =skin_create("window"      , g_blackLayer     ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_binderSkin     =skin_create("binder"      , g_blackLayer     ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_blueSkin       =skin_create("blue"        , g_blueLayer      ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_goldLayer         ,g_goldLayer       ,invalid_layer()   ,invalid_layer())
g_bootSkin       =skin_create("boot"        , g_bootLayer      ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_zeroSkin       =skin_create("blackFocused", g_bootLayer      ,invalid_layer() ,invalid_layer(),g_hoverLayer   ,invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_debugRedSkin   =skin_create("debugRed"    , g_debugRedLayer  ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_debugGreenSkin =skin_create("debugGreen"  , g_debugGreenLayer,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_debugBlueSkin  =skin_create("debugBlue"   , g_debugBlueLayer ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_debugGoldSkin  =skin_create("debugGold"   , g_debugGoldLayer ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_greenSkin      =skin_create("green"       , g_greenLayer     ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,g_goldLayer       ,invalid_layer()   ,invalid_layer())
g_headerSkin     =skin_create("header"      , g_headerLayer    ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_buttonSkin     =skin_create("button"      , g_headerLayer    ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_hoverSkin      =skin_create("blueA50"     , invalid_layer()  ,g_hoverLayer    ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_modalSkin      =skin_create("popup"       , g_modalLayer     ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_popupSkin      =skin_create("modal"       , g_popupLayer     ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_redSkin        =skin_create("red"         , g_redLayer       ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,g_goldLayer       ,invalid_layer()   ,invalid_layer())
g_stripSkin      =skin_create("strip"       , g_stripLayer     ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer()     ,invalid_layer()   ,invalid_layer()   ,invalid_layer())
g_textboxSkin    =skin_create("textbox"     , g_textboxLayer   ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
g_binderPageSkin =skin_create("binderPage"  , g_textboxLayer   ,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_pageFocusedBack   ,g_pageFocusedFront,g_pageSelectedBack,g_pageSelectedFront)
g_zeroBorderSkin =skin_create("blackFocused", g_zeroBorderLayer,invalid_layer() ,invalid_layer(),invalid_layer(),invalid_layer(),invalid_layer(),g_focusedLayer      ,invalid_layer()   ,g_selectedLayer   ,invalid_layer())
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func update(deltaTime f64)() { // ##1 rewrite
    process_events()
    //printf("UPDATE %d, %d\n", g_currentScreen.screen, g_nextScreen.screen)
    if (is_valid_screen(g_currentScreen)) {
        update_screen(g_currentScreen, deltaTime)
        if (screen_state_changed(g_currentScreen, STATE_OPENED, STATE_CLOSING)) {
            g_nextScreen = g_screens[g_currentScreen.screen].on_next // ##issue_58 issue array index with struct
            printf("NEXT_SCREEN %d\n", g_nextScreen.screen)
            printf("CURRENT %d, NEXT %d\n", g_currentScreen.screen, g_nextScreen.screen)
            g_transitionTime = 0.0D
            g_screens[g_currentScreen.screen].prevState= g_screens[g_currentScreen.screen].state
            printf("screen : %d, STATE_CLOSING\n", g_currentScreen.screen)
        } else if (screen_state_changed(g_currentScreen, STATE_CLOSING, STATE_CLOSED)) {
            g_screens[g_currentScreen.screen].time = 0.0D
            g_screens[g_currentScreen.screen].prevState = g_screens[g_currentScreen.screen].state
            g_currentScreen = g_nextScreen
            printf("screen : %d, STATE_CLOSED\n", g_currentScreen.screen)
        }
    }

    if (g_currentScreen.screen != g_nextScreen.screen) {
        if (is_valid_screen(g_nextScreen)) {
            update_screen(g_nextScreen, deltaTime)
        }

        if (g_transitionTime <= 0) {
            printf("TRANSITION STARTED %f\n", f64.f32(g_transitionTime + deltaTime))
            g_transitionTime = g_transitionTime + deltaTime
        } else if (g_transitionTime <= g_transitionDuration) {
            g_transitionTime = g_transitionTime + deltaTime
        } else {
            printf("TRANSITION ENDED\n")
            if (is_valid_screen(g_currentScreen)) {
                printf("CHANGE CLOSED\n")
                change_screen_state(g_currentScreen, STATE_CLOSED)
                printf("prev screen : %d, %d, %s\n", g_currentScreen.screen, g_screens[g_currentScreen.screen].state, "STATE_CLOSED")
            }

            g_currentScreen = g_nextScreen
            printf("CURRENT_SCREEN %d\n", g_nextScreen.screen)
            if (is_valid_screen(g_nextScreen)) {
                var nextScreen screen_id = g_screens[g_nextScreen.screen].on_next
                printf("CHANGE OPENED\n")
                change_screen_state(g_nextScreen, STATE_OPENED)
                printf("next screen : %d, %d, %s\n", g_nextScreen.screen, g_screens[g_nextScreen.screen].state, "STATE_OPENED")
                g_transitionTime = 0.0D
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var BUTTON_LEFT  i32 = 0
var BUTTON_RIGHT i32 = 1

var BUTTON_RELEASE i32 = 0
var BUTTON_PRESS   i32 = 1

var KEY_RELEASE i32 = 0
var KEY_PRESS   i32 = 1
var KEY_REPEAT  i32 = 2

var KEYCODE_SPACE     i32 =  32
var KEYCODE_ESCAPE    i32 = 256
var KEYCODE_ENTER     i32 = 257
var KEYCODE_TAB       i32 = 258
var KEYCODE_RIGHT     i32 = 262
var KEYCODE_LEFT      i32 = 263
var KEYCODE_DOWN      i32 = 264
var KEYCODE_UP        i32 = 265
var KEYCODE_LEFT_CTRL i32 = 341
var KEYCODE_MENU      i32 = 343

var MOD_NONE  i32 = 0
var MOD_SHIFT i32 = 1
var MOD_CTRL  i32 = 2
var MOD_ALT   i32 = 4
var MOD_MENU  i32 = 8

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*func skip_screens()() {
    var next bool = true
    var skipId screen_id = g_currentScreen
    for (next == true) {
        var nextId screen_id = g_screens[skipId].on_next
        if (is_valid_screen(nextId)) {
            if (is_valid_screen(g_screens[nextId.screen].on_exit) ||
                is_valid_screen(g_screens[nextId.screen].on_enter) ||
                is_valid_screen(g_screens[nextId.screen].on_menu)) {
                next = false
            }
            skipId = nextId
        } else {
            next = false
        }
    }
    g_nextScreen = skipId
}*/

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var EVENT_ERROR    i32 = 0
var EVENT_UNUSED   i32 = 1
var EVENT_CONSUMED i32 = 2

type keyboard_event_s struct {
    key i32
    scancode i32
    action i32
    mods i32
}

type mouse_event_s struct {
    position mat.v2
    button i32
    action i32
    mods i32
}

type event_s struct {
    keyboard keyboard_event_s
    mouse mouse_event_s
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_keyboard_event() (out keyboard_event_s) {
    out.key = -1
    out.scancode = -1
    out.action = 0
    out.mods = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_mouse_event() (out mouse_event_s) {
    out.position = mat.v2_(-1.0, -1.0)
    out.button = -1
    out.action = 0
    out.mods = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func invalid_event() (out event_s) {
    out.keyboard = invalid_keyboard_event()
    out.mouse = invalid_mouse_event()
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func control_process_event(id control_id, event *event_s) (out i32) {
    uti.assert_(is_valid_control(id), "control_process_event : invalid id")
    out = EVENT_UNUSED

    var visible i32 = g_controls[id.control].visible
    if (visible > 0) {
        //control_print("control_process_event : ", id, false)

        var index i32 = id.control
        var count i32 = g_controls[index].childCount
        for i := 0; i < count; i = i + 1 {
            var child control_id = g_controls[index].children[i]
            uti.assert_(is_valid_control(child), "control_process_event : invalid child control")
            var childVisible i32 = g_controls[child.control].visible
            if (childVisible > 0) {
                var guiType i32 = g_controls[child.control].gui_type
                var guiIndex i32 = g_controls[child.control].gui_index

                if (guiType == GUI_INVALID) {
                   uti.assert_(false, "invalid gui type (GUI_INVALID)")
                } else if (guiType == GUI_CONTROL) {
                    uti.assert_(guiIndex == child.control, "unexpected error")
                    out = control_process_event(control_id_(guiIndex), event)
                } else if (guiType == GUI_SCREEN) {
                    out = screen_process_event(screen_id_(child, guiIndex), event)
                } else if (guiType == GUI_PICTURE) {
                    out = picture_process_event(picture_id_(child, guiIndex), event)
                } else if (guiType == GUI_LABEL) {
                    out = label_process_event(label_id_(child, guiIndex), event)
                } else if (guiType == GUI_PARTITION) {
                    out = partition_process_event(partition_id_(child, guiIndex), event)
                } else if (guiType == GUI_KEYBOARD) {
                    out = keyboard_process_event(keyboard_id_(child, guiIndex), event)
                } else if (guiType == GUI_WINDOW) {
                    out = window_process_event(window_id_(child, guiIndex), event)
                } else if (guiType == GUI_GRAPH) {
                    out = graph_process_event(graph_id_(child, guiIndex), event)
                } else if (guiType == GUI_SPLITTER) {
                    out = splitter_process_event(splitter_id_(child, guiIndex), event)
                } else if (guiType == GUI_LIST) {
                    out = list_process_event(list_id_(child, guiIndex), event)
                } else if (guiType == GUI_SCROLLER) {
                    out = scroller_process_event(scroller_id_(child, guiIndex), event)
                } else if (guiType == GUI_LIFTER) {
                    out = lifter_process_event(lifter_id_(child, guiIndex), event)
                } else if (guiType == GUI_BINDER) {
                    out = binder_process_event(binder_id_(child, guiIndex), event)
                } else if (guiType == GUI_VECTOR) {
                    out = vector_process_event(vector_id_(child, guiIndex), event)
                } else if (guiType == GUI_COMBO) {
                    out = combo_process_event(combo_id_(child, guiIndex), event)
                } else {
                    printf("GUI TYPE %d\n", guiType)
                    uti.assert_(false, "control_process_event : unknown gui type")
                }
            }

            if (out == EVENT_CONSUMED) {
                i = count // ##pending issue brue
            } else if (out == EVENT_ERROR) {
                uti.assert_(false, "EVENT_ERROR")
            } else if (out != EVENT_UNUSED) {
                uti.assert_(false, "invalid EVENT code")
            }
        }
        //control_print("control_process_event : ", id, false)
        //printf("control_process_event : OUT %d\n", out)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func hide_modal(id screen_id) {
    printf("HIDE_MODAL %d\n", g_modalCount)
    uti.assert_(is_valid_screen(id), "hide_modal : invalid screen")
    uti.assert_(g_modalCount > 0, "hide_modal : invalid count")
    if (g_modalCount > 0) {
        var modalIndex i32 = g_modalCount - 1
        printf("MODAL_INDEX %d, COUNT %d\n", modalIndex, g_modalCount)
        var modalScreen screen_id = g_modals[modalIndex]
        uti.assert_(modalScreen.screen == id.screen, "hide_modal : invalid screen")
        if (modalScreen.screen == id.screen) {
            printf("hide_screen\n")
            hide_screen(modalScreen)
            g_modalCount = modalIndex
            g_hotScreen = invalid_screen()
        }
    }
    printf("AFTER HIDE_MODEL\n")
}

var g_hotScreen screen_id

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_events [128]event_s // ##0 use slice
var g_eventCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_cursor(window str, x f64, y f64) {
 //    printf("----------------------------------------------------------TOTO\n")
   //  printf("FUCK\n")
    var b bool // ##0 padding, something is messed up with callbacks
    var xx f32 = f64.f32(x)
    var yy f32 = gfx.gfx_height - f64.f32(y)
    uti.assert_(g_eventCount < 128, "process_cursor : event overflow") // ##0 remove when using event
    printf("cursor : %f, %f\n", xx, yy)
    g_cursorPos.x = xx
    g_cursorPos.y = yy

    g_events[g_eventCount] = invalid_event()
    g_events[g_eventCount].mouse.position = g_cursorPos
    g_eventCount = g_eventCount + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_button(window str, key i32, action i32, mods i32) {
    var b bool // ##0 padding, something is messed up with callbacks
    uti.assert_(g_eventCount < 128, "process_button : event overflow") // ##0 remove when using slice
    printf("button : %d, %d, %d\n", key, action, mods)

    g_events[g_eventCount] = invalid_event()
    g_events[g_eventCount].mouse.button = key
    g_events[g_eventCount].mouse.action = action
    g_events[g_eventCount].mouse.mods = mods
    g_events[g_eventCount].mouse.position = g_cursorPos
    g_eventCount = g_eventCount + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_keyboard(window str, key i32, scancode i32, action i32, mods i32) () {
    var b bool // ##0 padding, something is messed up with callbacks
    uti.assert_(g_eventCount < 128, "process_keyboard : event overflow") // ##0 remove when using slice
    printf("key pressed : %d, scancode %d, action %d, mods %d\n", key, scancode, action, mods)

    g_events[g_eventCount] = invalid_event()
    g_events[g_eventCount].keyboard.key = key
    g_events[g_eventCount].keyboard.scancode = scancode
    g_events[g_eventCount].keyboard.action = action
    g_events[g_eventCount].keyboard.mods = mods
    g_eventCount = g_eventCount + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_events() () {
//    printf("EVENT COUNT %d\n", g_eventCount)
    var i i32 = 0
    for i = 0; i < g_eventCount; i = i + 1 {
        process_event(&g_events[i])
    }
    g_eventCount = 0
//    printf("CLEAR EVENTS\n")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func process_event(event *event_s) () {
    var action i32 = (*event).keyboard.action
    var key i32 = (*event).keyboard.key
    var mods i32 = (*event).keyboard.mods

    var currentScreen screen_id = invalid_screen()
    if (g_modalCount > 0) {
        var modalIndex i32 = g_modalCount - 1
        var modalScreen screen_id = g_modals[modalIndex]
        g_hotScreen = modalScreen
        currentScreen = modalScreen
        if (control_process_event(modalScreen.base, event) == EVENT_UNUSED) {
            if (key == KEYCODE_ESCAPE && action == KEY_PRESS) {
                hide_modal(modalScreen)
                g_hotScreen = g_currentScreen
            } else {
                currentScreen = modalScreen
                g_hotScreen = modalScreen
            }
        }
    } else if (is_valid_screen(g_currentScreen)) {
    g_hotScreen = g_currentScreen
    //printf("NO MODAL\n")
    if (control_process_event(g_currentScreen.base, event) == EVENT_UNUSED) {
    //printf("process_keyboard : EVENT_UNUSED 0\n")
            var screen i32 = g_currentScreen.screen
            var state i32 = g_screens[screen].state
            //if (g_screens[g_currentScreen.screen].state == STATE_OPENED) { // ##pending
            //} else if (g_screens[g_currentScreen.screen].state == STATE_SHOWING) { // ##pending
            if (state == STATE_OPENED || state == STATE_SHOWING) {
                if (key == KEYCODE_ESCAPE && action == KEY_PRESS) {
                    g_screens[screen].paused = true
                    var onExit screen_id = g_screens[screen].on_exit
                    if (is_valid_screen(onExit) == true) {
                        show_screen(onExit)
                    } else {
                        printf("INVALID ON EXIT SCREEN %d, %d\n", onExit.screen, onExit.base)
                    }
                } else if (key == KEYCODE_ENTER && action == KEY_PRESS) {
                    g_screens[screen].paused = true
                    var onEnter screen_id = g_screens[screen].on_enter
                    if (is_valid_screen(onEnter) == true) {
                        show_screen(onEnter)
                    }
                } else if (key == KEYCODE_MENU && action == KEY_PRESS) {
                    g_screens[screen].paused = true
                    var onMenu screen_id = g_screens[screen].on_menu
                    if (is_valid_screen(onMenu) == true) {
                        show_screen(onMenu)
                    }
                } else {
    //printf("process_keyboard : EVENT_UNUSED 1\n")
                    currentScreen = g_currentScreen
                    g_hotScreen = g_currentScreen
                }
            }
        }
    } else {
        g_hotScreen = invalid_screen()
        //printf("----------------------------------------------->\n")
    }

    if (is_valid_screen(currentScreen)) {
    //printf("process_keyboard : EVENT_UNUSED 2\n")
        if (action == KEY_PRESS) {
            if (mods == MOD_NONE || mods == MOD_CTRL) {
                if (key == KEYCODE_LEFT ||
                    key == KEYCODE_UP) {
                    set_previous_focus(g_hotScreen)
                } else if (key == KEYCODE_RIGHT ||
                           key == KEYCODE_DOWN ||
                           key == KEYCODE_TAB) {
                    set_next_focus(g_hotScreen)
                }
            } else if (mods == MOD_SHIFT) {
                if (key == KEYCODE_TAB) {
                    set_previous_focus(g_hotScreen)
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func hide_screen(id screen_id) () {
    uti.assert_(is_valid_screen(id), "hide_screen : invalid screen")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func modal_is_visible(id screen_id) (out bool) {
    out = false
    uti.assert_(is_valid_screen(id), "modal_is_visible : invalid id")
    var modal bool = g_screens[id.screen].modal
    if (modal == true) {
        if (g_modalCount > 0) {
            var lastIndex i32 = g_modalCount - 1
            var left i32 = g_modals[lastIndex].screen
            var right i32 = id.screen
            //printf("left %d, right %d\n", left, right)
            if (left == right) {
                out = true
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func show_screen(id screen_id) () {
    uti.assert_(is_valid_screen(id), "show_screen : invalid id")
    g_hotScreen = id
    control_print("show_screen : ", id.base, false)
    rebuild_focus(id)

    var modal bool = g_screens[id.screen].modal
    if (modal == true) {
        g_modals[g_modalCount] = id
        g_modalCount = g_modalCount + 1
    } else {
        g_nextScreen = id
        g_transitionTime = 0.0D
    }

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func resize() () {
    clear_batches()
    if (is_valid_screen(g_currentScreen)) {
        reset_scope()
        //printf("-------------------------------------------------------------------------------->\n")
        screen_resize(g_currentScreen)
        control_redock(g_currentScreen.base, mat.v4_zero)
        //screen_resize(g_currentScreen)
        //control_redock(g_currentScreen.base, mat.v4_zero)
    }
    if (is_valid_screen(g_nextScreen) && g_currentScreen.screen != g_nextScreen.screen) {
        reset_scope()
        screen_resize(g_nextScreen)
        control_redock(g_nextScreen.base, mat.v4_zero)
        //screen_resize(g_nextScreen)
        //control_redock(g_nextScreen.base, mat.v4_zero)
    }

    var i i32 = 0
    for i = 0; i < g_modalCount; i = i + 1 {
        //control_print("before resize : ", g_modals[i].base, false)
        //printf("_-------------------------------------------------------------------------------->>>>\n")
        reset_scope()
        screen_resize(g_modals[i])
        control_redock(g_modals[i].base, mat.v4_zero)
        //screen_resize(g_modals[i])
        //control_redock(g_modals[i].base, mat.v4_zero)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
var g_profileRenderCurrentScreen fps.profile_id
var g_profileRenderNextScreen fps.profile_id
var g_profileRenderScreenEffect fps.profile_id
var g_profileRenderModals fps.profile_id
var g_profileRenderDefaultFramebuffer fps.profile_id
var g_profileRenderScreenControl fps.profile_id
var g_profileRenderOpaqueVertexColoredTriangles fps.profile_id
var g_profileRenderOpaqueTexturedTriangles fps.profile_id
var g_profileRenderOpaqueVertexColoredLines fps.profile_id
var g_profileRenderAlphaVertexColoredTriangles fps.profile_id
var g_profileRenderAlphaTexturedTriangles fps.profile_id
var g_profileControlRender fps.profile_id
var g_profileControlRenderChild fps.profile_id
var g_profileRenderControlFull fps.profile_id

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render() () {

    var clip mat.v4 = gfx.gfx_viewportBounds
    var depthTest bool = true
    var depthFunc i32 = gl.GEQUAL
    var depthClear f64 = -1.0D
    var depthWrite bool = true
    var stencilClear i32 = 256

    var clearColor mat.v4 = mat.v4_(0.0, 0.0, 0.0, 0.0)

    fps.begin_profile(g_profileRenderCurrentScreen)
    var target_0 gfx.target_s = gfx.invalid_target()
    if (is_valid_screen(g_currentScreen)) {
        target_0 = gfx.lock_target(app.app_width, app.app_height)
        gfx.bind_framebuffer(target_0.framebuffer)
        gfx.bind_depthbuffer(g_depthStencilBuffer)
        //gfx.bind_stencilbuffer(g_depthStencilBuffer)
        gfx.depth_state(depthTest, depthFunc, depthWrite)
        gfx.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT/* | gl.STENCIL_BUFFER_BIT*/, g_black, depthClear, stencilClear)
        gfx.color_write(true, true, true, true)
        screen_render(g_currentScreen, clip, 0)
        gfx.bind_depthbuffer(0)
        gfx.bind_stencilbuffer(0)
    }
    fps.end_profile(g_profileRenderCurrentScreen)

    var target_1 gfx.target_s = gfx.invalid_target()
    fps.begin_profile(g_profileRenderNextScreen)
    if (is_valid_screen(g_nextScreen) && g_nextScreen.screen != g_currentScreen.screen) {
        target_1 = gfx.lock_target(app.app_width, app.app_height)
        gfx.bind_framebuffer(target_1.framebuffer)
        gfx.bind_depthbuffer(g_depthStencilBuffer)
        //gfx.bind_stencilbuffer(g_depthStencilBuffer)
        gfx.depth_state(depthTest, depthFunc, depthWrite)
        gfx.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, g_black, depthClear, stencilClear)
        gfx.color_write(true, true, true, true)
        screen_render(g_nextScreen, clip, 0)
        gfx.bind_depthbuffer(0)
        gfx.bind_stencilbuffer(0)
    }
    fps.end_profile(g_profileRenderNextScreen)

    fps.begin_profile(g_profileRenderScreenEffect)
    var target_2 gfx.target_s = gfx.invalid_target()
    //if (gfx.is_valid_target(target_0) && gfx.is_valid_target(target_1)) {
        target_2 = gfx.lock_target(app.app_width, app.app_height)
        gfx.bind_framebuffer(target_2.framebuffer)
        gfx.clear(gl.COLOR_BUFFER_BIT, gfx.gfx_zero, 0.0D, 0)
        gfx.color_write(true, true, true, true)
        gfx.disable_depth()
        gfx.disable_stencil()
        gfx.disable_blending()
        gfx.effect_use(gfx.g_fxTrans_0)
        gfx.effect_assign_texture(gfx.g_fxTrans_0, 0, target_0.texture.name)
        gfx.effect_assign_texture(gfx.g_fxTrans_0, 1, target_1.texture.name)
        gfx.effect_assign_float(gfx.g_fxTrans_0, 0, f64.f32(g_transitionTime / g_transitionDuration))
        gfx.render_mesh(g_fullscreenQuad)
        if (gfx.is_valid_target(target_0)) {
            gfx.unlock_target(target_0)
        }
        if (gfx.is_valid_target(target_1)) {
            gfx.unlock_target(target_1)
        }
    /*} else if (gfx.is_valid_target(target_0)) {
        target_2 = target_0
    } else if (gfx.is_valid_target(target_1)) {
        target_2 = target_1
    } else {
        uti.assert_(false, "render : invalid target")
    }*/

    fps.end_profile(g_profileRenderScreenEffect)

    fps.begin_profile(g_profileRenderModals)
    var i i32 = 0
    for i = 0; i < g_modalCount; i = i + 1 {
        var target target_s = gfx.lock_target(app.app_width, app.app_height)
        gfx.bind_framebuffer(target.framebuffer)
        gfx.bind_depthbuffer(g_depthStencilBuffer)
        //gfx.bind_stencilbuffer(g_depthStencilBuffer)
        gfx.depth_state(depthTest, depthFunc, depthWrite)
        //gfx.stencil_state(true, gl.EQUAL, 0, 256, gl.KEEP, gl.KEEP, gl.KEEP, 0)
        gfx.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gfx.gfx_zero, depthClear, stencilClear)
        gfx.color_write(true, true, true, true)
        screen_render(g_modals[i], clip, 0)
        gfx.bind_depthbuffer(0)
        gfx.bind_stencilbuffer(0)

        var target_3 target_s = gfx.lock_target(app.app_width, app.app_height)
        gfx.bind_framebuffer(target_3.framebuffer)
        gfx.clear(gl.COLOR_BUFFER_BIT, gfx.gfx_zero, 0.0D, 0)
        gfx.color_write(true, true, true, true)
        gfx.disable_depth()
        gfx.disable_stencil()
        gfx.disable_blending()
        gfx.effect_use(gfx.g_fxTrans_1)
        gfx.effect_assign_texture(gfx.g_fxTrans_1, 0, target_2.texture.name)
        gfx.effect_assign_texture(gfx.g_fxTrans_1, 1, target.texture.name)
        gfx.effect_assign_float(gfx.g_fxTrans_1, 0, 1.0)
        gfx.render_mesh(g_fullscreenQuad)
        gfx.unlock_target(target)
        gfx.unlock_target(target_2)
        target_2 = target_3
    }
    fps.end_profile(g_profileRenderModals)

    fps.begin_profile(g_profileRenderDefaultFramebuffer)
    // ##todo fast path if no modals => render in default framebuffer 0
    gfx.bind_framebuffer(0)
    gfx.clear(gl.COLOR_BUFFER_BIT, gfx.gfx_zero, 0.0D, 0)
    gfx.color_write(true, true, true, true)
    gfx.disable_depth()
    gfx.disable_stencil()
    gfx.disable_blending()
    gfx.effect_use(gfx.g_fxTexture)
    gfx.effect_assign_texture(gfx.g_fxTexture, 0, target_2.texture.name)
    gfx.render_mesh(g_fullscreenQuad)
    gfx.unlock_target(target_2)
    fps.end_profile(g_profileRenderDefaultFramebuffer)

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

