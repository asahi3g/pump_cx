//-----------------------------------------------------------------------------
// pump-cx
//-----------------------------------------------------------------------------
package main
import "glfw"
import "gl"
import "time"
//-----------------------------------------------------------------------------
// cx bugs
//-----------------------------------------------------------------------------
// implicit cast ui32 -> i32
// printf %d ui32
// pointers
// assert doesn't stop program execution
// multiline array init
// inline array init
// inline string init
// if b {} else {} unexpected ELSE
// for true { return false }
// if glerror == 0 { break } unexpected RBRACE

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//i32.rand(0,2)

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func assert_(value bool, message str) {
	if value == false {
		printf("%s\n", message)
		var crash i32 = 0 / 0
	}
}

//-----------------------------------------------------------------------------
// utils
//-----------------------------------------------------------------------------
type fps_s struct {
    currentTime f64
    previousTime f64
    deltaTime f64
    fpsTime f64
    frameTime f64
    fps f64
	init bool
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func fps_init(targetFps f64)(out fps_s) {
    out.currentTime = glfw.GetTime()
    out.previousTime = out.currentTime
    out.deltaTime = 0.0D
    out.fpsTime = 0.0D
    out.frameTime = 0.0D
    if targetFps > 0.0D {
			printf("TARGET_FPS\n")
		out.frameTime = 1.0D / targetFps
    }
    out.fps = 0.0D
	out.init = true
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func fps_begin_update(in fps_s) (out fps_s) {

    out = in
    out.currentTime = glfw.GetTime()
    out.deltaTime = out.currentTime - out.previousTime
	if (out.init == true) {
		out.init = false
		out.deltaTime = out.frameTime
	}

    if out.currentTime - out.fpsTime > 1.0D {
        out.fpsTime = out.currentTime
        printf("fps : %d\n", f64.i32(out.fps))
        out.fps = 0.0D
    } else {
        out.fps = out.fps + 1.0D;
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func fps_end_update(in fps_s) (out fps_s) {
    out = in

    if out.frameTime > 0.0 {
        var updateTime f64 = glfw.GetTime()
        var    deltaUpdateTime f64 = updateTime - out.currentTime;
        if (deltaUpdateTime < out.frameTime) {
            time.Sleep(f64.i32(1000.0D * (out.frameTime - deltaUpdateTime)))
		}
    }

    out.previousTime = out.currentTime
}

//-----------------------------------------------------------------------------
// glfw
//-----------------------------------------------------------------------------
func keyPressed(window str, key i32, scancode i32, action i32, mods i32) () {
    printf("key pressed : %d, scancode %d, action %d, mods %d\n", key, scancode, action, mods)
    //if key == 32 && action == 1 || key == 265 && action == 1 {
    //}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func init_glfw(window str, name str, width i32, height i32, targetFps f64)() {

	g_ratio = i32.f64(width) / i32.f64(height)

    printf("starting %s...\n", name)

    glfw.Init()
    glfw.WindowHint(glfw.Resizable, glfw.False)
    glfw.WindowHint(glfw.ContextVersionMajor, 2)
    glfw.WindowHint(glfw.ContextVersionMinor, 1)
    glfw.CreateWindow(window, 800, 600, name)
	glfw.SetWindowPos(window, 100, 100) //1500, 100)
    glfw.MakeContextCurrent(window)
    var swapInterval i32 = 0
    if targetFps > 0.0D {
        swapInterval = 1 // should be based on targetFps
    }
    glfw.SwapInterval(swapInterval)
    glfw.SetKeyCallback(window, "keyPressed")
    // xPos, yPos := glfw.GetCursorPos("window")
    // glfw.SetMouseButtonCallback("window", "mouseButton") --> Doesn't work yet
}

//-----------------------------------------------------------------------------
// gl
//-----------------------------------------------------------------------------
var g_vaos []i32
var g_vaoCount i32 = 0

var g_vbos []i32
var g_vboCount i32 = 0

//var g_shaders[]i32
//var g_shaderCount i32 = 0

var g_programs []i32
var g_programCount i32 = 0

var g_sizeofFloat i32 = 4

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func glerror() (error bool) {
    error = false
    var glerr i32 = -1
    for glerr != 0  {
        glerr = gl.GetError()
        if  glerr != 0 {
            error = true
            if glerr == gl.INVALID_ENUM {
                printf("GL_INVALID_ENUM\n")
            } else if glerr == gl.INVALID_VALUE {
                printf("GL_INVALID_VALUE\n")
            } else if glerr == gl.INVALID_OPERATION {
                printf("GL_INVALID_OPERATION\n")
            } else if glerr == gl.STACK_OVERFLOW {
                printf("GL_STACK_OVERFLOW\n")
            } else if glerr == gl.STACK_UNDERFLOW {
                printf("GL_STACK_UNDERFLOW\n")
            } else if glerr == gl.OUT_OF_MEMORY {
                printf("GL_OUT_OF_MEMORY\n")
            } else if glerr != 0 {
                assert_(false, "invalid glError\n")
            }
        }
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func no_glerror() (noerror bool) {
    var error bool = glerror()
    noerror = error == false // panic if noerror = (glerror() == false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func glstatus() (error bool) {
	error = false
	var glstat i32
	glstat = gl.CheckFramebufferStatus(gl.FRAMEBUFFER)
	assert_(no_glerror(), "CheckFramebufferStatus")
	if (glstat != gl.FRAMEBUFFER_COMPLETE) {
		error = true;
		if (glstat == gl.FRAMEBUFFER_UNDEFINED) {
			printf("GL_FRAMEBUFFER_UNDEFINED\n")
		} else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT) {
			printf("GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n")
		} else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) {
			printf("GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\n")
		} else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER) {
			printf("GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER\n")
		} else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_READ_BUFFER) {
			printf("GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER\n")
		} else if (glstat == gl.FRAMEBUFFER_UNSUPPORTED) {
			printf("GL_FRAMEBUFFER_UNSUPPORTED\n")
		} else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
			printf("GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE\n")
		} else if (glstat == gl.FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS) {
			printf("GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS\n")
		} else {
			assert_(false, "invalid glFramebufferStatus")
		}
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func no_glstatus() (nostatus bool) {
	var status bool = glstatus()
	nostatus = status == false // panic if nostatus = (glstatus() == false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func gl_init(width i32, height i32, color [4]f32)() {

    gl.Strs("i_v3Position", "i_v3Position")
    gl.Strs("i_v4Albedo", "i_v4Albedo")
    gl.Strs("i_v2Texcoord", "i_v2Texcoord")
    gl.Strs("u_t2Albedo", "u_t2Albedo")
	gl.Strs("u_t2Src", "u_t2Src")
	gl.Strs("u_t2Dst", "u_t2Dst")
	gl.Strs("u_fTime", "u_fTime")

    //-----------------------------------------------------------------------------
    // vsPassThrough
    //-----------------------------------------------------------------------------
    gl.Strs(
    `
    #version 130
    in vec3 i_v3Position;
    in vec4 i_v4Albedo;
    in vec2 i_v2Texcoord;
    out vec4 v_v4Albedo;
    out vec2 v_v2Texcoord;
    void main()
    {
        gl_Position = vec4(i_v3Position.rg, 0.0, 1);
        v_v4Albedo = i_v4Albedo;
        v_v2Texcoord = i_v2Texcoord;
    }`, "vsPassThrough")

    //-----------------------------------------------------------------------------
    // psVertexColor
    //-----------------------------------------------------------------------------
    gl.Strs(
    `
    #version 130
    in vec4 v_v4Albedo;
    out vec4 o_v4Color;
    void main()
    {
        o_v4Color = v_v4Albedo;
    }
    `, "psVertexColor")

    //-----------------------------------------------------------------------------
    // psVertexTexture
    //-----------------------------------------------------------------------------
    gl.Strs(
    `
    #version 130
    uniform sampler2D u_t2Albedo;
    in vec4 v_v4Albedo;
	in vec2 v_v2Texcoord;
	out vec4 o_v4Color;
    void main()
    {
        o_v4Color = v_v4Albedo * texture2D(u_t2Albedo, v_v2Texcoord);
    }
    `, "psTexture")

    //-----------------------------------------------------------------------------
    // psTransition_0
	//-----------------------------------------------------------------------------
    gl.Strs(
	`
	#version 130
	uniform sampler2D u_t2Src;
	uniform sampler2D u_t2Dst;
	uniform float u_fTime;
	in vec2 v_v2Texcoord;
	out vec4 o_v4Color;
	void main()
	{
		o_v4Color = mix(texture2D(u_t2Src, v_v2Texcoord), texture2D(u_t2Dst, v_v2Texcoord), u_fTime);
	}
	`, "psTransition_0")

	//-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    gl.Init()
    assert_(no_glerror(), "gl.Init")

    gl.Disable(gl.BLEND)
	assert_(no_glerror(), "gl.Disable(gl.BLEND)")

    gl.Disable(gl.CULL_FACE)
	assert_(no_glerror(), "gl.Disable(gl.CULL_FACE)")

    gl.Disable(gl.DEPTH_TEST)
	assert_(no_glerror(), "gl.Disable(gl.DEPTH_TEST)")

    printf("clear color : %f, %f, %f, %f\n", color[0], color[1], color[2], color[3])
    gl.ClearColor(color[0], color[1], color[2], color[3])
    assert_(no_glerror(), "gl.ClearColor")

    gl.Viewport(0, 0, width, height)
    assert_(no_glerror(), "gl.Viewport")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func free_gl()() {

    gl.Free("vsPassThrough")
    gl.Free("psVertexColor")
    gl.Free("psTexture")
	gl.Free("psTransition_0")
	gl.Free("i_v3Position")
    gl.Free("i_v4Albedo")
    gl.Free("i_v2Texcoord")
    gl.Free("u_t2Albedo")
	gl.Free("u_t2Src")
	gl.Free("u_t2Dst")
	gl.Free("u_fTime")

	use_program(0)

    var i i32
    for i = 0; i < g_programCount; i = i + 1 {
        printf("gl.DeleteProgram(%d)\n", g_programs[i])
        gl.DeleteProgram(g_programs[i]) // ##0 crash
		assert_(no_glerror(), "gl.DeleteProgram")
    }

    for i = 0; i < g_vboCount; i = i + 1 {
        printf("gl.DeleteBuffers(%d)\n", g_vbos[i])
        gl.DeleteBuffers(1, g_vbos[i])
		assert_(no_glerror(), "glDeleteBuffers")
    }

    for i = 0; i < g_vaoCount; i = i + 1 {
        printf("gl.DeleteVertexArrays(%d)\n", g_vaos[i])
        gl.DeleteVertexArrays(1, g_vaos[i])
		assert_(no_glerror(), "g_DeleteVertexArrays")
    }


	gl.DeleteFramebuffers(1, g_target_0.framebuffer)
	assert_(no_glerror(), "g.DeleteFramebuffers")

	gl.DeleteFramebuffers(1, g_target_1.framebuffer)
	assert_(no_glerror(), "g_DeleteFramebuffers")

	gl.DeleteTextures(1, g_target_0.texture)
	assert_(no_glerror(), "g.DeleteTextures")

	gl.DeleteTextures(1, g_target_1.texture)
	assert_(no_glerror(), "g.DeleteTextures")

	gl.DeleteTextures(1, g_skycoinTexture)
	assert_(no_glerror(), "gl.DeleteTextures")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_texture(path str, mag i32, min i32, s i32, t i32, r i32, w i32, h i32) (texture i32) {
	if (path == "") {
		texture = gl.GenTextures(1, texture)
		assert_(no_glerror(), "gl.GenTextures")
	} else {
		texture = gl.NewTexture(path)
		assert_(no_glerror(), "gl.NewTexture")
	}

	gl.BindTexture(gl.TEXTURE_2D, texture)
	assert_(no_glerror(), "gl.BindTexture")

	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
	assert_(no_glerror(), "gl.TexParameteri")

	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
	assert_(no_glerror(), "gl.TexParameteri")

	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
	assert_(no_glerror(), "gl.TexParameteri")

	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
	assert_(no_glerror(), "gl.TexParameteri")

	gl.TexParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE)
	assert_(no_glerror(), "gl.TexParameteri")

	if (path == "") {
		gl.TexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, 0)
		assert_(no_glerror(), "gl.Image2D")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type target_s struct {
	framebuffer i32
	texture i32
}

func create_target(w i32, h i32) (target target_s) {
	var framebuffer i32 = -1
	var texture i32 = -1

	framebuffer = gl.GenFramebuffers(1, framebuffer)
	assert_(no_glerror(), "gl.GenFramebuffers")
	printf("FRAMEBUFFER_0 : %d\n", framebuffer)

	gl.BindFramebuffer(gl.FRAMEBUFFER, framebuffer)
	assert_(no_glerror(), "gl.BindFramebuffer")
	texture = create_texture("", gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, w, h)

	gl.FramebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0)
	assert_(no_glerror(), "gl.FramebufferTexture2D")

	assert_(no_glstatus(), "gl.CheckFramebufferStatus")

	gl.BindFramebuffer(gl.FRAMEBUFFER, 0)
	assert_(no_glerror(), "gl.BindFramebuffer")
	assert_(no_glstatus(), "gl.CheckFramebufferStatus")

	target.framebuffer = framebuffer
	target.texture = texture
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_program(vertex str, pixel str)(program i32) {

    // vertex shader
    var vertexShader i32 = gl.CreateShader(gl.VERTEX_SHADER)
    assert_(no_glerror(), "gl.CreateShader")
    //shaders = append(shaders, vertexShader) // cache shader creationg
    //++shaderCount

    gl.ShaderSource(vertexShader, 1, vertex)
    assert_(no_glerror(), "gl.ShaderSource")

    gl.CompileShader(vertexShader)
    assert_(no_glerror(), "gl.CompileShader")

    // pixel shader
    var pixelShader i32 = gl.CreateShader(gl.FRAGMENT_SHADER)
    assert_(no_glerror(), "gl.CreateShader")
    //shaders = append(shaders, pixelShader) // cache shader creation
    //++shaderCount

    gl.ShaderSource(pixelShader, 1, pixel)
    assert_(no_glerror(), "gl.ShaderSource")

    gl.CompileShader(pixelShader)
    assert_(no_glerror(), "gl.CompileShader")

    // program
    program = gl.CreateProgram()
    assert_(no_glerror(), "gl.CreateProgram")
    g_programs = append(g_programs, program)
    g_programCount = g_programCount + 1 // pre increment not working

    gl.AttachShader(program, vertexShader)
    assert_(no_glerror(), "gl.AttachShader")

    gl.AttachShader(program, pixelShader)
    assert_(no_glerror(), "gl.AttachShader")

    gl.LinkProgram(program)
    assert_(no_glerror(), "gl.LinkProgram")

    gl.DetachShader(program, vertexShader)
    assert_(no_glerror(), "gl.LinkProgram")

    gl.DetachShader(program, pixelShader)
    assert_(no_glerror(), "gl.DetachShader")

    gl.DeleteShader(vertexShader)
    assert_(no_glerror(), "gl.DeleteShader")

    gl.DeleteShader(pixelShader)
    assert_(no_glerror(), "gl.DeleteShader")

    return program
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func use_program(program i32) {
	//printf("use_program(%d)\n", program)
    gl.UseProgram(program)
	assert_(no_glerror(), "gl.UseProgram")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func bind_attribute(program i32, location i32, name str) () {

    gl.BindAttribLocation(program, location, name)
    assert_(no_glerror(), "gl.BindAttribute")

    var newLocation i32 = gl.GetAttribLocation(program, name)
    assert_(no_glerror(), "gl.GetAttribLocation")
    assert_(newLocation == location, "attribute not found\n")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func bind_texture(program i32, name str) (sampler i32) {
	sampler = bind_uniform(program, name)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func bind_uniform(program i32, name str) (uniform i32) {
    uniform = gl.GetUniformLocation(program, name) // ##2 crash find a way to test if str is present in gl.Strs
    assert_(no_glerror(), "gl.GetUniformLocation")
    assert_(uniform >= 0, "uniform>= 0")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func assign_texture(slot i32, sampler i32, texture i32) () {
    gl.ActiveTexture(gl.TEXTURE0 + slot)
    assert_(no_glerror(), "gl.ActiveTexture")

	gl.BindTexture(gl.TEXTURE_2D, texture)
	assert_(no_glerror(), "gl.BindTexture")

    gl.Uniform1i(sampler, slot)
    assert_(no_glerror(), "gl.Uniform1i")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func assign_float(slot i32, value f32) {
	gl.Uniform1f(slot, value)
	assert_(no_glerror(), "gl.Uniform1f")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type mesh_s struct {
    vertices [540]f32
	attributes [3]i32
    primitive i32
    vao i32
	vbo i32
	stride i32
    floatCount i32
    vertexCount i32
    dataSize i32
    bufferSize i32
	index i32
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func alloc_mesh(mesh *mesh_s, primitive i32, attributes [3]i32, vertexCount i32) () { // make it work with slices

    assert_((primitive == gl.TRIANGLES || primitive == gl.LINES), "(primitive == gl.TRIANGLES || primitive == gl.LINES)")
    assert_(vertexCount > 0, "vertexCount > 0")

    if primitive == gl.TRIANGLES {
        assert_((vertexCount % 3) == 0, "(vertexCount % 3) == 0")
    } else if primitive == gl.LINES {
        assert_((vertexCount % 2) == 0, "(vertexCount % 2) == 0")
    }
    (*mesh).attributes = attributes
    (*mesh).primitive = primitive
    (*mesh).vao = 0
    (*mesh).vbo = 0
	(*mesh).stride = 0
    (*mesh).floatCount = 0
    (*mesh).vertexCount = 0
    (*mesh).dataSize = 0
    (*mesh).bufferSize = 0
    (*mesh).index = 0;

    // stride
    var i i32 = 0
    var attributeCount i32 = len(attributes)
    var stride i32 = 0
    printf("attributeCount %d\n", attributeCount)
    for i = 0; i < attributeCount; i = i + 1 {
        (*mesh).stride = (*mesh).stride + attributes[i]
        stride = stride + attributes[i]
        printf("(*mesh).stride %d, stride %d, attributes[i] %d\n", (*mesh).stride, stride, attributes[i])
    }
    assert_((*mesh).stride > 0, "(*mesh).stride > 0")

    var floatCount i32 = (*mesh).stride * vertexCount
    var bufferSize i32 = floatCount * g_sizeofFloat
    assert_(bufferSize > 0, "bufferSize > 0")
	assert_((floatCount  % (*mesh).stride) == 0, "(floatCount % (*mesh).stride) == 0")
    (*mesh).bufferSize = bufferSize

    // vbo
    (*mesh).vbo = gl.GenBuffers(1, (*mesh).vbo)
    assert_(no_glerror(), "gl.GenBuffers")
    g_vbos = append(g_vbos, (*mesh).vbo)
    g_vboCount = g_vboCount + 1

    gl.BindBuffer(gl.ARRAY_BUFFER, (*mesh).vbo)
    assert_(no_glerror(), "gl.BindBuffer")

    // vao
    (*mesh).vao = gl.GenVertexArrays(1, (*mesh).vao)
    assert_(no_glerror(), "gl.GenVertexArrays")
    g_vaos = append(g_vaos, (*mesh).vao)
    g_vaoCount = g_vaoCount + 1;

    gl.BindVertexArray((*mesh).vao)
    assert_(no_glerror(), "gl.BindVertexArray")

    gl.BindBuffer(gl.ARRAY_BUFFER, (*mesh).vbo)
    assert_(no_glerror(), "gl.BindBuffer")

	printf("bufferSize %d\n", bufferSize)
    //var null *i32 = 0
    var null []f32
    gl.BufferData(gl.ARRAY_BUFFER, bufferSize, null, gl.DYNAMIC_DRAW)
	assert_(no_glerror(), "gl.BufferData")

	var offset i32 = 0
    for i = 0; i < attributeCount; i = i + 1 {
        printf("VertexAttribPointer %d, %d, %d, %d\n", i, attributes[i], (*mesh).stride * g_sizeofFloat, offset)

        gl.EnableVertexAttribArray(i)
        assert_(no_glerror(), "gl.EnableVertexAttribArray")

        gl.VertexAttribPointer(i, attributes[i], gl.FLOAT, false, (*mesh).stride * g_sizeofFloat, offset)
        assert_(no_glerror(), "gl.VertexAttribPointer")

        offset = offset + g_sizeofFloat * attributes[i]
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func begin_mesh(mesh *mesh_s) () {
	(*mesh).index = 0
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func end_mesh(mesh* mesh_s) () {

	if (*mesh).index > 0 {
		(*mesh).floatCount = (*mesh).index //len(g_vertices)
		//printf("floatCount %d\n", (*mesh).floatCount)

		(*mesh).dataSize = (*mesh).floatCount * g_sizeofFloat
		//printf("dataSize %d\n", (*mesh).dataSize)

		//printf("stride %d\n", (*mesh).stride)
		assert_(((*mesh).floatCount % (*mesh).stride) == 0, "((*mesh).floatCount % (*mesh).stride)) == 0")

		(*mesh).vertexCount = (*mesh).floatCount / (*mesh).stride
		//printf("vertexCount %d\n", (*mesh).vertexCount)

		//printf("(*mesh).vbo %d\n", (*mesh).vbo)
		gl.BindBuffer(gl.ARRAY_BUFFER, (*mesh).vbo)
		assert_(no_glerror(), "gl.BindBuffer")

	    gl.BufferSubData(gl.ARRAY_BUFFER, 0, (*mesh).dataSize, (*mesh).vertices)
		assert_(no_glerror(), "gl.BufferSubData")
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_mesh(mesh* mesh_s) {
	gl.BindVertexArray((*mesh).vao)
	assert_(no_glerror(), "gl.BindVertexArray")

    //printf("render mesh %d\n", (*mesh).vertexCount)
	gl.DrawArrays((*mesh).primitive, 0, (*mesh).vertexCount)
	assert_(no_glerror(), "gl.DrawArrays")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func append_line(mesh *mesh_s, x0 f32, y0 f32, x1 f32, y1 f32, r f32, g f32, b f32, a f32) {
	assert_((*mesh).primitive == gl.LINES, "(*mesh).primitive == gl.LINES")

	var index i32 = (*mesh).index
	(*mesh).vertices[index] = x0
	index = index + 1
	(*mesh).vertices[index] = y0
	index = index + 1
	(*mesh).vertices[index] = 0.0
	index = index + 1
	(*mesh).vertices[index] = r
	index = index + 1
	(*mesh).vertices[index] = g
	index = index + 1
	(*mesh).vertices[index] = b
	index = index + 1
	(*mesh).vertices[index] = a
	index = index + 1
	(*mesh).vertices[index] = 0.0
	index = index + 1
	(*mesh).vertices[index] = 0.0
	index = index + 1

	(*mesh).vertices[index] = x1
	index = index + 1
	(*mesh).vertices[index] = y1
	index = index + 1
	(*mesh).vertices[index] = 0.0
	index = index + 1
	(*mesh).vertices[index] = r
	index = index + 1
	(*mesh).vertices[index] = g
	index = index + 1
	(*mesh).vertices[index] = b
	index = index + 1
	(*mesh).vertices[index] = a
	index = index + 1
	(*mesh).vertices[index] = 0.0
	index = index + 1
	(*mesh).vertices[index] = 0.0
	index = index + 1

	(*mesh).index = index
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func append_quad(mesh *mesh_s, x f32, y f32, w f32, h f32, r f32, g f32, b f32, a f32) (){
    assert_((*mesh).primitive == gl.TRIANGLES, "(*mesh).primitive == gl.TRIANGLES")

    var index i32 = (*mesh).index
    var x1 f32 = x + w
    var y1 f32 = y + h

    (*mesh).vertices[index] = x
    index = index + 1
    (*mesh).vertices[index] = y
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1

    (*mesh).vertices[index] = x1
    index = index + 1
    (*mesh).vertices[index] = y
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1

    (*mesh).vertices[index] = x
    index = index + 1
    (*mesh).vertices[index] = y1
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1

    (*mesh).vertices[index] = x
    index = index + 1
    (*mesh).vertices[index] = y1
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1

    (*mesh).vertices[index] = x1
    index = index + 1
    (*mesh).vertices[index] = y
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1

    (*mesh).vertices[index] = x1
    index = index + 1
    (*mesh).vertices[index] = y1
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1
    (*mesh).vertices[index] = r
    index = index + 1
    (*mesh).vertices[index] = g
    index = index + 1
    (*mesh).vertices[index] = b
    index = index + 1
    (*mesh).vertices[index] = a
    index = index + 1
    (*mesh).vertices[index] = 1.0
    index = index + 1
    (*mesh).vertices[index] = 0.0
    index = index + 1


  /*(*mesh).vertices[index + 0] = x
	(*mesh).vertices[index + 1] = y
	(*mesh).vertices[index + 2] = 0.0
	(*mesh).vertices[index + 3] = r
	(*mesh).vertices[index + 4] = g
	(*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
	(*mesh).vertices[index + 7] = 0.0
	(*mesh).vertices[index + 8] = 1.0
	index = index + 9

	(*mesh).vertices[index + 0] = x1
    (*mesh).vertices[index + 1] = y
	(*mesh).vertices[index + 2] = 0.0
	(*mesh).vertices[index + 3] = r
	(*mesh).vertices[index + 4] = g
	(*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
	(*mesh).vertices[index + 7] = 1.0
	(*mesh).vertices[index + 8] = 1.0
	index = index + 9

	(*mesh).vertices[index + 0] = x
	(*mesh).vertices[index + 1] = y1
	(*mesh).vertices[index + 2] = 0.0
	(*mesh).vertices[index + 3] = r
	(*mesh).vertices[index + 4] = g
	(*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
	(*mesh).vertices[index + 7] = 0.0
	(*mesh).vertices[index + 8] = 0.0
	index = index + 9

	(*mesh).vertices[index + 0] = x
	(*mesh).vertices[index + 1] = y1
	(*mesh).vertices[index + 2] = 0.0
	(*mesh).vertices[index + 3] = r
	(*mesh).vertices[index + 4] = g
	(*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
	(*mesh).vertices[index + 7] = 0.0
	(*mesh).vertices[index + 8] = 0.0
	index = index + 9

	(*mesh).vertices[index + 0] = x1
	(*mesh).vertices[index + 1] = y
	(*mesh).vertices[index + 2] = 0.0
	(*mesh).vertices[index + 3] = r
	(*mesh).vertices[index + 4] = g
	(*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
	(*mesh).vertices[index + 7] = 1.0
	(*mesh).vertices[index + 8] = 1.0
	index = index + 9

	(*mesh).vertices[index + 0] = x1
	(*mesh).vertices[index + 1] = y1
	(*mesh).vertices[index + 2] = 0.0
	(*mesh).vertices[index + 3] = r
	(*mesh).vertices[index + 4] = g
	(*mesh).vertices[index + 5] = b
    (*mesh).vertices[index + 6] = a
	(*mesh).vertices[index + 7] = 1.0
	(*mesh).vertices[index + 8] = 0.0
	index = index + 9*/

	(*mesh).index = index
}

//-----------------------------------------------------------------------------
// main
//-----------------------------------------------------------------------------
var g_opaqueVertexColoredTriangles mesh_s
var g_opaqueVertexColoredLines mesh_s

var g_opaqueTexturedTriangles mesh_s

var g_alphaVertexColoredTriangles mesh_s

var g_fullscreenQuad mesh_s

var g_target_0 target_s
var g_target_1 target_s

var g_programVertexColor i32

var g_programTexture i32
var g_albedoSampler i32 // per program, i need a effect struct

var g_programTrans_0 i32
var g_srcSampler i32
var g_dstSampler i32
var g_timeUniform i32

var g_skycoinTexture i32

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type menu_s struct {
	label str
	texture str
	duration f64
	fadein f64
	fadeout f64
	time f64
	prev i32
	next i32
	state i32
	prevState i32
}

var STATE_CLOSED i32 = 0
var STATE_SHOWING i32 = 1
var STATE_OPENED i32 = 2
var STATE_CLOSING i32 = 3

var g_menus [64]menu_s
var g_menuCount i32
var g_currentMenu i32 = -1
var g_nextMenu i32 = -1

var g_transitionDuration f64 = 0.5D
var g_transitionTime f64 = 0.0D

var g_skycoinMenu i32
var g_pumpcxMenu i32
var g_mainMenu i32

var g_width i32 = 800
var g_height i32 = 600
var g_ratio f64

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_menu(label str, texture str, duration f64, prev i32, next i32) (index i32) {
	var menu menu_s

	menu.label = label
	menu.texture = texture
	menu.duration = duration
	menu.prev = prev
	menu.next = next
	menu.state = STATE_CLOSED
	menu.prevState = STATE_CLOSED

	index = g_menuCount
	g_menus[g_menuCount] = menu
	g_menuCount = g_menuCount + 1
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func is_valid_menu(index i32) (value bool) {
	value = ((index >= 0) && (index < g_menuCount))
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func change_menu_state(menu i32, state i32) () {
	assert_(is_valid_menu(menu), "change_menu_state::invalid menu index")
	g_menus[menu].prevState = g_menus[menu].state
	printf("CHANGE %d\n", state)
	g_menus[menu].state = state
	var prev i32 = g_menus[menu].prevState
	var curr i32 = g_menus[menu].state
	if (prev != curr) {
		printf("%s menu state changed %d -> %d\n", g_menus[menu].label, prev, curr)
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func menu_state_changed(menu i32, prev i32, curr i32) (value bool) {
	assert_(is_valid_menu(menu), "menu_state_chaned:: invalid menu index")
	var menuPrev i32 = g_menus[menu].prevState
	var menuCurr i32 = g_menus[menu].state
	value = ((menuPrev == prev) && (menuCurr == curr))
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func update_menu(menu i32, deltaTime f64) () {

	assert_(is_valid_menu(menu), "update_menu::invalid menu index")
	var t f64 = g_menus[menu].time
	var d f64 = g_menus[menu].duration

	g_menus[menu].time = t
	var state i32 = g_menus[menu].state
	if ((t <= 0) && (state == STATE_CLOSED)) {
		printf("CHANGE SHOWING\n")
		change_menu_state(menu, STATE_SHOWING)
	} else if ((t >= d) && (d > 0) && (state == STATE_OPENED)) { // can't use g_menus[menu].state here
		printf("CHANGE CLOSING %d\n", g_menus[menu].state)
		change_menu_state(menu, STATE_CLOSING)
	}

	t = t + deltaTime
	g_menus[menu].time = t
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func update_game(deltaTime f64)() { // rewrite

	if (is_valid_menu(g_currentMenu)) {
		update_menu(g_currentMenu, deltaTime)
		if (menu_state_changed(g_currentMenu, STATE_OPENED, STATE_CLOSING)) {
			g_nextMenu = g_menus[g_currentMenu].next
			g_transitionTime = 0.0D
			g_menus[g_currentMenu].prevState= g_menus[g_currentMenu].state
			printf("menu : %s, STATE_CLOSING\n", g_menus[g_currentMenu].label)
		} else if (menu_state_changed(g_currentMenu, STATE_CLOSING, STATE_CLOSED)) {
			g_menus[g_currentMenu].time = 0.0D
			g_menus[g_currentMenu].prevState= g_menus[g_currentMenu].state
			g_currentMenu = g_nextMenu
			printf("menu : %s, STATE_CLOSED\n")
			printf("CURRENT %d, NEXT %d\n", g_currentMenu, g_nextMenu)
		}
	}

	if (g_currentMenu != g_nextMenu) {
		if (is_valid_menu(g_nextMenu)) {
			update_menu(g_nextMenu, deltaTime)
		}

		if (g_transitionTime <= 0) {
			printf("TRANSITION STARTED %f\n", f64.f32(g_transitionTime + deltaTime))
			g_transitionTime = g_transitionTime + deltaTime
		} else if (g_transitionTime <= g_transitionDuration) {
			g_transitionTime = g_transitionTime + deltaTime
		} else {
			printf("TRANSITION ENDED\n")
			if (is_valid_menu(g_currentMenu)) {
				printf("CHANGE CLOSED\n")
				change_menu_state(g_currentMenu, STATE_CLOSED)
				printf("prev menu : %s, %d, %s\n", g_menus[g_currentMenu].label, g_menus[g_currentMenu].state, "STATE_CLOSED")
			}
			g_currentMenu = g_nextMenu
			if (is_valid_menu(g_nextMenu)) {
				var nextMenu i32 = g_menus[g_nextMenu].next
				printf("CHANGE OPENED\n")
				change_menu_state(g_nextMenu, STATE_OPENED)
				printf("next menu : %s, %d, %s\n", g_menus[g_nextMenu].label, g_menus[g_nextMenu].state, "STATE_OPENED")
				g_transitionTime = 0.0D
			}
		}
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_skycoin_menu() () {
	var tw f32 = 2526.0
	var th f32 = 1600.0
	var tr f32 = tw / th

	var targetW f32 = 1.16
	var targetH f32 = 1.16

	var w f32 = targetW * tr / f64.f32(g_ratio)
	var h f32 = targetH
	var x f32 = -1.0 + (2.0 - w) / 2.0
	var y f32 = -1.0 + (2.0 - h) / 2.0

	begin_mesh(&g_opaqueTexturedTriangles)
	append_quad(&g_opaqueTexturedTriangles, x, y, w, h, 1.0, 1.0, 1.0, 1.0)
	end_mesh(&g_opaqueTexturedTriangles)

    use_program(g_programTexture)
    if g_opaqueTexturedTriangles.index > 0 {
        assign_texture(0, g_albedoSampler, g_skycoinTexture)
        render_mesh(&g_opaqueTexturedTriangles)
    }

	gl.Disable(gl.BLEND)
	assert_(no_glerror(), "gl.Disable(gl.BLEND)")

	gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
	assert_(no_glerror(), "gl.BlendFunc")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_pumpcx_menu() () {
	render_debug()
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_main_menu() () {
	begin_mesh(&g_opaqueVertexColoredTriangles)
	append_quad(&g_opaqueVertexColoredTriangles,  -1.0, -1.0, 2.0, 2.0, 0.0, 114.0 / 255.0, 1.0, 1.0)
	end_mesh(&g_opaqueVertexColoredTriangles)

	// opaque
	gl.Disable(gl.BLEND)
	assert_(no_glerror(), "gl.Disable")

    use_program(g_programVertexColor)
    if g_opaqueVertexColoredTriangles.index > 0 {
        render_mesh(&g_opaqueVertexColoredTriangles)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_menu(menu i32) () {
	       if (menu == g_skycoinMenu) {
			render_skycoin_menu()
	} else if (menu == g_pumpcxMenu) {
			render_pumpcx_menu()
	} else if (menu == g_mainMenu) {
			render_main_menu()
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_debug() () {
	// opaque
	begin_mesh(&g_opaqueTexturedTriangles)
	append_quad(&g_opaqueTexturedTriangles, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0)
	append_quad(&g_opaqueTexturedTriangles,  0.0,  0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0)
	end_mesh(&g_opaqueTexturedTriangles)

	begin_mesh(&g_opaqueVertexColoredTriangles)
	append_quad(&g_opaqueVertexColoredTriangles,  0.0, -1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0)
	append_quad(&g_opaqueVertexColoredTriangles, -1.0,  0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0)
	end_mesh(&g_opaqueVertexColoredTriangles)

    begin_mesh(&g_opaqueVertexColoredLines)
    append_line(&g_opaqueVertexColoredLines, -1.0, -1.0, 1.0,  1.0, 1.0, 1.0, 1.0, 1.0)
    append_line(&g_opaqueVertexColoredLines, -1.0,  1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0)
    end_mesh(&g_opaqueVertexColoredLines)

	// alpha
	begin_mesh(&g_alphaVertexColoredTriangles)
	append_quad(&g_alphaVertexColoredTriangles, -0.5, -0.5, 1.0, 1.0, 0.0, 0.0, 1.0, 0.5)
	end_mesh(&g_alphaVertexColoredTriangles)

	// opaque
	gl.Disable(gl.BLEND)
	assert_(no_glerror(), "gl.Disable")

    use_program(g_programTexture)
    if g_opaqueTexturedTriangles.index > 0 {
        assign_texture(0, g_albedoSampler, g_skycoinTexture)
        render_mesh(&g_opaqueTexturedTriangles)
    }

    use_program(g_programVertexColor)
    if (g_opaqueVertexColoredTriangles.index > 0) {
        render_mesh(&g_opaqueVertexColoredTriangles)
    }

    if g_opaqueVertexColoredLines.index > 0 {
        render_mesh(&g_opaqueVertexColoredLines)
    }

	// alpha
	gl.Enable(gl.BLEND)
	assert_(no_glerror(), "gl.Enable(gl.BLEND)")

	gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
	assert_(no_glerror(), "gl.BlendFunc")

    if g_alphaVertexColoredTriangles.index > 0 {
        render_mesh(&g_alphaVertexColoredTriangles)
    }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func render_game() () {
	gl.BindFramebuffer(gl.FRAMEBUFFER, g_target_0.framebuffer)
	assert_(no_glerror(), "gl.BindFramebuffer")
	gl.Clear(gl.COLOR_BUFFER_BIT)
	assert_(no_glerror(), "gl.Clear")
	if (is_valid_menu(g_currentMenu)) {
		render_menu(g_currentMenu)
	}

	gl.BindFramebuffer(gl.FRAMEBUFFER, g_target_1.framebuffer)
	assert_(no_glerror(), "gl.BindFramebuffer")
	gl.Clear(gl.COLOR_BUFFER_BIT)
	assert_(no_glerror(), "gl.Clear")
	if (is_valid_menu(g_nextMenu)) {
		render_menu(g_nextMenu)
	}

	// fullscreen transition
	gl.BindFramebuffer(gl.FRAMEBUFFER, 0)
	assert_(no_glerror(), "gl.BindFramebuffer")

    gl.Clear(gl.COLOR_BUFFER_BIT)
    assert_(no_glerror(), "gl.Clear")

	gl.Disable(gl.DEPTH_TEST)
	assert_(no_glerror(), "gl.Disable")

	gl.Disable(gl.BLEND)
	assert_(no_glerror(), "gl.Disable")

	use_program(g_programTrans_0)
	assign_texture(0, g_srcSampler, g_target_0.texture)
	assign_texture(1, g_dstSampler, g_target_1.texture)
	assign_float(g_timeUniform, f64.f32(g_transitionTime / g_transitionDuration))
	render_mesh(&g_fullscreenQuad)
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func main() {

	var targetFps f64 = 60.0D

    var window str // inline str init doesn't work
    window = "window"

    var color [4]f32 // inlin array init doesn't work
    color = [4]f32 { 30.0 / 255.0, 34.0 / 255.0, 39.0 / 255.0, 1.0 }

	init_glfw(window, "pumpcx", g_width, g_height, targetFps)
    gl_init(g_width, g_height, color)

    // programs
    g_programVertexColor = create_program("vsPassThrough", "psVertexColor")
    //printf("g_programVertexColor %d\n", g_programVertexColor)
    bind_attribute(g_programVertexColor, 0, "i_v3Position")
    bind_attribute(g_programVertexColor, 1, "i_v4Albedo")

    g_programTexture = create_program("vsPassThrough", "psTexture")
    //printf("g_programTexture %d\n", g_programTexture)
    bind_attribute(g_programTexture, 0, "i_v3Position")
	bind_attribute(g_programTexture, 1, "i_v4Albedo")
    bind_attribute(g_programTexture, 2, "i_v2Texcoord")
    g_albedoSampler = bind_texture(g_programTexture, "u_t2Albedo")

	g_programTrans_0 = create_program("vsPassThrough", "psTransition_0")
	//printf("prgramTrans_0 %d\n", g_programTrans_0)
	bind_attribute(g_programTrans_0, 0, "i_v3Position")
	bind_attribute(g_programTrans_0, 2, "i_v2Texcoord")
	g_srcSampler = bind_texture(g_programTrans_0, "u_t2Src")
	g_dstSampler = bind_texture(g_programTrans_0, "u_t2Dst")
	g_timeUniform = bind_uniform(g_programTrans_0, "u_fTime")

	// textures
	g_skycoinTexture = create_texture("textures/Skycoin-Cloud-BW-Vertical-on_black@2x.png",
		gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, 0, 0)
	//printf("g_skycoinTexture %d\n", g_skycoinTexture)

	// meshes
    var attributes [3]i32
    attributes = [3]i32{3, 4, 2} // can't use slice yet
	alloc_mesh(&g_opaqueVertexColoredTriangles, gl.TRIANGLES, attributes, 1024 * 3)
	alloc_mesh(&g_alphaVertexColoredTriangles, gl.TRIANGLES, attributes, 1024 * 3)
	alloc_mesh(&g_opaqueTexturedTriangles, gl.TRIANGLES, attributes, 1024 * 3)
    alloc_mesh(&g_opaqueVertexColoredLines, gl.LINES, attributes, 1024 * 2)
	alloc_mesh(&g_fullscreenQuad, gl.TRIANGLES, attributes, 6 * 3)

	begin_mesh(&g_fullscreenQuad)
	append_quad(&g_fullscreenQuad, -1.0, 1.0, 2.0, -2.0, 1.0, 1.0, 1.0, 1.0)
	end_mesh(&g_fullscreenQuad)

	// targets
	g_target_0 = create_target(g_width, g_height)
	g_target_1 = create_target(g_width, g_height)

	// menus
	g_skycoinMenu = create_menu("skycoin", "skycoin.png", 3.0D, -1, 1)
	g_pumpcxMenu = create_menu("pumpcx", "", 2.0D, 0, 2)
	g_mainMenu = create_menu("main", "", -2.0D, 1, 2)
	g_nextMenu = g_skycoinMenu

    // main loop
    var fps fps_s = fps_init(targetFps)
    for bool.not(glfw.ShouldClose(window)) {

        fps = fps_begin_update(fps)
        glfw.MakeContextCurrent(window)
		update_game(fps.deltaTime)
		render_game()
        glfw.PollEvents()
        glfw.SwapBuffers(window)
        fps = fps_end_update(fps)
    }

    free_gl()

    printf("dumpcx\n")
}
