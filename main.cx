//-----------------------------------------------------------------------------
// pump-cx
//-----------------------------------------------------------------------------
package main
import "glfw"
import "gl"
import "time"
//-----------------------------------------------------------------------------
// cx bugs
//-----------------------------------------------------------------------------
// multiline array init
// []f32.len()
// else { // comment } unexpected RBRACE
// gl.OUT_OF_MEMOR
// for true { return false }
// if glerror == 0 { break } unexpected RBRACE
// assert doesn't stop program execution
    
//var vertices [9]f32// = [9]f32{0.0, 0.5, 0.0, -0.5, -0.5, 0.0, 0.5, -0.5, 0.0}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/*
// Random Number between -0.6 to 0.6
func randNumGenerator() (rNum f32){
    var sign i32
    sign = i32.rand(0,2) // Random Number between 0, 1

    if sign == 1 {
        rNum = f32.div(i32.rand(1, 6), 10)
    } else {
        rNum = f32.div(i32.rand(1, 6), 10)
        rNum = f32.mul(rNum, -1.0)
    }

}
*/

//-----------------------------------------------------------------------------
// utils
//-----------------------------------------------------------------------------
type fps_s struct {
	currentTime f64
	previousTime f64
	deltaTime f64
	fpsTime f64
	frameTime f64
	fps f64
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func fps_init(targetFps f64)(out fps_s) {
	out.currentTime = glfw.GetTime()
	out.previousTime = out.currentTime
	out.deltaTime = 0.0D
	out.fpsTime = 0.0D
	out.frameTime = 0.0D
	if targetFps > 0.0D {
		out.frameTime = 1.0D / targetFps
	}
	out.fps = 0.0D
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func fps_begin_update(in fps_s) (out fps_s) {

	out = in
	out.currentTime = glfw.GetTime()
	out.deltaTime = out.currentTime - out.previousTime

	if out.currentTime - out.fpsTime > 1.0D {
		out.fpsTime = out.currentTime
		printf("fps : %d\n", f64.i32(out.fps))
		out.fps = 0.0D
	} else {
		out.fps = out.fps + 1.0D;
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func fps_end_update(in fps_s) (out fps_s) {
	out = in

	if out.frameTime > 0.0 {
		var updateTime f64 = glfw.GetTime()
		var	deltaUpdateTime f64 = updateTime - out.currentTime;
		if (deltaUpdateTime < out.frameTime) {
			time.Sleep(f64.i32(1000.0D * (out.frameTime - deltaUpdateTime)))
		}
	}

	out.previousTime = out.currentTime
}

//-----------------------------------------------------------------------------
// glfw
//-----------------------------------------------------------------------------
func keyPressed(window str, key i32, scancode i32, action i32, mods i32) () {
    printf("key pressed : %d, scancode %d, action %d, mods %d\n", key, scancode, action, mods)
    //if key == 32 && action == 1 || key == 265 && action == 1 {
    //}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func init_glfw(window str, name str, width i32, height i32, targetFps f64)() {

    printf("starting %s...\n", name)

    glfw.Init()
    glfw.WindowHint(glfw.Resizable, glfw.False)
    glfw.WindowHint(glfw.ContextVersionMajor, 2)
    glfw.WindowHint(glfw.ContextVersionMinor, 1)
    glfw.CreateWindow(window, 800, 600, name)
    glfw.MakeContextCurrent(window)
	var swapInterval i32 = 0
	if targetFps > 0.0D {
		swapInterval = 1 // should be based on targetFps
	}
    glfw.SwapInterval(swapInterval)
	glfw.SetKeyCallback(window, "keyPressed")
    // xPos, yPos := glfw.GetCursorPos("window")
    // glfw.SetMouseButtonCallback("window", "mouseButton") --> Doesn't work yet
}

//-----------------------------------------------------------------------------
// gl
//-----------------------------------------------------------------------------
var g_vaos []i32
var g_vaoCount i32 = 0

var g_vbos []i32
var g_vboCount i32 = 0

//var g_shaders[]i32
//var g_shaderCount i32 = 0

var g_programs []i32
var g_programCount i32 = 0

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func glerror_2() (error bool) {
	error = false
	var glerr i32 = -1
	for glerr != 0  {
		glerr = gl.GetError()
        if  glerr != 0 {
			error = true
			if glerr == gl.INVALID_ENUM {
                printf("GL_INVALID_ENUM\n")
			} else if glerr == gl.INVALID_VALUE {
                printf("GL_INVALID_VALUE\n")
			} else if glerr == gl.INVALID_OPERATION {
                printf("GL_INVALID_OPERATION\n")
			} else if glerr == gl.STACK_OVERFLOW {
                printf("GL_STACK_OVERFLOW\n")
			} else if glerr == gl.STACK_UNDERFLOW {
                printf("GL_STACK_UNDERFLOW\n")
			} else if glerr == gl.OUT_OF_MEMORY {
                printf("GL_OUT_OF_MEMORY\n")
			} else if glerr != 0 {
				printf("invalid glError\n")
			}
		}
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func no_glerror() (noerror bool) {
	var error bool = glerror_2()
	noerror = error == false // panic if noerror = (glerror_2() == false)
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func init_gl(width i32, height i32, color [4]f32)() {

    gl.Strs("i_v3Position", "i_v3Position")
    gl.Strs("i_v3Color", "i_v3Color")
	gl.Strs("i_v2Texcoord", "i_v2Texcoord")

	//-----------------------------------------------------------------------------
    // vsPassThrough
    //-----------------------------------------------------------------------------
    gl.Strs(
    `
    #version 130
    in vec3 i_v3Position;
    in vec3 i_v3Color;
	in vec2 i_v2Texcoord;
    out vec3 v_v3Color;
	out vec2 v_v2Texcoord;
    void main()
    {
        gl_Position = vec4(i_v3Position.rg, 0.0, 1);
        v_v3Color = i_v3Color;
		v_v2Texcoord = i_v2Texcoord;
    }`, "vsPassThrough")

    //-----------------------------------------------------------------------------
    // psVertexColor
    //-----------------------------------------------------------------------------
    gl.Strs(
    `
    #version 130
    in vec3 v_v3Color;
    out vec4 o_v4Color;
    void main()
    {
        o_v4Color = vec4(v_v3Color, 1);
    }
    `, "psVertexColor")

    //-----------------------------------------------------------------------------
    // psVertexTexture
    //-----------------------------------------------------------------------------
    gl.Strs(
    `
    #version 130
	//uniform sampler2D u_t2Sampler;
    in vec2 v_v2Texcoord;
    out vec4 o_v4Color;
    void main()
    {
        //o_v4Color = vec4(texture2D(u_t2Sampler, v_v2Texcoord).rgb, 1);
		o_v4Color = vec4(v_v2Texcoord.rrr, 1);
    }
    `, "psTexture")

	//-----------------------------------------------------------------------------
    //-----------------------------------------------------------------------------
    gl.Init()
    assert_(no_glerror(), "")

    gl.Disable(gl.BLEND)
    //gl.Enable(gl.BLEND)
    assert_(no_glerror(), "")

    //gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
	//assert_(no_glerror(), "")

    gl.Disable(gl.CULL_FACE)
    assert_(no_glerror(), "")

    gl.Disable(gl.DEPTH_TEST)
    assert_(no_glerror(), "")

    printf("clear color : %f, %f, %f, %f\n", color[0], color[1], color[2], color[3])
    gl.ClearColor(color[0], color[1], color[2], color[3])
    assert_(no_glerror(), "")

    gl.Viewport(0, 0, width, height)
    assert_(no_glerror(), "")

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func free_gl()() {

    gl.Free("vsPassThrough")
    gl.Free("psVertexColor")
	gl.Free("psTexture")
	gl.Free("i_v3Position")
    gl.Free("i_v3Color")
	gl.Free("i_v2Texcoord")

    var i i32

    for i = 0; i < g_programCount; i = i + 1 {
		printf("gl.DeleteProgram(%d)\n", g_programs[i])
		gl.DeleteProgram(g_programs[i])
    }

	for i = 0; i < g_vboCount; i = i + 1 {
		printf("gl.DeleteBuffers(%d)\n", g_vbos[i])
		gl.DeleteBuffers(1, g_vbos[i])
	}

	for i = 0; i < g_vaoCount; i = i + 1 {
		printf("gl.DeleteVertexArrays(%d)\n", g_vaos[i])
		gl.DeleteVertexArrays(1, g_vaos[i])
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func bind_attribute(program i32, location i32, name str) () {

    gl.BindAttribLocation(program, location, name)
    assert_(no_glerror(), "")

    var newLocation i32 = gl.GetAttribLocation(program, name)
    assert_(no_glerror(), "")
    assert_(newLocation == location, "attribute not found\n")
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
func create_program(vertex str, pixel str)(program i32) {

    // vertex shader
    var vertexShader i32 = gl.CreateShader(gl.VERTEX_SHADER)
    assert_(no_glerror(), "")
    //shaders = append(shaders, vertexShader) // cache shader creationg
    //++shaderCount

    gl.ShaderSource(vertexShader, 1, vertex)
    assert_(no_glerror(), "")

    gl.CompileShader(vertexShader)
    assert_(no_glerror(), "")

    // pixel shader
    var pixelShader i32 = gl.CreateShader(gl.FRAGMENT_SHADER)
    assert_(no_glerror(), "")
    //shaders = append(shaders, pixelShader) // cache shader creation
    //++shaderCount

    gl.ShaderSource(pixelShader, 1, pixel)
    assert_(no_glerror(), "")

    gl.CompileShader(pixelShader)
    assert_(no_glerror(), "")

    // program
    program = gl.CreateProgram()
    assert_(no_glerror(), "")
    g_programs = append(g_programs, program)
    g_programCount = g_programCount + 1 // pre increment not working

    gl.AttachShader(program, vertexShader)
    assert_(no_glerror(), "")

    gl.AttachShader(program, pixelShader)
    assert_(no_glerror(), "")

    gl.LinkProgram(program)
    assert_(no_glerror(), "")

    gl.DetachShader(program, vertexShader)
    assert_(no_glerror(), "")

    gl.DetachShader(program, pixelShader)
    assert_(no_glerror(), "")

    gl.DeleteShader(vertexShader)
    assert_(no_glerror(), "")

    gl.DeleteShader(pixelShader)
    assert_(no_glerror(), "")

    return program
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
type mesh_s struct {
	primitive i32
	vao i32
	stride i32
	floatCount i32
	vertexCount i32
	dataSize i32
}

func alloc_mesh(primitive i32, attributes [3]i32, vertexData [48]f32) (mesh mesh_s) { // make it work with slices

	var sizeofFloat i32 = 4

	mesh.primitive = primitive
	mesh.vao = 0
	mesh.stride = 0
	mesh.floatCount = 0
	mesh.vertexCount = 0

	// stride
	var i i32 = 0
	var attributeCount i32

	attributeCount = len(attributes)
	for i = 0; i < attributeCount; i = i + 1 {
		mesh.stride = mesh.stride + attributes[i]
	}

	mesh.floatCount = len(vertexData)
	mesh.dataSize = mesh.floatCount * sizeofFloat

	assert_((mesh.floatCount % mesh.stride) == 0, "invalid vertex data")
	mesh.vertexCount = mesh.floatCount / mesh.stride

	// vbo
    var vbo i32 = 0
    vbo = gl.GenBuffers(1, vbo)
    assert_(no_glerror(), "")
	g_vbos = append(g_vbos, vbo)
	g_vboCount = g_vboCount + 1

    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)
    assert_(no_glerror(), "")

    gl.BufferData(gl.ARRAY_BUFFER, mesh.dataSize, vertexData, gl.DYNAMIC_DRAW)
    assert_(no_glerror(), "")

    // vao
    mesh.vao = gl.GenVertexArrays(1, mesh.vao)
    assert_(no_glerror(), "")
	g_vaos = append(g_vaos, mesh.vao)
	g_vaoCount = g_vaoCount + 1;

    gl.BindVertexArray(mesh.vao)
    assert_(no_glerror(), "")

    gl.EnableVertexAttribArray(0)
    assert_(no_glerror(), "")

    gl.EnableVertexAttribArray(1)
    assert_(no_glerror(), "")

    gl.BindBuffer(gl.ARRAY_BUFFER, vbo)
    assert_(no_glerror(), "")

	var offset i32 = 0
	for i = 0; i < attributeCount; i = i + 1 {
	    gl.VertexAttribPointer(i, attributes[i], gl.FLOAT, false, mesh.stride * sizeofFloat, offset)
		assert_(no_glerror(), "")

		offset = offset + sizeofFloat * attributes[i]
	}
}


//-----------------------------------------------------------------------------
// main
//-----------------------------------------------------------------------------
func main() {
    var width i32 = 800
    var height i32 = 600
	var targetFps f64 = 60.0D

    var window str // inline str init doesn't work
    window = "window"

    var color [4]f32 // inlin array init doesn't work
    color = [4]f32 { 1.0, 0.0, 1.0, 1.0 }

    init_glfw(window, "pump_cx", width, height, targetFps)
    init_gl(width, height, color)

    // program
    var programVertexColor i32 = create_program("vsPassThrough", "psVertexColor")
    bind_attribute(programVertexColor, 0, "i_v3Position")
    bind_attribute(programVertexColor, 1, "i_v3Color")

	// program
    var programTexture i32 = create_program("vsPassThrough", "psTexture")
    bind_attribute(programTexture, 0, "i_v3Position")
	bind_attribute(programTexture, 2, "i_v2Texcoord")

    // mesh
	var attributes [3]i32
	attributes = [3]i32 {3, 3, 2 }

	var vertices [48]f32
    vertices = [48]f32 {
        -0.5, -0.5, 0.0,   1.0, 0.0, 0.0,   0.0, 0.0,
         0.5, -0.5, 0.0,   0.0, 1.0, 0.0,   1.0, 0.0,
        -0.5,  0.5, 0.0,   0.0, 0.0, 1.0,   0.0, 1.0,
        -0.5,  0.5, 0.0,   0.0, 0.0, 1.0,   0.0, 1.0,
         0.5, -0.5, 0.0,   0.0, 1.0, 0.0,   1.0, 0.0,
         0.5,  0.5, 0.0,   1.0, 0.0, 0.0,   1.0, 1.0 }

	var mesh mesh_s = alloc_mesh(gl.TRIANGLES, attributes, vertices)

	// main loop
	var fps fps_s = fps_init(targetFps)
    for bool.not(glfw.ShouldClose(window)) {

		fps = fps_begin_update(fps)

	    glfw.MakeContextCurrent(window)
        gl.Clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
        assert_(no_glerror(), "")

        gl.UseProgram(programVertexColor)
		//gl.UseProgram(programTexture)
        assert_(no_glerror(), "")

        gl.BindVertexArray(mesh.vao)
        assert_(no_glerror(), "")

        gl.DrawArrays(mesh.primitive, 0, mesh.vertexCount)
        assert_(no_glerror(), "")

        glfw.PollEvents()
		glfw.SwapBuffers(window)

		fps = fps_end_update(fps)
    }

    free_gl()

    printf("dump_cx\n")
}
